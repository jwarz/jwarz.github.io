<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Joschka Schwarz">

<title>Joschka Schwarz - Machine Learning with caret in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Joschka Schwarz</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-data-science" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Data Science</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-data-science">    
        <li>
    <a class="dropdown-item" href="../../../../../content/R/index.html">
 <span class="dropdown-text">R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../../content/python/index.html">
 <span class="dropdown-text">Python</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../../content/sql/index.html">
 <span class="dropdown-text">SQL</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../../../slides/index.html">
 <span class="menu-text">Presentations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../resumes/index.html">
 <span class="menu-text">Resumes</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jwarz/"><i class="bi bi-github" role="img" aria-label="Quarto GitHub">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/j-schwarz"><i class="bi bi-linkedin" role="img" aria-label="Quarto LinkedIn">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
                  <a href="" class="quarto-reader-toggle nav-link" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#regression-models-fitting-them-and-evaluating-their-performance" id="toc-regression-models-fitting-them-and-evaluating-their-performance" class="nav-link active" data-scroll-target="#regression-models-fitting-them-and-evaluating-their-performance">1. Regression models: fitting them and evaluating their performance</a>
  <ul class="collapse">
  <li><a href="#welcome-to-the-toolbox" id="toc-welcome-to-the-toolbox" class="nav-link" data-scroll-target="#welcome-to-the-toolbox">Welcome to the Toolbox</a></li>
  <li><a href="#in-sample-rmse-for-linear-regression" id="toc-in-sample-rmse-for-linear-regression" class="nav-link" data-scroll-target="#in-sample-rmse-for-linear-regression">In-sample RMSE for linear regression</a></li>
  <li><a href="#in-sample-rmse-for-linear-regression-on-diamonds" id="toc-in-sample-rmse-for-linear-regression-on-diamonds" class="nav-link" data-scroll-target="#in-sample-rmse-for-linear-regression-on-diamonds">In-sample RMSE for linear regression on diamonds</a></li>
  <li><a href="#out-of-sample-error-measures" id="toc-out-of-sample-error-measures" class="nav-link" data-scroll-target="#out-of-sample-error-measures">Out-of-sample error measures</a></li>
  <li><a href="#out-of-sample-rmse-for-linear-regression" id="toc-out-of-sample-rmse-for-linear-regression" class="nav-link" data-scroll-target="#out-of-sample-rmse-for-linear-regression">Out-of-sample RMSE for linear regression</a></li>
  <li><a href="#randomly-order-the-data-frame" id="toc-randomly-order-the-data-frame" class="nav-link" data-scroll-target="#randomly-order-the-data-frame">Randomly order the data frame</a></li>
  <li><a href="#try-an-8020-split" id="toc-try-an-8020-split" class="nav-link" data-scroll-target="#try-an-8020-split">Try an 80/20 split</a></li>
  <li><a href="#predict-on-test-set" id="toc-predict-on-test-set" class="nav-link" data-scroll-target="#predict-on-test-set">Predict on test set</a></li>
  <li><a href="#calculate-test-set-rmse-by-hand" id="toc-calculate-test-set-rmse-by-hand" class="nav-link" data-scroll-target="#calculate-test-set-rmse-by-hand">Calculate test set RMSE by hand</a></li>
  <li><a href="#comparing-out-of-sample-rmse-to-in-sample-rmse" id="toc-comparing-out-of-sample-rmse-to-in-sample-rmse" class="nav-link" data-scroll-target="#comparing-out-of-sample-rmse-to-in-sample-rmse">Comparing out-of-sample RMSE to in-sample RMSE</a></li>
  <li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation">Cross-validation</a></li>
  <li><a href="#advantage-of-cross-validation" id="toc-advantage-of-cross-validation" class="nav-link" data-scroll-target="#advantage-of-cross-validation">Advantage of cross-validation</a></li>
  <li><a href="#fold-cross-validation" id="toc-fold-cross-validation" class="nav-link" data-scroll-target="#fold-cross-validation">10-fold cross-validation</a></li>
  <li><a href="#fold-cross-validation-1" id="toc-fold-cross-validation-1" class="nav-link" data-scroll-target="#fold-cross-validation-1">5-fold cross-validation</a></li>
  <li><a href="#x-5-fold-cross-validation" id="toc-x-5-fold-cross-validation" class="nav-link" data-scroll-target="#x-5-fold-cross-validation">5 x 5-fold cross-validation</a></li>
  <li><a href="#making-predictions-on-new-data" id="toc-making-predictions-on-new-data" class="nav-link" data-scroll-target="#making-predictions-on-new-data">Making predictions on new data</a></li>
  </ul></li>
  <li><a href="#classification-models-fitting-them-and-evaluating-their-performance" id="toc-classification-models-fitting-them-and-evaluating-their-performance" class="nav-link" data-scroll-target="#classification-models-fitting-them-and-evaluating-their-performance">2. Classification models: fitting them and evaluating their performance</a>
  <ul class="collapse">
  <li><a href="#logistic-regression-on-sonar" id="toc-logistic-regression-on-sonar" class="nav-link" data-scroll-target="#logistic-regression-on-sonar">Logistic regression on sonar</a></li>
  <li><a href="#why-a-traintest-split" id="toc-why-a-traintest-split" class="nav-link" data-scroll-target="#why-a-traintest-split">Why a train/test split?</a></li>
  <li><a href="#try-a-6040-split" id="toc-try-a-6040-split" class="nav-link" data-scroll-target="#try-a-6040-split">Try a 60/40 split</a></li>
  <li><a href="#fit-a-logistic-regression-model" id="toc-fit-a-logistic-regression-model" class="nav-link" data-scroll-target="#fit-a-logistic-regression-model">Fit a logistic regression model</a></li>
  <li><a href="#confusion-matrix" id="toc-confusion-matrix" class="nav-link" data-scroll-target="#confusion-matrix">Confusion matrix</a></li>
  <li><a href="#confusion-matrix-takeaways" id="toc-confusion-matrix-takeaways" class="nav-link" data-scroll-target="#confusion-matrix-takeaways">Confusion matrix takeaways</a></li>
  <li><a href="#calculate-a-confusion-matrix" id="toc-calculate-a-confusion-matrix" class="nav-link" data-scroll-target="#calculate-a-confusion-matrix">Calculate a confusion matrix</a></li>
  <li><a href="#calculating-accuracy" id="toc-calculating-accuracy" class="nav-link" data-scroll-target="#calculating-accuracy">Calculating accuracy</a></li>
  <li><a href="#calculating-true-positive-rate" id="toc-calculating-true-positive-rate" class="nav-link" data-scroll-target="#calculating-true-positive-rate">Calculating true positive rate</a></li>
  <li><a href="#calculating-true-negative-rate" id="toc-calculating-true-negative-rate" class="nav-link" data-scroll-target="#calculating-true-negative-rate">Calculating true negative rate</a></li>
  <li><a href="#class-probabilities-and-predictions" id="toc-class-probabilities-and-predictions" class="nav-link" data-scroll-target="#class-probabilities-and-predictions">Class probabilities and predictions</a></li>
  <li><a href="#probabilities-and-classes" id="toc-probabilities-and-classes" class="nav-link" data-scroll-target="#probabilities-and-classes">Probabilities and classes</a></li>
  <li><a href="#try-another-threshold" id="toc-try-another-threshold" class="nav-link" data-scroll-target="#try-another-threshold">Try another threshold</a></li>
  <li><a href="#from-probabilites-to-confusion-matrix" id="toc-from-probabilites-to-confusion-matrix" class="nav-link" data-scroll-target="#from-probabilites-to-confusion-matrix">From probabilites to confusion matrix</a></li>
  <li><a href="#introducing-the-roc-curve" id="toc-introducing-the-roc-curve" class="nav-link" data-scroll-target="#introducing-the-roc-curve">Introducing the ROC curve</a></li>
  <li><a href="#whats-the-value-of-a-roc-curve" id="toc-whats-the-value-of-a-roc-curve" class="nav-link" data-scroll-target="#whats-the-value-of-a-roc-curve">What’s the value of a ROC curve?</a></li>
  <li><a href="#plot-an-roc-curve" id="toc-plot-an-roc-curve" class="nav-link" data-scroll-target="#plot-an-roc-curve">Plot an ROC curve</a></li>
  <li><a href="#area-under-the-curve-auc" id="toc-area-under-the-curve-auc" class="nav-link" data-scroll-target="#area-under-the-curve-auc">Area under the curve (AUC)</a></li>
  <li><a href="#model-roc-and-auc" id="toc-model-roc-and-auc" class="nav-link" data-scroll-target="#model-roc-and-auc">Model, ROC, and AUC</a></li>
  <li><a href="#customizing-traincontrol" id="toc-customizing-traincontrol" class="nav-link" data-scroll-target="#customizing-traincontrol">Customizing trainControl</a></li>
  <li><a href="#using-custom-traincontrol" id="toc-using-custom-traincontrol" class="nav-link" data-scroll-target="#using-custom-traincontrol">Using custom trainControl</a></li>
  </ul></li>
  <li><a href="#tuning-model-parameters-to-improve-performance" id="toc-tuning-model-parameters-to-improve-performance" class="nav-link" data-scroll-target="#tuning-model-parameters-to-improve-performance">3. Tuning model parameters to improve performance</a>
  <ul class="collapse">
  <li><a href="#random-forests-and-wine" id="toc-random-forests-and-wine" class="nav-link" data-scroll-target="#random-forests-and-wine">Random forests and wine</a></li>
  <li><a href="#random-forests-vs.-linear-models" id="toc-random-forests-vs.-linear-models" class="nav-link" data-scroll-target="#random-forests-vs.-linear-models">Random forests vs.&nbsp;linear models</a></li>
  <li><a href="#fit-a-random-forest" id="toc-fit-a-random-forest" class="nav-link" data-scroll-target="#fit-a-random-forest">Fit a random forest</a></li>
  <li><a href="#explore-a-wider-model-space" id="toc-explore-a-wider-model-space" class="nav-link" data-scroll-target="#explore-a-wider-model-space">Explore a wider model space</a></li>
  <li><a href="#advantage-of-a-longer-tune-length" id="toc-advantage-of-a-longer-tune-length" class="nav-link" data-scroll-target="#advantage-of-a-longer-tune-length">Advantage of a longer tune length</a></li>
  <li><a href="#try-a-longer-tune-length" id="toc-try-a-longer-tune-length" class="nav-link" data-scroll-target="#try-a-longer-tune-length">Try a longer tune length</a></li>
  <li><a href="#custom-tuning-grids" id="toc-custom-tuning-grids" class="nav-link" data-scroll-target="#custom-tuning-grids">Custom tuning grids</a></li>
  <li><a href="#advantages-of-a-custom-tuning-grid" id="toc-advantages-of-a-custom-tuning-grid" class="nav-link" data-scroll-target="#advantages-of-a-custom-tuning-grid">Advantages of a custom tuning grid</a></li>
  <li><a href="#fit-a-random-forest-with-custom-tuning" id="toc-fit-a-random-forest-with-custom-tuning" class="nav-link" data-scroll-target="#fit-a-random-forest-with-custom-tuning">Fit a random forest with custom tuning</a></li>
  <li><a href="#introducing-glmnet" id="toc-introducing-glmnet" class="nav-link" data-scroll-target="#introducing-glmnet">Introducing glmnet</a></li>
  <li><a href="#advantage-of-glmnet" id="toc-advantage-of-glmnet" class="nav-link" data-scroll-target="#advantage-of-glmnet">Advantage of glmnet</a></li>
  <li><a href="#make-a-custom-traincontrol" id="toc-make-a-custom-traincontrol" class="nav-link" data-scroll-target="#make-a-custom-traincontrol">Make a custom trainControl</a></li>
  <li><a href="#fit-glmnet-with-custom-traincontrol" id="toc-fit-glmnet-with-custom-traincontrol" class="nav-link" data-scroll-target="#fit-glmnet-with-custom-traincontrol">Fit glmnet with custom trainControl</a></li>
  <li><a href="#glmnet-with-custom-tuning-grid" id="toc-glmnet-with-custom-tuning-grid" class="nav-link" data-scroll-target="#glmnet-with-custom-tuning-grid">glmnet with custom tuning grid</a></li>
  <li><a href="#why-a-custom-tuning-grid" id="toc-why-a-custom-tuning-grid" class="nav-link" data-scroll-target="#why-a-custom-tuning-grid">Why a custom tuning grid?</a></li>
  <li><a href="#glmnet-with-custom-traincontrol-and-tuning" id="toc-glmnet-with-custom-traincontrol-and-tuning" class="nav-link" data-scroll-target="#glmnet-with-custom-traincontrol-and-tuning">glmnet with custom trainControl and tuning</a></li>
  <li><a href="#interpreting-glmnet-plots" id="toc-interpreting-glmnet-plots" class="nav-link" data-scroll-target="#interpreting-glmnet-plots">Interpreting glmnet plots</a></li>
  </ul></li>
  <li><a href="#preprocessing-your-data" id="toc-preprocessing-your-data" class="nav-link" data-scroll-target="#preprocessing-your-data">4. Preprocessing your data</a>
  <ul class="collapse">
  <li><a href="#median-imputation" id="toc-median-imputation" class="nav-link" data-scroll-target="#median-imputation">Median imputation</a></li>
  <li><a href="#median-imputation-vs.-omitting-rows" id="toc-median-imputation-vs.-omitting-rows" class="nav-link" data-scroll-target="#median-imputation-vs.-omitting-rows">Median imputation vs.&nbsp;omitting rows</a></li>
  <li><a href="#apply-median-imputation" id="toc-apply-median-imputation" class="nav-link" data-scroll-target="#apply-median-imputation">Apply median imputation</a></li>
  <li><a href="#knn-imputation" id="toc-knn-imputation" class="nav-link" data-scroll-target="#knn-imputation">KNN imputation</a></li>
  <li><a href="#comparing-knn-imputation-to-median-imputation" id="toc-comparing-knn-imputation-to-median-imputation" class="nav-link" data-scroll-target="#comparing-knn-imputation-to-median-imputation">Comparing KNN imputation to median imputation</a></li>
  <li><a href="#use-knn-imputation" id="toc-use-knn-imputation" class="nav-link" data-scroll-target="#use-knn-imputation">Use KNN imputation</a></li>
  <li><a href="#compare-knn-and-median-imputation" id="toc-compare-knn-and-median-imputation" class="nav-link" data-scroll-target="#compare-knn-and-median-imputation">Compare KNN and median imputation</a></li>
  <li><a href="#multiple-preprocessing-methods" id="toc-multiple-preprocessing-methods" class="nav-link" data-scroll-target="#multiple-preprocessing-methods">Multiple preprocessing methods</a></li>
  <li><a href="#order-of-operations" id="toc-order-of-operations" class="nav-link" data-scroll-target="#order-of-operations">Order of operations</a></li>
  <li><a href="#combining-preprocessing-methods" id="toc-combining-preprocessing-methods" class="nav-link" data-scroll-target="#combining-preprocessing-methods">Combining preprocessing methods</a></li>
  <li><a href="#handling-low-information-predictors" id="toc-handling-low-information-predictors" class="nav-link" data-scroll-target="#handling-low-information-predictors">Handling low-information predictors</a></li>
  <li><a href="#why-remove-near-zero-variance-predictors" id="toc-why-remove-near-zero-variance-predictors" class="nav-link" data-scroll-target="#why-remove-near-zero-variance-predictors">Why remove near zero variance predictors?</a></li>
  <li><a href="#remove-near-zero-variance-predictors" id="toc-remove-near-zero-variance-predictors" class="nav-link" data-scroll-target="#remove-near-zero-variance-predictors">Remove near zero variance predictors</a></li>
  <li><a href="#preprocess-and-nearzerovar" id="toc-preprocess-and-nearzerovar" class="nav-link" data-scroll-target="#preprocess-and-nearzerovar">preProcess() and nearZeroVar()</a></li>
  <li><a href="#fit-model-on-reduced-blood-brain-data" id="toc-fit-model-on-reduced-blood-brain-data" class="nav-link" data-scroll-target="#fit-model-on-reduced-blood-brain-data">Fit model on reduced blood-brain data</a></li>
  <li><a href="#principle-components-analysis-pca" id="toc-principle-components-analysis-pca" class="nav-link" data-scroll-target="#principle-components-analysis-pca">Principle components analysis (PCA)</a></li>
  <li><a href="#using-pca-as-an-alternative-to-nearzerovar" id="toc-using-pca-as-an-alternative-to-nearzerovar" class="nav-link" data-scroll-target="#using-pca-as-an-alternative-to-nearzerovar">Using PCA as an alternative to nearZeroVar()</a></li>
  </ul></li>
  <li><a href="#selecting-models-a-case-study-in-churn-prediction" id="toc-selecting-models-a-case-study-in-churn-prediction" class="nav-link" data-scroll-target="#selecting-models-a-case-study-in-churn-prediction">5. Selecting models: a case study in churn prediction</a>
  <ul class="collapse">
  <li><a href="#reusing-a-traincontrol" id="toc-reusing-a-traincontrol" class="nav-link" data-scroll-target="#reusing-a-traincontrol">Reusing a trainControl</a></li>
  <li><a href="#why-reuse-a-traincontrol" id="toc-why-reuse-a-traincontrol" class="nav-link" data-scroll-target="#why-reuse-a-traincontrol">Why reuse a trainControl?</a></li>
  <li><a href="#make-custom-traintest-indices" id="toc-make-custom-traintest-indices" class="nav-link" data-scroll-target="#make-custom-traintest-indices">Make custom train/test indices</a></li>
  <li><a href="#reintroducing-glmnet" id="toc-reintroducing-glmnet" class="nav-link" data-scroll-target="#reintroducing-glmnet">Reintroducing glmnet</a></li>
  <li><a href="#glmnet-as-a-baseline-model" id="toc-glmnet-as-a-baseline-model" class="nav-link" data-scroll-target="#glmnet-as-a-baseline-model">glmnet as a baseline model</a></li>
  <li><a href="#fit-the-baseline-model" id="toc-fit-the-baseline-model" class="nav-link" data-scroll-target="#fit-the-baseline-model">Fit the baseline model</a></li>
  <li><a href="#reintroducing-random-forest" id="toc-reintroducing-random-forest" class="nav-link" data-scroll-target="#reintroducing-random-forest">Reintroducing random forest</a></li>
  <li><a href="#random-forest-drawback" id="toc-random-forest-drawback" class="nav-link" data-scroll-target="#random-forest-drawback">Random forest drawback</a></li>
  <li><a href="#random-forest-with-custom-traincontrol" id="toc-random-forest-with-custom-traincontrol" class="nav-link" data-scroll-target="#random-forest-with-custom-traincontrol">Random forest with custom trainControl</a></li>
  <li><a href="#comparing-models" id="toc-comparing-models" class="nav-link" data-scroll-target="#comparing-models">Comparing models</a></li>
  <li><a href="#matching-traintest-indices" id="toc-matching-traintest-indices" class="nav-link" data-scroll-target="#matching-traintest-indices">Matching train/test indices</a></li>
  <li><a href="#create-a-resamples-object" id="toc-create-a-resamples-object" class="nav-link" data-scroll-target="#create-a-resamples-object">Create a resamples object</a></li>
  <li><a href="#more-on-resamples" id="toc-more-on-resamples" class="nav-link" data-scroll-target="#more-on-resamples">More on resamples</a></li>
  <li><a href="#create-a-box-and-whisker-plot" id="toc-create-a-box-and-whisker-plot" class="nav-link" data-scroll-target="#create-a-box-and-whisker-plot">Create a box-and-whisker plot</a></li>
  <li><a href="#create-a-scatterplot" id="toc-create-a-scatterplot" class="nav-link" data-scroll-target="#create-a-scatterplot">Create a scatterplot</a></li>
  <li><a href="#ensembling-models" id="toc-ensembling-models" class="nav-link" data-scroll-target="#ensembling-models">Ensembling models</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/jwarz/jwarz.github.io/edit/main/content/R/topics/07_machine_learning/machine_learning_with_caret/machine_learning_with_caret.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/jwarz/jwarz.github.io/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Machine Learning with caret in R</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Joschka Schwarz </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p><strong>Short Description</strong></p>
<p>This course teaches the big ideas in machine learning: how to build and evaluate predictive models, how to tune them for performance, and how to preprocess data</p>
<p><strong>Long Description</strong></p>
<p>Machine learning is the study and application of algorithms that learn from and make predictions on data. From search results to self-driving cars, it has manifested itself in all areas of our lives and is one of the most exciting and fast growing fields of research in the world of data science. This course teaches the big ideas in machine learning: how to build and evaluate predictive models, how to tune them for optimal performance, how to preprocess data for better results, and much more. The popular <code>caret</code> R package, which provides a consistent interface to all of R’s most powerful machine learning facilities, is used throughout the course.</p>
<section id="regression-models-fitting-them-and-evaluating-their-performance" class="level1">
<h1>1. Regression models: fitting them and evaluating their performance</h1>
<p>In the first chapter of this course, you’ll fit regression models with <code>train()</code> and evaluate their out-of-sample performance using cross-validation and root-mean-square error (RMSE).</p>
<section id="welcome-to-the-toolbox" class="level2">
<h2 class="anchored" data-anchor-id="welcome-to-the-toolbox">Welcome to the Toolbox</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Welcome to the Toolbox</strong></p>
<p>Welcome to the machine learning toolbox course. I’m Max Kuhn, statistician and author of the caret package, which I’ve been working on for over a decade.</p>
<p><strong>2. Supervised Learning</strong></p>
<p>Today caret is one of the most widely used packages in R for supervised learning (also known as predictive modeling).Supervised learning is machine learning when you have a “target variable,” or something specific you want to predict.A classic example of supervised learning is predicting which species an iris is, based on its physical measurements. Another example would be predicting which customers in your business will “churn” or cancel their service.In both of these cases, we have something specific we want to predict on new data: species and churn.</p>
<p><strong>3. Supervised Learning</strong></p>
<p>There are two main kinds of predictive models: classification and regression.Classification models predict qualitative variables, for example the species of a flower, or “will a customer churn”. Regression models predict quantitative variables, for example the price of a diamond.Once we have a model, we use a “metric” to evaluate how well the model works. A metric is quantifiable and gives us an objective measure of how well the model predicts on new data.For regression problems, we will focus on “root mean squared error” or RMSE as our metric of choice.This is the error that linear regression models typically seek to minimize, for example in the lm() function in R. It’s a good, general purpose error metric, and the most common one for regression models.</p>
<p><strong>4. Evaluating Model Performance</strong></p>
<p>Unfortunately, it’s common practice to calculate RMSE on the same data we used to fit the model. This typically leads to overly-optimistic estimates of model performance. This is also known as overfitting.A better approach is to use out-of-sample estimates of model performance.This is the approach caret takes, because it simulates what happens in the real world and helps us avoid over-fitting.</p>
<p><strong>5. In-sample error</strong></p>
<p>However, it’s useful to start off by looking at in-sample error, so we can contrast it later with out-of-sample error on the same dataset.First, we load the mtcars dataset and fit a model to the first 20 rows.Next, we make in-sample predictions, using the predict function on our model.Finally, we calculate RMSE on our training data, and get pretty good results.</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s practice calculating RMSE on some other datasets.</p>
</section>
<section id="in-sample-rmse-for-linear-regression" class="level2">
<h2 class="anchored" data-anchor-id="in-sample-rmse-for-linear-regression">In-sample RMSE for linear regression</h2>
<blockquote class="blockquote">
<h2 id="question" class="anchored"><em>Question</em></h2>
<p>RMSE is commonly calculated in-sample on your training set. What’s a potential drawback to calculating training set error?<br> <br> ⬜ There’s no potential drawback to calculating training set error, but you should calculate \(R^2\) instead of RMSE.<br> ✅ You have no idea how well your model generalizes to new data (i.e.&nbsp;overfitting).<br> ⬜ You should manually inspect your model to validate its coefficients and calculate RMSE.<br></p>
</blockquote>
<p>Correct! Training set error doesn’t tell you anything about the future.</p>
</section>
<section id="in-sample-rmse-for-linear-regression-on-diamonds" class="level2">
<h2 class="anchored" data-anchor-id="in-sample-rmse-for-linear-regression-on-diamonds">In-sample RMSE for linear regression on diamonds</h2>
<p>As you saw in the video, included in the course is the <code>diamonds</code> dataset, which is a classic dataset from the <code>ggplot2</code> package. The dataset contains physical attributes of diamonds as well as the price they sold for. One interesting modeling challenge is predicting diamond price based on their attributes using something like a linear regression.</p>
<p>Recall that to fit a linear regression, you use the <code>lm()</code> function in the following format:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x, my_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To make predictions using <code>mod</code> on the original data, you call the <code>predict()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod, my_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a linear model on the <code>diamonds</code> dataset predicting <code>price</code> using all other variables as predictors (i.e.&nbsp;<code>price ~ .</code>). Save the result to <code>model</code>.</li>
<li>Make predictions using <code>model</code> on the full original dataset and save the result to <code>p</code>.</li>
<li>Compute errors using the formula \(errors = predicted - actual\). Save the result to <code>error</code>.</li>
<li>Compute RMSE using the formula you learned in the video and print it to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Load data</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">data</span>(diamonds, <span class="at">package =</span> <span class="st">"ggplot2"</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># Fit lm model: model</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>model <span class="ot">&lt;-</span> <span class="fu">lm</span>(price <span class="sc">~</span> ., diamonds)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"># Predict on full data: p</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>p <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, diamonds)</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co"># Compute errors: error</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>error <span class="ot">&lt;-</span> p <span class="sc">-</span> diamonds[[<span class="st">"price"</span>]]</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co"># Calculate RMSE</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="fu">sqrt</span>(<span class="fu">mean</span>(error <span class="sc">^</span> <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Now you know how to manually calculate RMSE for your model’s predictions!</p>
</section>
<section id="out-of-sample-error-measures" class="level2">
<h2 class="anchored" data-anchor-id="out-of-sample-error-measures">Out-of-sample error measures</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Out-of-sample error measures</strong></p>
<p>Hi! I’m Zach Deane Mayer, and I’m one of the co-authors of the caret package. I have a passion for data science, and spend most of my time working on and thinking about problems in machine learning.</p>
<p><strong>2. Out-of-sample error</strong></p>
<p>This course focuses on predictive, rather than explanatory modeling. We want models that do not overfit the training data and generalize well. In other words, our primary concern when modeling is “do the models perform well on new data?”The best way to answer this question is to test the models on new data. This simulates real world experience, in which you fit on one dataset, and then predict on new data, where you do not actually know the outcome.Simulating this experience with a train/test split helps you make an honest assessment of yourself as a modeler.This is one of the key insights of machine learning: error metrics should be computed on new data, because in-sample validation (or predicting on your training data) essentially guarantees overfitting.Out-of-sample validation helps you choose models that will continue to perform well in the future.This is the primary goal of the caret package in general and this course specifically: don’t overfit. Pick models that perform well on new data.</p>
<p><strong>3. Example: out-of-sample RMSE</strong></p>
<p>Let’s walk through a simple example of out-of-sample validation: We start with a linear regression model, fit on the first 20 rows of the mtcars dataset.Next, we make predictions with this model on a NEW dataset: the last 12 observations of the mtcars dataset. The 12 cars in this test set will not be used to determine the coefficents of the linear regression model, and are therefore a good test of how well we can predict on new data.In practice, rather than manually splitting the dataset, we’d actually use the createResamples or createFolds function in caret, but the manual split simplifies this example.Finally, we calculate root-mean-squared-error (or RMSE) on the test set by comparing the predictions from our model to the actual MPG values for the test set.RMSE is a measure of the model’s average error. It has the same units as the test set, so this means our model is off by 5 to 6 miles per gallon, on average.</p>
<p><strong>4. Compare to in-sample RMSE</strong></p>
<p>Compared to in-sample RMSE from a model fit on the full dataset, our model is significantly worse.If we had used in-sample error, we would have fooled ourselves into thinking our model is much better than it actually is in reality.It’s hard to make predictions on new data, as this example shows. Out-of-sample error helps account for this fact, so we can focus on models that predict things we don’t already know.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s practice this concept on some example data.</p>
</section>
<section id="out-of-sample-rmse-for-linear-regression" class="level2">
<h2 class="anchored" data-anchor-id="out-of-sample-rmse-for-linear-regression">Out-of-sample RMSE for linear regression</h2>
<blockquote class="blockquote">
<h2 id="question-1" class="anchored"><em>Question</em></h2>
<p>What is the advantage of using a train/test split rather than just validating your model in-sample on the training set?<br> <br> ⬜ It takes less time to calculate error on the test set, since it is smaller than the training set.<br> ⬜ There is no advantage to using a test set. You can just use adjusted \(R^2\) on your training set.<br> ✅ It gives you an estimate of how well your model performs on new data.<br></p>
</blockquote>
<p>Correct! Tests sets are essential for making sure your models will make good predictions.</p>
</section>
<section id="randomly-order-the-data-frame" class="level2">
<h2 class="anchored" data-anchor-id="randomly-order-the-data-frame">Randomly order the data frame</h2>
<p>One way you can take a train/test split of a dataset is to order the dataset randomly, then divide it into the two sets. This ensures that the training set and test set are both random samples and that any biases in the ordering of the dataset (e.g.&nbsp;if it had originally been ordered by price or size) are not retained in the samples we take for training and testing your models. You can think of this like shuffling a brand new deck of playing cards before dealing hands.</p>
<p>First, you set a random seed so that your work is reproducible and you get the same random split each time you run your script:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, you use the <code>sample()</code> function to shuffle the row indices of the <code>diamonds</code> dataset. You can later use these indices to reorder the dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>rows <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(diamonds))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, you can use this random vector to reorder the diamonds dataset:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>diamonds <span class="ot">&lt;-</span> diamonds[rows, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Set the random seed to 42.</li>
<li>Make a vector of row indices called <code>rows</code>.</li>
<li>Randomly reorder the <code>diamonds</code> data frame, assigning to <code>shuffled_diamonds</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># Set seed</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co"># Shuffle row indices: rows</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>rows <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(diamonds))</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co"># Randomly order data</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>shuffled_diamonds <span class="ot">&lt;-</span> diamonds[rows, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great job! Randomly ordering your dataset is important for many machine learning methods.</p>
</section>
<section id="try-an-8020-split" class="level2">
<h2 class="anchored" data-anchor-id="try-an-8020-split">Try an 80/20 split</h2>
<p>Now that your dataset is randomly ordered, you can split the first 80% of it into a training set, and the last 20% into a test set. You can do this by choosing a split point approximately 80% of the way through your data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>split <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">nrow</span>(mydata) <span class="sc">*</span> <span class="fl">0.80</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can then use this point to break off the first 80% of the dataset as a training set:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>mydata[<span class="dv">1</span><span class="sc">:</span>split, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And then you can use that same point to determine the test set:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>mydata[(split <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span><span class="fu">nrow</span>(mydata), ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Choose a row index to split on so that the split point is approximately 80% of the way through the <code>diamonds</code> dataset. Call this index <code>split</code>.</li>
<li>Create a training set called <code>train</code> using that index.</li>
<li>Create a test set called <code>test</code> using that index.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Determine row to split on: split</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>split <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">nrow</span>(diamonds) <span class="sc">*</span> <span class="fl">0.80</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># Create train</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>train <span class="ot">&lt;-</span> diamonds[<span class="dv">1</span><span class="sc">:</span>split, ]</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># Create test</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>test <span class="ot">&lt;-</span> diamonds[(split <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span><span class="fu">nrow</span>(diamonds), ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Well done! Because you already randomly ordered your dataset, it’s easy to split off a random test set.</p>
</section>
<section id="predict-on-test-set" class="level2">
<h2 class="anchored" data-anchor-id="predict-on-test-set">Predict on test set</h2>
<p>Now that you have a randomly split training set and test set, you can use the <code>lm()</code> function as you did in the first exercise to fit a model to your training set, rather than the entire dataset. Recall that you can use the formula interface to the linear regression function to fit a model with a specified target variable using all other variables in the dataset as predictors:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> ., training_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can use the <code>predict()</code> function to make predictions from that model on new data. The new dataset must have all of the columns from the training data, but they can be in a different order with different values. Here, rather than re-predicting on the training set, you can predict on the test set, which you did not use for training the model. This will allow you to determine the out-of-sample error for the model in the next exercise:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>p <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, new_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit an <code>lm()</code> model called <code>model</code> to predict <code>price</code> using all other variables as covariates. Be sure to use the training set, <code>train</code>.</li>
<li>Predict on the test set, <code>test</code>, using <code>predict()</code>. Store these values in a vector called <code>p</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># Fit lm model on train: model</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>model <span class="ot">&lt;-</span> <span class="fu">lm</span>(price <span class="sc">~</span> ., train)</span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co"># Predict on test: p</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>p <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Excellent work! R makes it very easy to predict with a model on new data.</p>
</section>
<section id="calculate-test-set-rmse-by-hand" class="level2">
<h2 class="anchored" data-anchor-id="calculate-test-set-rmse-by-hand">Calculate test set RMSE by hand</h2>
<p>Now that you have predictions on the test set, you can use these predictions to calculate an error metric (in this case RMSE) on the test set and see how the model performs out-of-sample, rather than in-sample as you did in the first exercise. You first do this by calculating the errors between the predicted diamond prices and the actual diamond prices by subtracting the predictions from the actual values.</p>
<p>Once you have an error vector, calculating RMSE is as simple as squaring it, taking the mean, then taking the square root:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="fu">sqrt</span>(<span class="fu">mean</span>(error<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Calculate the error between the predictions on the test set and the actual diamond prices in the test set. Call this <code>error</code>.</li>
<li>Calculate RMSE using this error vector, just printing the result to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Compute errors: error</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>error <span class="ot">&lt;-</span> p <span class="sc">-</span> test[[<span class="st">"price"</span>]]</span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co"># Calculate RMSE</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="fu">sqrt</span>(<span class="fu">mean</span>(error<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Good Job! Calculating RMSE on a test set is exactly the same as calculating it on a training set.</p>
</section>
<section id="comparing-out-of-sample-rmse-to-in-sample-rmse" class="level2">
<h2 class="anchored" data-anchor-id="comparing-out-of-sample-rmse-to-in-sample-rmse">Comparing out-of-sample RMSE to in-sample RMSE</h2>
<blockquote class="blockquote">
<h2 id="question-2" class="anchored"><em>Question</em></h2>
<p>Why is the test set RMSE <em>higher</em> than the training set RMSE?<br> <br> ✅ Because you overfit the training set and the test set contains data the model hasn’t seen before.<br> ⬜ Because you should not use a test set at all and instead just look at error on the training set.<br> ⬜ Because the test set has a smaller sample size the training set and thus the mean error is lower.<br></p>
</blockquote>
<p>Right! Computing the error on the training set is risky because the model may overfit the data used to train it.</p>
</section>
<section id="cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="cross-validation">Cross-validation</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Cross-validation</strong></p>
<p>In the last video, we manually split our data</p>
<p><strong>2. Cross-validation</strong></p>
<p>we manually split our data into a single test set, and evaluated out-of-sample error once.</p>
<p><strong>3. Cross-validation</strong></p>
<p>However, this process is a little fragile: the presence or absence of a single outlier can vastly change our out-of-sample RMSE.</p>
<p><strong>4. Cross-validation</strong></p>
<p>A better approach than a simple train/test split is using multiple test sets and averaging out-of-sample error, which gives us a more precise estimate of true out-of-sample error. One of the most common approaches for multiple test sets is known as “cross-validation”, in which we split our data into ten “folds” or train/test splits. We create these folds in such a way that each point in our dataset occurs in exactly one test set. This gives us 10 test sets, and better yet, means that every single point in our dataset occurs exactly once. In other words, we get a test set that is the same size as our training set, but is composed of out-of-sample predictions!</p>
<p><strong>5. Cross-validation</strong></p>
<p>We assign each row to its single test set randomly, to avoid any kind of systemic biases in our data. This is one of the best ways to estimate out-of-sample error for predictive models.</p>
<p><strong>6. Fit final model on full dataset</strong></p>
<p>One important note: after doing cross-validation, you throw all resampled models away and start over! Cross-validation is only used to estimate the out-of-sample error for your model. Once you know this, you re-fit your model on the full training dataset, so as to fully exploit the information in that dataset.</p>
<p><strong>7. Fit final model on full dataset</strong></p>
<p>This, by definition, makes cross-validation very expensive: it inherently takes 11 times as long as fitting a single model (10 cross-validation models plus the final model). The train function in caret does a different kind of re-sampling known as bootstrap validation, but is also capable of doing cross-validation, and the two methods in practice yield similar results.</p>
<p><strong>8. Cross-validation</strong></p>
<p>Lets fit a cross-validated model to the mtcars dataset. First, we set the random seed, since cross-validation randomly assigns rows to each fold and we want to be able to reproduce our model exactly. The train function has a formula interface, which is identical to the formula interface for the lm function in base R. However, it supports fitting hundreds of different models, which are easily specified with the “method” argument. In this case, we fit a linear regression model, but we could just as easily specify method = ‘rf’ and fit a random forest model, without changing any of our code. This is the second most useful feature of the caret package, behind cross-validation of models: it provides a common interface to hundreds of different predictive models. The trControl argument controls the parameters caret uses for cross-validation. In this course, we will mostly use 10-fold cross-validation, but this flexible function supports many other cross-validation schemes. Additionally, we provide the verboseIter = TRUE argument, which gives us a progress log as the model is being fit and lets us know if we have time to get coffee while the models run.</p>
<p><strong>9. Let’s practice!</strong></p>
<p>Let’s practice cross-validating some models.</p>
</section>
<section id="advantage-of-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="advantage-of-cross-validation">Advantage of cross-validation</h2>
<blockquote class="blockquote">
<h2 id="question-3" class="anchored"><em>Question</em></h2>
<p>What is the advantage of cross-validation over a single train/test split?<br> <br> ⬜ There is no advantage to cross-validation, just as there is no advantage to a single train/test split. You should be validating your models in-sample with a metric like adjusted \(R^2\).<br> ⬜ You can pick the best test set to minimize the reported RMSE of your model.<br> ✅ It gives you multiple estimates of out-of-sample error, rather than a single estimate.<br></p>
</blockquote>
<p>Correct! If all of your estimates give similar outputs, you can be more certain of the model’s accuracy. If your estimates give different outputs, that tells you the model does not perform consistently and suggests a problem with it.</p>
</section>
<section id="fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="fold-cross-validation">10-fold cross-validation</h2>
<p>As you saw in the video, a better approach to validating models is to use multiple systematic test sets, rather than a single random train/test split. Fortunately, the <code>caret</code> package makes this very easy to do:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(y <span class="sc">~</span> ., my_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>caret</code> supports many types of cross-validation, and you can specify which type of cross-validation and the number of cross-validation folds with the <code>trainControl()</code> function, which you pass to the <code>trControl</code> argument in <code>train()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb18-2"><a href="#cb18-2"></a>  y <span class="sc">~</span> ., </span>
<span id="cb18-3"><a href="#cb18-3"></a>  my_data,</span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="at">method =</span> <span class="st">"lm"</span>,</span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb18-6"><a href="#cb18-6"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="at">number =</span> <span class="dv">10</span>,</span>
<span id="cb18-8"><a href="#cb18-8"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>  )</span>
<span id="cb18-10"><a href="#cb18-10"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It’s important to note that you pass the method for modeling to the main <code>train()</code> function and the method for cross-validation to the <code>trainControl()</code> function.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a linear regression to model <code>price</code> using all other variables in the <code>diamonds</code> dataset as predictors. Use the <code>train()</code> function and 10-fold cross-validation. (Note that we’ve taken a subset of the full <code>diamonds</code> dataset to speed up this operation, but it’s still named <code>diamonds</code>.)</li>
<li>Print the model to the console and examine the results.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># Load package</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="fu">library</span>(caret)</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co"># Fit lm model using 10-fold CV: model</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb19-6"><a href="#cb19-6"></a>  price <span class="sc">~</span> ., </span>
<span id="cb19-7"><a href="#cb19-7"></a>  diamonds,</span>
<span id="cb19-8"><a href="#cb19-8"></a>  <span class="at">method =</span> <span class="st">"lm"</span>,</span>
<span id="cb19-9"><a href="#cb19-9"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="at">number =</span> <span class="dv">10</span>,</span>
<span id="cb19-12"><a href="#cb19-12"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb19-13"><a href="#cb19-13"></a>  )</span>
<span id="cb19-14"><a href="#cb19-14"></a>)</span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co"># Print model to console</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Good job! Caret does all the work of splitting test sets and calculating RMSE for you!</p>
</section>
<section id="fold-cross-validation-1" class="level2">
<h2 class="anchored" data-anchor-id="fold-cross-validation-1">5-fold cross-validation</h2>
<p>In this course, you will use a wide variety of datasets to explore the full flexibility of the <code>caret</code> package. Here, you will use the famous Boston housing dataset, where the goal is to predict median home values in various Boston suburbs.</p>
<p>You can use exactly the same code as in the previous exercise, but change the dataset used by the model:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb20-2"><a href="#cb20-2"></a>  medv <span class="sc">~</span> ., </span>
<span id="cb20-3"><a href="#cb20-3"></a>  BostonHousing, </span>
<span id="cb20-4"><a href="#cb20-4"></a>  <span class="at">method =</span> <span class="st">"lm"</span>,</span>
<span id="cb20-5"><a href="#cb20-5"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb20-7"><a href="#cb20-7"></a>    <span class="at">number =</span> <span class="dv">10</span>,</span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>  )</span>
<span id="cb20-10"><a href="#cb20-10"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, you can reduce the number of cross-validation folds from 10 to 5 using the <code>number</code> argument to the <code>trainControl()</code> argument:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>trControl <span class="ot">=</span> <span class="fu">trainControl</span>(</span>
<span id="cb21-2"><a href="#cb21-2"></a>  <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb21-3"><a href="#cb21-3"></a>  <span class="at">number =</span> <span class="dv">5</span>,</span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit an <code>lm()</code> model to the <code>Boston</code> housing dataset, such that <code>medv</code> is the response variable and all other variables are explanatory variables.</li>
<li>Use 5-fold cross-validation rather than 10-fold cross-validation.</li>
<li>Print the model to the console and inspect the results.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="co"># Load package (for the dataset)</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="fu">library</span>(mlbench)</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="fu">data</span>(BostonHousing)</span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="co"># Fit lm model using 5-fold CV: model</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb22-7"><a href="#cb22-7"></a>  medv <span class="sc">~</span> ., </span>
<span id="cb22-8"><a href="#cb22-8"></a>  BostonHousing,</span>
<span id="cb22-9"><a href="#cb22-9"></a>  <span class="at">method =</span> <span class="st">"lm"</span>,</span>
<span id="cb22-10"><a href="#cb22-10"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="at">number =</span> <span class="dv">5</span>,</span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>  )</span>
<span id="cb22-15"><a href="#cb22-15"></a>)</span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a><span class="co"># Print model to console</span></span>
<span id="cb22-18"><a href="#cb22-18"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Caret makes it easy to try different validation schemes with the same model and compare RMSE.</p>
</section>
<section id="x-5-fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="x-5-fold-cross-validation">5 x 5-fold cross-validation</h2>
<p>You can do more than just one iteration of cross-validation. Repeated cross-validation gives you a better estimate of the test-set error. You can also repeat the entire cross-validation procedure. This takes longer, but gives you many more out-of-sample datasets to look at and much more precise assessments of how well the model performs.</p>
<p>One of the awesome things about the <code>train()</code> function in <code>caret</code> is how easy it is to run very different models or methods of cross-validation just by tweaking a few simple arguments to the function call. For example, you could repeat your entire cross-validation procedure 5 times for greater confidence in your estimates of the model’s out-of-sample accuracy, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>trControl <span class="ot">=</span> <span class="fu">trainControl</span>(</span>
<span id="cb23-2"><a href="#cb23-2"></a>  <span class="at">method =</span> <span class="st">"repeatedcv"</span>, </span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="at">number =</span> <span class="dv">5</span>,</span>
<span id="cb23-4"><a href="#cb23-4"></a>  <span class="at">repeats =</span> <span class="dv">5</span>, </span>
<span id="cb23-5"><a href="#cb23-5"></a>  <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Re-fit the linear regression model to the <code>BostonHousing</code> housing dataset.</li>
<li>Use 5 repeats of 5-fold cross-validation.</li>
<li>Print the model to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># Fit lm model using 5 x 5-fold CV: model</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb24-3"><a href="#cb24-3"></a>  medv <span class="sc">~</span> ., </span>
<span id="cb24-4"><a href="#cb24-4"></a>  BostonHousing,</span>
<span id="cb24-5"><a href="#cb24-5"></a>  <span class="at">method =</span> <span class="st">"lm"</span>,</span>
<span id="cb24-6"><a href="#cb24-6"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="at">method =</span> <span class="st">"repeatedcv"</span>, </span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="at">number =</span> <span class="dv">5</span>,</span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="at">repeats =</span> <span class="dv">5</span>, </span>
<span id="cb24-10"><a href="#cb24-10"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>  )</span>
<span id="cb24-12"><a href="#cb24-12"></a>)</span>
<span id="cb24-13"><a href="#cb24-13"></a></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="co"># Print model to console</span></span>
<span id="cb24-15"><a href="#cb24-15"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Fantastic work! You can use caret to do some very complicated cross-validation schemes.</p>
</section>
<section id="making-predictions-on-new-data" class="level2">
<h2 class="anchored" data-anchor-id="making-predictions-on-new-data">Making predictions on new data</h2>
<p>Finally, the model you fit with the <code>train()</code> function has the exact same <code>predict()</code> interface as the linear regression models you fit earlier in this chapter.</p>
<p>After fitting a model with <code>train()</code>, you can simply call <code>predict()</code> with new data, e.g:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="fu">predict</span>(my_model, new_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use the <code>predict()</code> function to make predictions with <code>model</code> on the full <code>Boston</code> housing dataset. Print the result to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="co"># Predict on full Boston dataset</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="fu">predict</span>(model, BostonHousing)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Awesome job! Predicting with a caret model is as easy as predicting with a regular model!</p>
</section>
</section>
<section id="classification-models-fitting-them-and-evaluating-their-performance" class="level1">
<h1>2. Classification models: fitting them and evaluating their performance</h1>
<p>In this chapter, you’ll fit classification models with <code>train()</code> and evaluate their out-of-sample performance using cross-validation and area under the curve (AUC).</p>
<section id="logistic-regression-on-sonar" class="level2">
<h2 class="anchored" data-anchor-id="logistic-regression-on-sonar">Logistic regression on sonar</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Logistic regression on sonar</strong></p>
<p>Classification models differ from regression models</p>
<p><strong>2. Classification models</strong></p>
<p>in that you’re trying to predict a categorical target. For example, predicting whether or not a loan will default.This is still a form of supervised learning, like with regression problems. As before, we can use a train/test split to explore how well our model generalizes to new data.In this chapter, we’ll be working with the ‘sonar’ dataset, a classic statistics dataset which contains some characteristics of a sonar signal for objects that are either rocks or mines. The goal here is to train a classifier that can reliably distinguish rocks from mines.</p>
<p><strong>3. Example: Sonar data</strong></p>
<p>Let’s load the sonar dataset and take a look at it. Note that the target is either “R” for rock and “M” for mine and most of the predictors are numbers measuring some aspect of a sonar signal.</p>
<p><strong>4. Splitting the data</strong></p>
<p>Analyzing sonar and radar signals was one of the original applications of machine learning. As with the diamonds and Boston housing datasets in the previous chapter, we’ll start by splitting the dataset randomly into training and test sets.This time; however, we’ll do a 60/40 split, instead of 80/20. The sonar dataset is very small, so a 40% split gives us a more reliable test set. It would be even better to use multiple 80/20 splits and average the results of each 20% split.We’ll discuss this idea in more detail later.</p>
<p><strong>5. Splitting the data</strong></p>
<p>First, we randomly order the dataset. This is important to avoid bias in our train/test split and make sure we get a representative sample of the whole dataset.Next, we identify a row that’s about 60% of the way through the dataset. This row will be the last observation in our training set.Finally, we check that our training set is 60% of the entire dataset.</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s practice making train/test splits.</p>
</section>
<section id="why-a-traintest-split" class="level2">
<h2 class="anchored" data-anchor-id="why-a-traintest-split">Why a train/test split?</h2>
<blockquote class="blockquote">
<h2 id="question-4" class="anchored"><em>Question</em></h2>
<p>What is the point of making a train/test split for binary classification problems?<br> <br> ⬜ To make the problem harder for the model by reducing the dataset size.<br> ✅ To evaluate your models out-of-sample, on new data.<br> ⬜ To reduce the dataset size, so your models fit faster.<br> ⬜ There is no real reason; it is no different than evaluating your models in-sample.<br></p>
</blockquote>
<p>Correct! Out-of-sample evaluation is the gold standard of model validation.</p>
</section>
<section id="try-a-6040-split" class="level2">
<h2 class="anchored" data-anchor-id="try-a-6040-split">Try a 60/40 split</h2>
<p>As you saw in the video, you’ll be working with the <code>Sonar</code> dataset in this chapter, using a 60% training set and a 40% test set. We’ll practice making a train/test split one more time, just to be sure you have the hang of it. Recall that you can use the <code>sample()</code> function to get a random permutation of the row indices in a dataset, to use when making train/test splits, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>n_obs <span class="ot">&lt;-</span> <span class="fu">nrow</span>(my_data)</span>
<span id="cb27-2"><a href="#cb27-2"></a>permuted_rows <span class="ot">&lt;-</span> <span class="fu">sample</span>(n_obs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And then use those row indices to randomly reorder the dataset, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>my_data <span class="ot">&lt;-</span> my_data[permuted_rows, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once your dataset is randomly ordered, you can split off the first 60% as a training set and the last 40% as a test set.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Get the number of observations (rows) in <code>Sonar</code>, assigning to <code>n_obs</code>.</li>
<li>Shuffle the row indices of <code>Sonar</code> and store the result in <code>permuted_rows</code>.</li>
<li>Use <code>permuted_rows</code> to randomly reorder the rows of <code>Sonar</code>, saving as <code>Sonar_shuffled</code>.</li>
<li>Identify the proper row to split on for a 60/40 split. Store this row number as <code>split</code>.</li>
<li>Save the first 60% of <code>Sonar_shuffled</code> as a training set.</li>
<li>Save the last 40% of <code>Sonar_shuffled</code> as the test set.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># Load data (from mlbench package)</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="co"># sonar_train &lt;- readRDS("data/sonar_train.rds")</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="co"># sonar_test  &lt;- readRDS("data/sonar_test.rds")</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="fu">data</span>(Sonar)</span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="co"># Get the number of observations</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>n_obs <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Sonar)</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="co"># Shuffle row indices: permuted_rows</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>permuted_rows <span class="ot">&lt;-</span> <span class="fu">sample</span>(n_obs)</span>
<span id="cb29-11"><a href="#cb29-11"></a></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="co"># Randomly order data: Sonar</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>Sonar_shuffled <span class="ot">&lt;-</span> Sonar[permuted_rows, ]</span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="co"># Identify row to split on: split</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>split <span class="ot">&lt;-</span> <span class="fu">round</span>(n_obs <span class="sc">*</span> <span class="fl">0.6</span>)</span>
<span id="cb29-17"><a href="#cb29-17"></a></span>
<span id="cb29-18"><a href="#cb29-18"></a><span class="co"># Create train</span></span>
<span id="cb29-19"><a href="#cb29-19"></a>train <span class="ot">&lt;-</span> Sonar_shuffled[<span class="dv">1</span><span class="sc">:</span>split, ]</span>
<span id="cb29-20"><a href="#cb29-20"></a></span>
<span id="cb29-21"><a href="#cb29-21"></a><span class="co"># Create test</span></span>
<span id="cb29-22"><a href="#cb29-22"></a>test <span class="ot">&lt;-</span> Sonar_shuffled[(split <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>n_obs, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Excellent work! Randomly shuffling your data makes it easy to manually create a train/test split.</p>
</section>
<section id="fit-a-logistic-regression-model" class="level2">
<h2 class="anchored" data-anchor-id="fit-a-logistic-regression-model">Fit a logistic regression model</h2>
<p>Once you have your random training and test sets you can fit a logistic regression model to your training set using the <code>glm()</code> function. <code>glm()</code> is a more advanced version of <code>lm()</code> that allows for more varied types of regression models, aside from plain vanilla ordinary least squares regression.</p>
<p>Be sure to pass the argument <code>family = "binomial"</code> to <code>glm()</code> to specify that you want to do logistic (rather than linear) regression. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="fu">glm</span>(Target <span class="sc">~</span> ., <span class="at">family =</span> <span class="st">"binomial"</span>, dataset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Don’t worry about warnings like <code>glm.fit: algorithm did not converge</code> or <code>glm.fit: fitted probabilities numerically 0 or 1 occurred</code>. These are common on smaller datasets and usually don’t cause any issues. They typically mean your dataset is <em>perfectly separable</em>, which can cause problems for the math behind the model, but R’s <code>glm()</code> function is almost always robust enough to handle this case with no problems.</p>
<p>Once you have a <code>glm()</code> model fit to your dataset, you can predict the outcome (e.g.&nbsp;rock or mine) on the <code>test</code> set using the <code>predict()</code> function with the argument <code>type = "response"</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="fu">predict</span>(my_model, test, <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a logistic regression called <code>model</code> to predict <code>Class</code> using all other variables as predictors. Use the training set for <code>Sonar</code>.</li>
<li>Predict on the <code>test</code> set using that model. Call the result <code>p</code> like you’ve done before.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># Load package</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb32-3"><a href="#cb32-3"></a></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="co"># Load data</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>train <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/sonar_train.rds"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb32-6"><a href="#cb32-6"></a>  </span>
<span id="cb32-7"><a href="#cb32-7"></a>                  <span class="co"># Create numeric target</span></span>
<span id="cb32-8"><a href="#cb32-8"></a>                  <span class="fu">mutate</span>(<span class="at">Class_num =</span> <span class="fu">as.numeric</span>(Class <span class="sc">==</span> <span class="st">"M"</span>))</span>
<span id="cb32-9"><a href="#cb32-9"></a>                  </span>
<span id="cb32-10"><a href="#cb32-10"></a>                  <span class="co"># mutate(Class = case_when(Class == "M" ~ 1, </span></span>
<span id="cb32-11"><a href="#cb32-11"></a>                  <span class="co">#                          Class == "R" ~ 0))</span></span>
<span id="cb32-12"><a href="#cb32-12"></a></span>
<span id="cb32-13"><a href="#cb32-13"></a>test  <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/sonar_test.rds"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb32-14"><a href="#cb32-14"></a>  </span>
<span id="cb32-15"><a href="#cb32-15"></a>                  <span class="co"># Create numeric target</span></span>
<span id="cb32-16"><a href="#cb32-16"></a>                  <span class="fu">mutate</span>(<span class="at">Class_num =</span> <span class="fu">as.numeric</span>(Class <span class="sc">==</span> <span class="st">"M"</span>))</span>
<span id="cb32-17"><a href="#cb32-17"></a></span>
<span id="cb32-18"><a href="#cb32-18"></a><span class="co"># Fit glm model: model</span></span>
<span id="cb32-19"><a href="#cb32-19"></a>model <span class="ot">&lt;-</span> <span class="fu">glm</span>(Class_num <span class="sc">~</span> ., train <span class="sc">|&gt;</span> <span class="fu">select</span>(<span class="sc">-</span>Class), <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb32-20"><a href="#cb32-20"></a></span>
<span id="cb32-21"><a href="#cb32-21"></a><span class="co"># Predict on test: p</span></span>
<span id="cb32-22"><a href="#cb32-22"></a>p <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, test <span class="sc">|&gt;</span> <span class="fu">select</span>(<span class="sc">-</span>Class), <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Manually fitting a glm model in R is very similar to fitting an lm model.</p>
</section>
<section id="confusion-matrix" class="level2">
<h2 class="anchored" data-anchor-id="confusion-matrix">Confusion matrix</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Confusion matrix</strong></p>
<p>A really useful tool for evaluating binary classification models is known as a “confusion matrix”. This is a matrix of the model’s predicted classes vs the actual outcomes in reality.It’s called a confusion matrix because it reveals how “confused” the model is between the 2 classes, and highlights instances in which one class is confused for the other.</p>
<p><strong>2. Confusion matrix</strong></p>
<p>The columns of the confusion matrix are the true classes, while the rows of the confusion matrix are the predicted classes. From left-to-right, top-to-bottom, the cells of the matrix are: true positives, false positives, false negatives, and true negatives.The main diagonal of the confusion matrix is the cases where the model is correct (true positives and true negatives) and the second diagonal of the confusion matrix is the cases where the model is incorrect (false negatives and false positives).Let’s briefly review the 4 possible outcomes with a binary classification model: True positives are cases where the model correctly predicted yes. False positives are cases where the model incorrectly predicted yes. False negatives are cases where the model incorrectly predicted no. And True negatives are cases where the model correctly predicted no.All 4 of these outcomes are important when evaluating a predictive model’s accuracy, so it’s useful to look at them simultaneously in a single table.</p>
<p><strong>3. Confusion matrix</strong></p>
<p>To generate a confusion matrix, we start by fitting a model to our training set. In this case, we’ll use a simple logistic regression model.Next, we predict on the test set, and cut the predicted probabilities with a threshold to get class assignments.In other words, the logistic regression model outputs the probability that an object is a mine, but we need to use these probabilities to make a binary decision: rock or mine.In the simplest case, we use a probability of 50% as our cutoff, and assign anything under 50% as a rock and anything over 50% as a mine.</p>
<p><strong>4. Confusion matrix</strong></p>
<p>Next we make a 2-way frequency table, using the “table” function in R. This table reveals a high number of false positives and false negatives: our model is frequently wrong.</p>
<p><strong>5. Confusion matrix</strong></p>
<p>Rather than calculate our error rate by hand, we’ll now let the “confusionMatrix” function in caret do it for us. This function provides the same 2-way frequency table as the table function in base R, but outputs a number of useful statistics as well.The most useful statistic in this table is the accuracy, which is not very impressive.Compare this to the “no information rate” or the case where we always predict the dominant class, which is mines. At about 50%, the no information rate reveals that using a dummy model that always predicts mines is more accurate than our logistic regression!</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s practice calculating confusion matrices.</p>
</section>
<section id="confusion-matrix-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="confusion-matrix-takeaways">Confusion matrix takeaways</h2>
<blockquote class="blockquote">
<h2 id="question-5" class="anchored"><em>Question</em></h2>
<p>What information does a confusion matrix provide?<br> <br> ⬜ True positive rates<br> ⬜ True negative rates<br> ⬜ False positive rates<br> ⬜ False negative rates<br> ✅ All of the above<br></p>
</blockquote>
<p>Yes! It contains all of them.</p>
</section>
<section id="calculate-a-confusion-matrix" class="level2">
<h2 class="anchored" data-anchor-id="calculate-a-confusion-matrix">Calculate a confusion matrix</h2>
<p>As you saw in the video, a confusion matrix is a very useful tool for calibrating the output of a model and examining all possible outcomes of your predictions (true positive, true negative, false positive, false negative).</p>
<p>Before you make your confusion matrix, you need to “cut” your predicted probabilities at a given threshold to turn probabilities into a factor of class predictions. Combine <code>ifelse()</code> with <code>factor()</code> as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a>pos_or_neg <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(probability_prediction <span class="sc">&gt;</span> threshold, positive_class, negative_class)</span>
<span id="cb33-2"><a href="#cb33-2"></a>p_class    <span class="ot">&lt;-</span> <span class="fu">factor</span>(pos_or_neg, <span class="at">levels =</span> <span class="fu">levels</span>(test_values))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>confusionMatrix()</code> in <code>caret</code> improves on <code>table()</code> from base R by adding lots of useful ancillary statistics in addition to the base rates in the table. You can calculate the confusion matrix (and the associated statistics) using the predicted outcomes as well as the actual outcomes, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="fu">confusionMatrix</span>(p_class, test_values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use <code>ifelse()</code> to create a character vector, <code>m_or_r</code> that is the positive class, <code>"M"</code>, when <code>p</code> is greater than 0.5, and the negative class, <code>"R"</code>, otherwise.</li>
<li>Convert <code>m_or_r</code> to be a factor, <code>p_class</code>, with levels the same as those of <code>test[["Class"]]</code>.</li>
<li>Make a confusion matrix with <code>confusionMatrix()</code>, passing <code>p_class</code> and the <code>"Class"</code> column from the <code>test</code> dataset.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># If p exceeds threshold of 0.5, M else R: m_or_r</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>m_or_r <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(p <span class="sc">&gt;</span> <span class="fl">0.5</span>, <span class="st">"M"</span>, <span class="st">"R"</span>)</span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="co"># Convert to factor: p_class</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>p_class <span class="ot">&lt;-</span> <span class="fu">factor</span>(m_or_r, <span class="at">levels =</span> <span class="fu">levels</span>(test[[<span class="st">"Class"</span>]]))</span>
<span id="cb35-6"><a href="#cb35-6"></a></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="co"># Create confusion matrix</span></span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="fu">confusionMatrix</span>(p_class, test[[<span class="st">"Class"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! The confusionMatrix function is a very easy way to get a detailed summary of your model’s accuracy.</p>
</section>
<section id="calculating-accuracy" class="level2">
<h2 class="anchored" data-anchor-id="calculating-accuracy">Calculating accuracy</h2>
<p>Use <code>confusionMatrix(p_class, test[["Class"]])</code> to calculate a confusion matrix on the test set.</p>
<blockquote class="blockquote">
<h2 id="question-6" class="anchored"><em>Question</em></h2>
<p>What is the test set accuracy of this model (rounded to the nearest percent)?<br> <br> ⬜ 58%<br> ⬜ 83%<br> ✅ 70%<br> ⬜ 51%<br></p>
</blockquote>
<p>Nice one! This is the model’s accuracy.</p>
</section>
<section id="calculating-true-positive-rate" class="level2">
<h2 class="anchored" data-anchor-id="calculating-true-positive-rate">Calculating true positive rate</h2>
<p>Use <code>confusionMatrix(p_class, test[["Class"]])</code> to calculate a confusion matrix on the test set.</p>
<blockquote class="blockquote">
<h2 id="question-7" class="anchored"><em>Question</em></h2>
<p>What is the test set true positive rate (or sensitivity) of this model (rounded to the nearest percent)?<br> <br> ⬜ 58%<br> ✅ 83%<br> ⬜ 70%<br> ⬜ 51%<br></p>
</blockquote>
<p>Nice one!</p>
</section>
<section id="calculating-true-negative-rate" class="level2">
<h2 class="anchored" data-anchor-id="calculating-true-negative-rate">Calculating true negative rate</h2>
<p>Use <code>confusionMatrix(p_class, test[["Class"]])</code> to calculate a confusion matrix on the test set.</p>
<blockquote class="blockquote">
<h2 id="question-8" class="anchored"><em>Question</em></h2>
<p>What is the test set true negative rate (or specificity) of this model (rounded to the nearest percent)?<br> <br> ⬜ 58%<br> ⬜ 83%<br> ⬜ 70%<br> ✅ 51%<br></p>
</blockquote>
<p>Good job!</p>
</section>
<section id="class-probabilities-and-predictions" class="level2">
<h2 class="anchored" data-anchor-id="class-probabilities-and-predictions">Class probabilities and predictions</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Class probabilities and predictions</strong></p>
<p>In the previous video, we worked through an example confusion matrix using 50% as the classification cutoff threshold.</p>
<p><strong>2. Different thresholds</strong></p>
<p>However, we’re not limited to using this threshold. For example, if we wanted to catch more mines (at the expense of more false positives), we could use a cutoff of 10%. On the other hand, if we wanted to be more certain of our predicted mines (at the expense of catching fewer of them) we could use 90% as our threshold.In other words, choosing a threshold is an exercise in balancing the true positive rate (or percent of mines we catch) with the false positive rate (or percent of non-mines we incorrectly flag as mines). Choosing a threshold is therefore very important, and also somewhat dependent on a cost-benefit analysis of the problem at hand.Unfortunately, there’s not a good heuristic for choosing prediction thresholds ahead of time. You usually have to use a confusion matrix on your test set to find a good threshold.</p>
<p><strong>3. Confusion matrix</strong></p>
<p>Let’s work through an example and pretend we want fewer predicted mines, with a greater degree of certainty in each prediction. To do this, we could use a larger cutoff value on our predicted probabilities, for example 99% rather than 50%, and make the same 2-way frequency table we used in the previous exercise.</p>
<p><strong>4. Confusion matrix with caret</strong></p>
<p>As before, we can also use caret’s helper functions to calculate the statistics associated with this confusion matrix. In this case, we get an accuracy of 30%, which is better than our last attempt, but still far below the 51% accuracy of the no-information model that always predicts mines.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Lets play around with some more confusion thresholds and see if we can manually find a good classification threshold for our rocks vs mines model.</p>
</section>
<section id="probabilities-and-classes" class="level2">
<h2 class="anchored" data-anchor-id="probabilities-and-classes">Probabilities and classes</h2>
<blockquote class="blockquote">
<h2 id="question-9" class="anchored"><em>Question</em></h2>
<p>What’s the relationship between the predicted probabilities and the predicted classes?<br> <br> ⬜ You determine the predicted probabilities by looking at the average accuracy of the predicted classes.<br> ⬜ There is no relationship; they’re completely different things.<br> ✅ Predicted classes are based off of predicted probabilities plus a classification threshold.<br></p>
</blockquote>
<p>Correct! Probabilities are used to determine classes.</p>
</section>
<section id="try-another-threshold" class="level2">
<h2 class="anchored" data-anchor-id="try-another-threshold">Try another threshold</h2>
<p>In the previous exercises, you used a threshold of 0.50 to cut your predicted probabilities to make class predictions (rock vs mine). However, this classification threshold does not always align with the goals for a given modeling problem.</p>
<p>For example, pretend you want to identify the objects you are really certain are mines. In this case, you might want to use a probability threshold of 0.90 to get <em>fewer predicted mines, but with greater confidence in each prediction</em>.</p>
<p>The code pattern for cutting probabilities into predicted classes, then calculating a confusion matrix, was shown in Exercise 7 of this chapter.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use <code>ifelse()</code> to create a character vector, <code>m_or_r</code> that is the positive class, <code>"M"</code>, when <code>p</code> is greater than <strong>0.9</strong>, and the negative class, <code>"R"</code>, otherwise.</li>
<li>Convert <code>m_or_r</code> to be a factor, <code>p_class</code>, with levels the same as those of <code>test[["Class"]]</code>.</li>
<li>Make a confusion matrix with <code>confusionMatrix()</code>, passing <code>p_class</code> and the <code>"Class"</code> column from the <code>test</code> dataset.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a><span class="co"># If p exceeds threshold of 0.9, M else R: m_or_r</span></span>
<span id="cb36-2"><a href="#cb36-2"></a>m_or_r <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(p <span class="sc">&gt;</span> <span class="fl">0.9</span>, <span class="st">"M"</span>, <span class="st">"R"</span>)</span>
<span id="cb36-3"><a href="#cb36-3"></a></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="co"># Convert to factor: p_class</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>p_class <span class="ot">&lt;-</span> <span class="fu">factor</span>(m_or_r, <span class="at">levels =</span> <span class="fu">levels</span>(test[[<span class="st">"Class"</span>]]))</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="co"># Create confusion matrix</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="fu">confusionMatrix</span>(p_class, test[[<span class="st">"Class"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Amazing! Note that there are (slightly) fewer predicted mines with this higher threshold: 55 (40 + 15) as compared to 57 for the 0.50 threshold.</p>
</section>
<section id="from-probabilites-to-confusion-matrix" class="level2">
<h2 class="anchored" data-anchor-id="from-probabilites-to-confusion-matrix">From probabilites to confusion matrix</h2>
<p>Conversely, say you want to be really certain that your model correctly identifies all the mines as mines. In this case, you might use a prediction threshold of 0.10, instead of 0.90.</p>
<p>The code pattern for cutting probabilities into predicted classes, then calculating a confusion matrix, was shown in Exercise 7 of this chapter.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use <code>ifelse()</code> to create a character vector, <code>m_or_r</code> that is the positive class, <code>"M"</code>, when <code>p</code> is greater than <strong>0.1</strong>, and the negative class, <code>"R"</code>, otherwise.</li>
<li>Convert <code>m_or_r</code> to be a factor, <code>p_class</code>, with levels the same as those of <code>test[["Class"]]</code>.</li>
<li>Make a confusion matrix with <code>confusionMatrix()</code>, passing <code>p_class</code> and the <code>"Class"</code> column from the <code>test</code> dataset.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a><span class="co"># If p exceeds threshold of 0.1, M else R: m_or_r</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>m_or_r <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(p <span class="sc">&gt;</span> <span class="fl">0.1</span>, <span class="st">"M"</span>, <span class="st">"R"</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="co"># Convert to factor: p_class</span></span>
<span id="cb37-5"><a href="#cb37-5"></a>p_class <span class="ot">&lt;-</span> <span class="fu">factor</span>(m_or_r, <span class="at">levels =</span> <span class="fu">levels</span>(test[[<span class="st">"Class"</span>]]))</span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="co"># Create confusion matrix</span></span>
<span id="cb37-8"><a href="#cb37-8"></a><span class="fu">confusionMatrix</span>(p_class, test[[<span class="st">"Class"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Awesome! Note that there are (slightly) more predicted mines with this lower threshold: 58 (40 + 18) as compared to 47 for the 0.50 threshold.</p>
</section>
<section id="introducing-the-roc-curve" class="level2">
<h2 class="anchored" data-anchor-id="introducing-the-roc-curve">Introducing the ROC curve</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Introducing the ROC curve</strong></p>
<p>Manually evaluating classification thresholds is hard work!</p>
<p><strong>2. The challenge</strong></p>
<p>In order to do this correctly, we’d have to manually calculate dozens (or hundreds) of confusion matrices, and then visually inspect them until we find one we like.This seems un-scientific, as it requires a lot of manual work, is heuristic-based, and could easily overlook a particular important threshold. We need a more systematic approach to evaluating classification thresholds.</p>
<p><strong>3. ROC curves</strong></p>
<p>One common approach to this problem is to let the computer iteratively evaluate every possible classification threshold and then calculate the true-positive rate and false-positive rate for each of them. We can then plot the true postive / false positive rate at every possible threshold, and visualize the trade-off between the 2 extreme models (predict all mines vs predict all rocks, or 100% true positive rate vs 0% false positive rate).The resulting curve is called a ROC curve, or receiver operating characteristic curve. (Don’t worry, no one actually remembers that acronym.) The ROC curve was developed during World War 2 as a method of analyzing radar signals. In this historically interesting case, a true positive would be correctly identifying a bomber by it’s radar signal, while a false positive would be identifying a flock of birds as a bomber.</p>
<p><strong>4. An example ROC curve</strong></p>
<p>Let’s take a look at a ROC curve for one of our models from the previous video. We use our predicted probabilities along with the actual classes as inputs to the colAUC function from the caTools package. If we specify the argument plotROC = TRUE, the function also plots the ROC curve for us.Here, the X axis is the false positive rate, the y axis is the true positive rate, and we can see each possible prediction threshold as a point on the curve. Each of these points represents a confusion matrix we didn’t have to evaluate by hand.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s practice creating some ROC curves.</p>
</section>
<section id="whats-the-value-of-a-roc-curve" class="level2">
<h2 class="anchored" data-anchor-id="whats-the-value-of-a-roc-curve">What’s the value of a ROC curve?</h2>
<blockquote class="blockquote">
<h2 id="question-10" class="anchored"><em>Question</em></h2>
<p>What is the primary value of an ROC curve?<br> <br> ⬜ It has a cool acronym.<br> ⬜ It can be used to determine the true positive and false positive rates for a particular classification threshold.<br> ✅ It evaluates all possible thresholds for splitting predicted probabilities into predicted classes.<br></p>
</blockquote>
<p>Yes! ROC curves let you evaluate how good a model is, without worry about calibrating its probabilities.</p>
</section>
<section id="plot-an-roc-curve" class="level2">
<h2 class="anchored" data-anchor-id="plot-an-roc-curve">Plot an ROC curve</h2>
<p>As you saw in the video, an ROC curve is a really useful shortcut for summarizing the performance of a classifier over all possible thresholds. This saves you a lot of tedious work computing class predictions for many different thresholds and examining the confusion matrix for each.</p>
<p>My favorite package for computing ROC curves is <code>caTools</code>, which contains a function called <code>colAUC()</code>. This function is very user-friendly and can actually calculate ROC curves for multiple predictors at once. In this case, you only need to calculate the ROC curve for one predictor, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="fu">colAUC</span>(predicted_probabilities, actual, <span class="at">plotROC =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function will return a score called AUC (more on that later) and the <code>plotROC = TRUE</code> argument will return the plot of the ROC curve for visual inspection.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Predict probabilities (i.e.&nbsp;<code>type = "response"</code>) on the test set, then store the result as <code>p</code>.</li>
<li>Make an ROC curve using the predicted test set probabilities.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># Load package</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="fu">library</span>(caTools)</span>
<span id="cb39-3"><a href="#cb39-3"></a></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="co"># Predict on test: p</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>p <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, test, <span class="at">type =</span> <span class="st">"response"</span>)</span>
<span id="cb39-6"><a href="#cb39-6"></a></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="co"># Make ROC curve</span></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="fu">colAUC</span>(p, test[[<span class="st">"Class"</span>]], <span class="at">plotROC =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! The colAUC function makes plotting a roc curve as easy as calculating a confusion matrix.</p>
</section>
<section id="area-under-the-curve-auc" class="level2">
<h2 class="anchored" data-anchor-id="area-under-the-curve-auc">Area under the curve (AUC)</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Area under the curve (AUC)</strong></p>
<p>Just looking at a ROC curves starts to give us a good idea of how to evaluate whether or not our predictive model is any good.</p>
<p><strong>2. From ROC to AUC</strong></p>
<p>One interesting observation is that models with random predictions tend to produce curves that closely follow the diagonal line. On the other hand, models with a classification threshold that allows for perfect separation of classes produce a “box” with a single point at (1,0) to represent a model where it is possible to achieve a 100% true positive rate and 0% false positive rate. Wouldn’t that be nice?Continuing with this example, if we calculate the area under each of these 2 ROC curves, an interesting property emerges: the area under the curve for a perfect model is exactly 1, as our plot represents a 1 by 1 square, and the average area under the curve for a random model is point-5, as our plot represents a diagonal line.</p>
<p><strong>3. Defining AUC</strong></p>
<p>We can use this insight to formalize a measure of model accuracy known as “AUC” or “area under the curve.” This metric is calculated based on the ROC curve plot, and is extremely useful. Its a single-number summary of the model’s accuracy that does not requires us to manually evaluate confusion matrices.This number summarizes the model’s performance across all possible classification thresholds, and is a single metric we can use to rank different models within the same dataset.</p>
<p><strong>4. Defining AUC</strong></p>
<p>It ranges from 0 to 1, where point-5 is the AUC of a random model and 1-point-0 is the AUC of a perfect model. (A perfectly anti-predictive model would have an AUC of 0, but that rarely happens).In practice most models fall between point-5 and 1-point-0, while a really bad model can occasionally be in the point-4 range. As a very rough rule of thumb, AUC can be thought of as a letter grade, where point-9 is an “A”, point-8 is a “B”, point-7 is a “C”, point-5 is an “F”, and so on. I’m generally happy with a model that has an AUC of point-8 or higher, and models in the point-7 range are often useful.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Fortunately, the caret package automates calculating the area under the ROC curve for us. Let’s practice making use of this versatile metric.</p>
</section>
<section id="model-roc-and-auc" class="level2">
<h2 class="anchored" data-anchor-id="model-roc-and-auc">Model, ROC, and AUC</h2>
<blockquote class="blockquote">
<h2 id="question-11" class="anchored"><em>Question</em></h2>
<p>What is the AUC of a perfect model?<br> <br> ⬜ 0.00<br> ⬜ 0.50<br> ✅ 1.00<br></p>
</blockquote>
<p>Correct! A perfect model has an AUC of 1.</p>
</section>
<section id="customizing-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="customizing-traincontrol">Customizing trainControl</h2>
<p>As you saw in the video, area under the ROC curve is a very useful, single-number summary of a model’s ability to discriminate the positive from the negative class (e.g.&nbsp;mines from rocks). An AUC of 0.5 is no better than random guessing, an AUC of 1.0 is a perfectly predictive model, and an AUC of 0.0 is perfectly anti-predictive (which rarely happens).</p>
<p>This is often a much more useful metric than simply ranking models by their accuracy at a set threshold, as different models might require different calibration steps (looking at a confusion matrix at each step) to find the optimal classification threshold for that model.</p>
<p>You can use the <code>trainControl()</code> function in <code>caret</code> to use AUC (instead of acccuracy), to tune the parameters of your models. The <code>twoClassSummary()</code> convenience function allows you to do this easily.</p>
<p>When using <code>twoClassSummary()</code>, be sure to always include the argument <code>classProbs = TRUE</code> or your model will throw an error! (You cannot calculate AUC with just class predictions. You need to have class probabilities as well.)</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Customize the <code>trainControl</code> object to use <code>twoClassSummary</code> rather than <code>defaultSummary</code>.</li>
<li>Use 10-fold cross-validation.</li>
<li>Be sure to tell <code>trainControl()</code> to return class probabilities.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="co"># Create trainControl object: myControl</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>myControl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(</span>
<span id="cb40-3"><a href="#cb40-3"></a>  <span class="at">method =</span> <span class="st">"cv"</span>,</span>
<span id="cb40-4"><a href="#cb40-4"></a>  <span class="at">number =</span> <span class="dv">10</span>,</span>
<span id="cb40-5"><a href="#cb40-5"></a>  <span class="at">summaryFunction =</span> twoClassSummary,</span>
<span id="cb40-6"><a href="#cb40-6"></a>  <span class="at">classProbs =</span> <span class="cn">TRUE</span>, <span class="co"># IMPORTANT!</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>  <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Don’t forget the classProbs argument to train control, especially if you’re going to calculate AUC or logloss.</p>
</section>
<section id="using-custom-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="using-custom-traincontrol">Using custom trainControl</h2>
<p>Now that you have a custom <code>trainControl</code> object, it’s easy to fit <code>caret</code> models that use AUC rather than accuracy to tune and evaluate the model. You can just pass your custom <code>trainControl</code> object to the <code>train()</code> function via the <code>trControl</code> argument, e.g.:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a><span class="fu">train</span>(<span class="sc">&lt;</span>standard arguments here<span class="sc">&gt;</span>, <span class="at">trControl =</span> myControl)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This syntax gives you a convenient way to store a lot of custom modeling parameters and then use them across multiple different calls to <code>train()</code>. You will make extensive use of this trick in Chapter 5.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use <code>train()</code> to predict <code>Class</code> from all other variables in the <code>Sonar</code> data (that is, <code>Class ~ .</code>). It should be a <code>glm</code> model (that is, set <code>method</code> to <code>"glm"</code>) using your custom <code>trainControl</code> object, <code>myControl</code>. Save the result to <code>model</code>.</li>
<li>Print the model to the console and examine its output.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="co"># Train glm with custom trainControl: model</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb42-3"><a href="#cb42-3"></a>  Class <span class="sc">~</span> ., </span>
<span id="cb42-4"><a href="#cb42-4"></a>  Sonar, </span>
<span id="cb42-5"><a href="#cb42-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span>,</span>
<span id="cb42-6"><a href="#cb42-6"></a>  <span class="at">trControl =</span> myControl</span>
<span id="cb42-7"><a href="#cb42-7"></a>)</span>
<span id="cb42-8"><a href="#cb42-8"></a></span>
<span id="cb42-9"><a href="#cb42-9"></a><span class="co"># Print model to console</span></span>
<span id="cb42-10"><a href="#cb42-10"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Note that fitting a glm with caret often produces warnings about convergence or probabilities. These warnings can almost always be safely ignored, as you can use the glm’s predictions to validate whether the model is accurate enough for your task.</p>
</section>
</section>
<section id="tuning-model-parameters-to-improve-performance" class="level1">
<h1>3. Tuning model parameters to improve performance</h1>
<p>In this chapter, you will use the <code>train()</code> function to tweak model parameters through cross-validation and grid search.</p>
<section id="random-forests-and-wine" class="level2">
<h2 class="anchored" data-anchor-id="random-forests-and-wine">Random forests and wine</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Random forests and wine</strong></p>
<p>Now that we’ve explored simple, linear models for classification and regression, lets move on to something more interesting.</p>
<p><strong>2. Random forests</strong></p>
<p>Random forests are a very popular type of machine learning model. They are very useful, especially for beginners, because they are quite robust against over-fitting.Random forests typically yield very accurate, non-linear models with no extra work on the part of the data scientist. This makes them very useful on many real-world problems.</p>
<p><strong>3. Random forests</strong></p>
<p>The drawback to random forests is that, unlike linear models, they have “hyperparameters” to tune; and unlike regular parameters, for instance slope or intercept in a linear model, hyperparameters cannot be directly estimated from the training data. They must be manually specified by the data scientist as inputs to the predictive model.However, these hyperparameters can impact how the model fits the data, and the optimal values for these parameters vary dataset to dataset. In practice, the default values of the hyperparameters for random forests are often fine, but occasionally they aren’t and will need adjustment.Fortunately, we have the caret package to help us.</p>
<p><strong>4. Random forests</strong></p>
<p>Random forests start with a simple decision tree model, which is fast, but usually not very accurate.</p>
<p><strong>5. Random forests</strong></p>
<p>Random forests improve the accuracy of a single model by fitting many decision trees, each fit to a different bootstrap sample of the original dataset.This is called bootstrap aggregation or bagging, and is a well-known technique for improving the performance of predictive models.Random forests take bagging one step further by randomly re-sampling the columns of the dataset at each split. This additional level of sampling often helps yield even more accurate models.</p>
<p><strong>6. Running a random forest</strong></p>
<p>Let’s fit a random forest using caret.First, we load the sonar dataset, and then set the random seed so our results are reproducible.Next, we fit a model using the train function, and pass the “ranger” argument to fit a random forest. Ranger is a great package for fitting random forests in R, and is often much faster than the original randomForest package in R.Finally, we plot the result, to see which hyperparameters for the random forest give the best results.</p>
<p><strong>7. Plotting the results</strong></p>
<p>Finally, we plot the result, to see which hyperparameters for the random forest give the best results.In this case it looks like smaller values yield higher accuracy.</p>
<p><strong>8. Let’s practice!</strong></p>
<p>Let’s practice fitting some random forests.</p>
</section>
<section id="random-forests-vs.-linear-models" class="level2">
<h2 class="anchored" data-anchor-id="random-forests-vs.-linear-models">Random forests vs.&nbsp;linear models</h2>
<blockquote class="blockquote">
<h2 id="question-12" class="anchored"><em>Question</em></h2>
<p>What’s the primary advantage of random forests over linear models?<br> <br> ⬜ They make you sound cooler during job interviews.<br> ⬜ You can’t understand what’s going on inside of a random forest model, so you don’t have to explain it to anyone.<br> ✅ A random forest is a more flexible model than a linear model, but just as easy to fit.<br></p>
</blockquote>
<p>Correct! Random forests are very powerful non-linear models, but are also very easy to fit.</p>
</section>
<section id="fit-a-random-forest" class="level2">
<h2 class="anchored" data-anchor-id="fit-a-random-forest">Fit a random forest</h2>
<p>As you saw in the video, random forest models are much more flexible than linear models, and can model complicated nonlinear effects as well as automatically capture interactions between variables. They tend to give very good results on real world data, so let’s try one out on the wine quality dataset, where the goal is to predict the human-evaluated quality of a batch of wine, given some of the machine-measured chemical and physical properties of that batch.</p>
<p>Fitting a random forest model is exactly the same as fitting a generalized linear regression model, as you did in the previous chapter. You simply change the <code>method</code> argument in the <code>train</code> function to be <code>"ranger"</code>. The <code>ranger</code> package is a rewrite of R’s classic <code>randomForest</code> package and fits models much faster, but gives almost exactly the same results. We suggest that all beginners use the <code>ranger</code> package for random forest modeling.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Train a random forest called <code>model</code> on the wine quality dataset, <code>wine</code>, such that <code>quality</code> is the response variable and all other variables are explanatory variables.</li>
<li>Use <code>method = "ranger"</code>.</li>
<li>Use a <code>tuneLength</code> of 1.</li>
<li>Use 5 CV folds.</li>
<li>Print <code>model</code> to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="co"># Load data</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>wine <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/wine_100.rds"</span>)</span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="co"># Fit random forest: model</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb43-6"><a href="#cb43-6"></a>  quality <span class="sc">~</span> .,</span>
<span id="cb43-7"><a href="#cb43-7"></a>  <span class="at">tuneLength =</span> <span class="dv">1</span>,</span>
<span id="cb43-8"><a href="#cb43-8"></a>  <span class="at">data =</span> wine, </span>
<span id="cb43-9"><a href="#cb43-9"></a>  <span class="at">method =</span> <span class="st">"ranger"</span>,</span>
<span id="cb43-10"><a href="#cb43-10"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="at">number =</span> <span class="dv">5</span>, </span>
<span id="cb43-13"><a href="#cb43-13"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb43-14"><a href="#cb43-14"></a>  )</span>
<span id="cb43-15"><a href="#cb43-15"></a>)</span>
<span id="cb43-16"><a href="#cb43-16"></a></span>
<span id="cb43-17"><a href="#cb43-17"></a><span class="co"># Print model to console</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Awesome job! Fitting a random forest is just as easy as fitting a glm. Caret makes it very easy to try out many different models.</p>
</section>
<section id="explore-a-wider-model-space" class="level2">
<h2 class="anchored" data-anchor-id="explore-a-wider-model-space">Explore a wider model space</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Explore a wider model space</strong></p>
<p>One of the big differences between a random forest and the linear regression models we’ve been exploring up to now, is that random forests require “tuning”.</p>
<p><strong>2. Random forests require tuning</strong></p>
<p>In other words, random forests have “hyperparameters” that control how the model is fit. Unlike the “parameters” of a model (for example the split points in random forests or coefficients in linear regression), hyperparameters must be selected by hand, before fitting the model.The most important of these hyperparameters is the “mtry” or the number of randomly selected variables used at each split point in the individual decision tress that make up the random forest.This number is tunable: you could look at as few as 2 or as many as 100 variables per split. Forests that used 2 variables would tend to be more random, while forests that used 100 variables would tend to be less random.Unfortunately, due to their nature, it’s hard to know the best value of these hyperparameters without trying them out on your training data. For some datasets, 2-variable random forests are best, and on other datasets, 100-variable random forests are best.</p>
<p><strong>3. Example: sonar data</strong></p>
<p>Once again, caret saves us a lot of boring manual work and automates this process of hyperparameter selection. Not only does caret do cross-validation to tell us our model’s out-of-sample error, it also automates a process called “grid search” for selecting hyperparameters based on out-of-sample error.To start, we can play with the tuneLength argument to the train function. This argument is used to tell train to explore more models along its default tuning grid. First, we load the Sonar dataset from the mlbench package, and then we fit a random forest with a very fine tuning grid by specifying tuneLength = 10.This will take longer than the default model, which uses a tunelength of 3. This means we get a potentially more accurate model, but at the expense of waiting much longer for it to run.Also note that we’re using the method = ‘ranger’ argument to the train function. This uses the ranger package in R to fit a random forest, which is much faster than the more widely known randomForest package. I highly recommend using ranger if you do any random forest modeling. It’s a lot faster and yields very similar results.After the model is fit, we can then plot the results</p>
<p><strong>4. Plot the results</strong></p>
<p>and visually inspect the model’s accuracy for different values of mtry. In this case, it looks like mtry = 14 yields the highest out-of-sample accuracy.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s explore the tuneLength argument on some other models.</p>
</section>
<section id="advantage-of-a-longer-tune-length" class="level2">
<h2 class="anchored" data-anchor-id="advantage-of-a-longer-tune-length">Advantage of a longer tune length</h2>
<blockquote class="blockquote">
<h2 id="question-13" class="anchored"><em>Question</em></h2>
<p>What’s the advantage of a longer <code>tuneLength</code>?<br> <br> ✅ You explore more potential models and can potentially find a better model.<br> ⬜ Your models take less time to fit.<br> ⬜ There’s no advantage; you’ll always end up with the same final model.<br></p>
</blockquote>
<p>You’re correct! Longer tune lengths explore more models.</p>
</section>
<section id="try-a-longer-tune-length" class="level2">
<h2 class="anchored" data-anchor-id="try-a-longer-tune-length">Try a longer tune length</h2>
<p>Recall from the video that random forest models have a primary tuning parameter of <code>mtry</code>, which controls how many variables are exposed to the splitting search routine at each split. For example, suppose that a tree has a total of 10 splits and <code>mtry = 2</code>. This means that there are 10 samples of 2 predictors each time a split is evaluated.</p>
<p>Use a larger tuning grid this time, but stick to the defaults provided by the <code>train()</code> function. Try a <code>tuneLength</code> of 3, rather than 1, to explore some more potential models, and plot the resulting model using the <code>plot</code> function.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Train a random forest model, <code>model</code>, using the <code>wine</code> dataset on the <code>quality</code> variable with all other variables as explanatory variables. (This will take a few seconds to run, so be patient!)</li>
<li>Use <code>method = "ranger"</code>.</li>
<li>Change the <code>tuneLength</code> to 3.</li>
<li>Use 5 CV folds.</li>
<li>Print <code>model</code> to the console.</li>
<li>Plot the model after fitting it.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># Fit random forest: model</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb44-3"><a href="#cb44-3"></a>  quality <span class="sc">~</span> .,</span>
<span id="cb44-4"><a href="#cb44-4"></a>  <span class="at">tuneLength =</span> <span class="dv">3</span>,</span>
<span id="cb44-5"><a href="#cb44-5"></a>  <span class="at">data =</span> wine, </span>
<span id="cb44-6"><a href="#cb44-6"></a>  <span class="at">method =</span> <span class="st">"ranger"</span>,</span>
<span id="cb44-7"><a href="#cb44-7"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb44-8"><a href="#cb44-8"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb44-9"><a href="#cb44-9"></a>    <span class="at">number =</span> <span class="dv">5</span>, </span>
<span id="cb44-10"><a href="#cb44-10"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb44-11"><a href="#cb44-11"></a>  )</span>
<span id="cb44-12"><a href="#cb44-12"></a>)</span>
<span id="cb44-13"><a href="#cb44-13"></a></span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="co"># Print model to console</span></span>
<span id="cb44-15"><a href="#cb44-15"></a>model</span>
<span id="cb44-16"><a href="#cb44-16"></a></span>
<span id="cb44-17"><a href="#cb44-17"></a><span class="co"># Plot model</span></span>
<span id="cb44-18"><a href="#cb44-18"></a><span class="fu">plot</span>(model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Excellent! You can adjust the tuneLength variable to make a trade-off between runtime and how deep you want to grid-search the model.</p>
</section>
<section id="custom-tuning-grids" class="level2">
<h2 class="anchored" data-anchor-id="custom-tuning-grids">Custom tuning grids</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Custom tuning grids</strong></p>
<p>In the last video, we learned how to use the tuneLength argument to customize caret models. However, we’re not limited to the defaults train chooses for us.</p>
<p><strong>2. Pros and cons of custom tuning</strong></p>
<p>We can pass our own, fully-customized grids as data.frames to the tuneGrid argument in train function. This is the most flexible method of fitting and tuning caret models, and gives us complete control over the models that are explored during grid search.The major drawback of this method is that it requires the most knowledge of the how the model works, and can dramatically increase the model’s runtime if you use a very large tuning grid. However, it also gives you full control over the model you are tuning, and if you know the algorithm well, you can exploit that knowledge to get better results from your models.</p>
<p><strong>3. Custom tuning example</strong></p>
<p>Lets make a custom tuning grid. To start, we need to make a data.frame with the values of tuning parameters we want to explore. Random forests have a single tuning parameter (mtry), so we make a data.frame with a single column. In the last video, we saw that mtry values of 2, 8, and 14 did well, so we’ll make a grid that explores the lower portion of the tuning space in more detail, looking at 2,3,4 and 5, as well as 10 and 20 as values for mtry.After fitting our model, we can plot the results.</p>
<p><strong>4. Custom tuning</strong></p>
<p>In this case the tuning value of 10 looks to be the best, though perhaps not quite as good as the 14 caret chose by default in the previous video.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s explore some custom tuning grids on other datasets.</p>
</section>
<section id="advantages-of-a-custom-tuning-grid" class="level2">
<h2 class="anchored" data-anchor-id="advantages-of-a-custom-tuning-grid">Advantages of a custom tuning grid</h2>
<blockquote class="blockquote">
<h2 id="question-14" class="anchored"><em>Question</em></h2>
<p>Why use a custom <code>tuneGrid</code>?<br> <br> ⬜ There’s no advantage; you’ll always end up with the same final model.<br> ✅ It gives you more fine-grained control over the tuning parameters that are explored.<br> ⬜ It always makes your models run faster.<br></p>
</blockquote>
<p>You’re right! A custom tune grid gives you full control over caret’s grid search.</p>
</section>
<section id="fit-a-random-forest-with-custom-tuning" class="level2">
<h2 class="anchored" data-anchor-id="fit-a-random-forest-with-custom-tuning">Fit a random forest with custom tuning</h2>
<p>Now that you’ve explored the default tuning grids provided by the <code>train()</code> function, let’s customize your models a bit more.</p>
<p>You can provide any number of values for <code>mtry</code>, from 2 up to the number of columns in the dataset. In practice, there are diminishing returns for much larger values of <code>mtry</code>, so you will use a custom tuning grid that explores 2 simple models (<code>mtry = 2</code> and <code>mtry = 3</code>) as well as one more complicated model (<code>mtry = 7</code>).</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Define a custom tuning grid.the number of variables to possibly split at each node, <code>.mtry</code>, to a vector of <code>2</code>, <code>3</code>, and <code>7</code>.the rule to split on, <code>.splitrule</code>, to <code>"variance"</code>.the minimum node size, <code>.min.node.size</code>, to <code>5</code>.</li>
<li>Set the number of variables to possibly split at each node, <code>.mtry</code>, to a vector of <code>2</code>, <code>3</code>, and <code>7</code>.</li>
<li>Set the rule to split on, <code>.splitrule</code>, to <code>"variance"</code>.</li>
<li>Set the minimum node size, <code>.min.node.size</code>, to <code>5</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># Define the tuning grid: tuneGrid</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>tuneGrid <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb45-3"><a href="#cb45-3"></a>  <span class="at">.mtry =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">7</span>),</span>
<span id="cb45-4"><a href="#cb45-4"></a>  <span class="at">.splitrule =</span> <span class="st">"variance"</span>,</span>
<span id="cb45-5"><a href="#cb45-5"></a>  <span class="at">.min.node.size =</span> <span class="dv">5</span></span>
<span id="cb45-6"><a href="#cb45-6"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="5" type="1">
<li>Train another random forest model, <code>model</code>, using the <code>wine</code> dataset on the <code>quality</code> variable with all other variables as explanatory variables.<code>method = "ranger"</code>.the custom <code>tuneGrid</code>. CV folds.</li>
<li>Use <code>method = "ranger"</code>.</li>
<li>Use the custom <code>tuneGrid</code>.</li>
<li>Use 5 CV folds.</li>
<li>Print <code>model</code> to the console.</li>
<li>Plot the model after fitting it using <code>plot()</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="co"># From previous step</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>tuneGrid <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb46-3"><a href="#cb46-3"></a>  <span class="at">.mtry =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">7</span>),</span>
<span id="cb46-4"><a href="#cb46-4"></a>  <span class="at">.splitrule =</span> <span class="st">"variance"</span>,</span>
<span id="cb46-5"><a href="#cb46-5"></a>  <span class="at">.min.node.size =</span> <span class="dv">5</span></span>
<span id="cb46-6"><a href="#cb46-6"></a>)</span>
<span id="cb46-7"><a href="#cb46-7"></a></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="co"># Fit random forest: model</span></span>
<span id="cb46-9"><a href="#cb46-9"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb46-10"><a href="#cb46-10"></a>  quality <span class="sc">~</span> .,</span>
<span id="cb46-11"><a href="#cb46-11"></a>  <span class="at">tuneGrid =</span> tuneGrid,</span>
<span id="cb46-12"><a href="#cb46-12"></a>  <span class="at">data =</span> wine, </span>
<span id="cb46-13"><a href="#cb46-13"></a>  <span class="at">method =</span> <span class="st">"ranger"</span>,</span>
<span id="cb46-14"><a href="#cb46-14"></a>  <span class="at">trControl =</span> <span class="fu">trainControl</span>(</span>
<span id="cb46-15"><a href="#cb46-15"></a>    <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb46-16"><a href="#cb46-16"></a>    <span class="at">number =</span> <span class="dv">5</span>, </span>
<span id="cb46-17"><a href="#cb46-17"></a>    <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb46-18"><a href="#cb46-18"></a>  )</span>
<span id="cb46-19"><a href="#cb46-19"></a>)</span>
<span id="cb46-20"><a href="#cb46-20"></a></span>
<span id="cb46-21"><a href="#cb46-21"></a><span class="co"># Print model to console</span></span>
<span id="cb46-22"><a href="#cb46-22"></a>model</span>
<span id="cb46-23"><a href="#cb46-23"></a></span>
<span id="cb46-24"><a href="#cb46-24"></a><span class="co"># Plot model</span></span>
<span id="cb46-25"><a href="#cb46-25"></a><span class="fu">plot</span>(model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Model tuning plots can be very useful for understanding caret models.</p>
</section>
<section id="introducing-glmnet" class="level2">
<h2 class="anchored" data-anchor-id="introducing-glmnet">Introducing glmnet</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Introducing glmnet</strong></p>
<p>Now we’ll introduce one of my favorite predictive models: the glmnet model.</p>
<p><strong>2. Introducing glmnet</strong></p>
<p>Glmnet models are an extension of generalized linear models (or the glm function in R). However, they have built-in variable selection that is useful on many real-world datasets. In particular, it helps linear regression models better handle collinearity–or correlation among the predictors in a model–and also helps prevent them in being over-confident in results derived from small sample sizes. There are 2 primary forms of glmnet models: lasso regression, which penalizes the number of non-zero coefficients, and ridge regression, which penalizes the absolute magnitude of the coefficients. These penalties are calculated during the model fit, and are used by the optimizer to adjust the linear regression coefficients. In other words, a glmnet attempts to find a parsimonious model, with either few non-zero coefficients, or small absolute magnitude coefficients, that best fit the input dataset. This is an extremely useful model, and pairs particularly well with random forest models, as it tends to yield different results.</p>
<p><strong>3. Tuning glmnet models</strong></p>
<p>glmnet models are a combination of 2 types of models: lasso regression (with a penalty on the number of non-zero coefficients) and ridge regression (with a penalty on large coefficients). Furthermore, glmnet models can fit a <em>mix</em> of lasso and ridge models, this is, a model with a small penalty on both the number of non-zero coefficients and their absolute magnitude. This gives glmnet models many parameters to tune. The alpha parameter ranges from 0 to 1, where 0 is pure ridge regression, 1 is pure lasso regression, and any value between is a mix of the two. Lambda, on the other hand, ranges from 0 to positive infinity, and controls the size of the penalty. Higher values of lambda will yield simpler models, and high enough values of lambda will yield intercept-only models that just predict the mean of the response variable in the training data.</p>
<p><strong>4. Example: “don’t overfit”</strong></p>
<p>Let’s take a look at the “don’t overfit” dataset, which is based on the first Kaggle competition I ever competed in. This dataset has almost as many columns as rows, which makes it challenging for traditional linear regression models. We’ll make a custom trainControl object that predicts class probabilities and uses AUC to perform grid search and select models.</p>
<p><strong>5. Try the defaults</strong></p>
<p>We’ll start with a simple model that uses the default caret tuning grid: 3 values of alpha and 3 values of lambda, and plot the result.</p>
<p><strong>6. Plot the results</strong></p>
<p>As you can see, the model with an alpha (or mixing percentage) of around 0-point-55 and a medium value of lambda (or regularization parameter) does the best on this dataset.</p>
<p><strong>7. Let’s practice!</strong></p>
<p>Let’s explore the glmnet model in some more detail.</p>
</section>
<section id="advantage-of-glmnet" class="level2">
<h2 class="anchored" data-anchor-id="advantage-of-glmnet">Advantage of glmnet</h2>
<blockquote class="blockquote">
<h2 id="question-15" class="anchored"><em>Question</em></h2>
<p>What’s the advantage of <code>glmnet</code> over regular <code>glm</code> models?<br> <br> ⬜ <code>glmnet</code> models automatically find interaction variables.<br> ⬜ <code>glmnet</code> models don’t provide p-values or confidence intervals on predictions.<br> ✅ <code>glmnet</code> models place constraints on your coefficients, which helps prevent overfitting.<br></p>
</blockquote>
<p>Yes! glmnet models give you an easy way to optimize for simpler models.</p>
</section>
<section id="make-a-custom-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="make-a-custom-traincontrol">Make a custom trainControl</h2>
<p>The wine quality dataset was a regression problem, but now you are looking at a classification problem. This is a simulated dataset based on the “don’t overfit” competition on Kaggle a number of years ago.</p>
<p>Classification problems are a little more complicated than regression problems because you have to provide a custom <code>summaryFunction</code> to the <code>train()</code> function to use the <code>AUC</code> metric to rank your models. Start by making a custom <code>trainControl</code>, as you did in the previous chapter. Be sure to set <code>classProbs = TRUE</code>, otherwise the <code>twoClassSummary</code> for <code>summaryFunction</code> will break.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li><p>Make a custom <code>trainControl</code> called <code>myControl</code> for classification using the <code>trainControl</code> function.</p>
<ul>
<li>Use 10 CV folds.</li>
<li>Use <code>twoClassSummary</code> for the <code>summaryFunction</code>.</li>
<li>Be sure to set <code>classProbs = TRUE</code>.</li>
</ul></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># Create custom trainControl: myControl</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>myControl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(</span>
<span id="cb47-3"><a href="#cb47-3"></a>  <span class="at">method =</span> <span class="st">"cv"</span>, </span>
<span id="cb47-4"><a href="#cb47-4"></a>  <span class="at">number =</span> <span class="dv">10</span>,</span>
<span id="cb47-5"><a href="#cb47-5"></a>  <span class="at">summaryFunction =</span> twoClassSummary,</span>
<span id="cb47-6"><a href="#cb47-6"></a>  <span class="at">classProbs =</span> <span class="cn">TRUE</span>, <span class="co"># IMPORTANT!</span></span>
<span id="cb47-7"><a href="#cb47-7"></a>  <span class="at">verboseIter =</span> <span class="cn">TRUE</span></span>
<span id="cb47-8"><a href="#cb47-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Creating a custome trainControl gives you much finer control over how caret searches for models.</p>
</section>
<section id="fit-glmnet-with-custom-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="fit-glmnet-with-custom-traincontrol">Fit glmnet with custom trainControl</h2>
<p>Now that you have a custom <code>trainControl</code> object, fit a <code>glmnet</code> model to the “don’t overfit” dataset. Recall from the video that <code>glmnet</code> is an extension of the generalized linear regression model (or <code>glm</code>) that places constraints on the magnitude of the coefficients to prevent overfitting. This is more commonly known as “penalized” regression modeling and is a very useful technique on datasets with many predictors and few values.</p>
<p><code>glmnet</code> is capable of fitting two different kinds of penalized models, controlled by the <code>alpha</code> parameter:</p>
<ul>
<li>Ridge regression (or <code>alpha = 0</code>)</li>
<li>Lasso regression (or <code>alpha = 1</code>) You’ll now fit a <code>glmnet</code> model to the “don’t overfit” dataset using the defaults provided by the <code>caret</code> package.</li>
</ul>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Train a <code>glmnet</code> model called <code>model</code> on the <code>overfit</code> data. Use the custom <code>trainControl</code> from the previous exercise (<code>myControl</code>). The variable <code>y</code> is the response variable and all other variables are explanatory variables.</li>
<li>Print the model to the console.</li>
<li>Use the <code>max()</code> function to find the maximum of the ROC statistic contained somewhere in <code>model[["results"]]</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a><span class="co"># Load package</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="fu">library</span>(readr)</span>
<span id="cb48-3"><a href="#cb48-3"></a></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="co"># Load data</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>overfit <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"data/overfit.csv"</span>)</span>
<span id="cb48-6"><a href="#cb48-6"></a></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="co"># Fit glmnet model: model</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb48-9"><a href="#cb48-9"></a>  y <span class="sc">~</span> ., </span>
<span id="cb48-10"><a href="#cb48-10"></a>  overfit,</span>
<span id="cb48-11"><a href="#cb48-11"></a>  <span class="at">method =</span> <span class="st">"glmnet"</span>,</span>
<span id="cb48-12"><a href="#cb48-12"></a>  <span class="at">trControl =</span> myControl</span>
<span id="cb48-13"><a href="#cb48-13"></a>)</span>
<span id="cb48-14"><a href="#cb48-14"></a></span>
<span id="cb48-15"><a href="#cb48-15"></a><span class="co"># Print model to console</span></span>
<span id="cb48-16"><a href="#cb48-16"></a>model</span>
<span id="cb48-17"><a href="#cb48-17"></a></span>
<span id="cb48-18"><a href="#cb48-18"></a><span class="co"># Print maximum ROC statistic</span></span>
<span id="cb48-19"><a href="#cb48-19"></a><span class="fu">max</span>(model[[<span class="st">"results"</span>]][[<span class="st">"ROC"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Awesome job! This glmnet will use AUC rather than accuracy to select the final model parameters.</p>
</section>
<section id="glmnet-with-custom-tuning-grid" class="level2">
<h2 class="anchored" data-anchor-id="glmnet-with-custom-tuning-grid">glmnet with custom tuning grid</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. glmnet with custom tuning grid</strong></p>
<p>Random forest models are relatively easy to tune, as there’s really 1 parameter of importance: mtry.</p>
<p><strong>2. Custom tuning glmnet models</strong></p>
<p>Glmnet models, on the other hand, have 2 tuning parameters: alpha (or the mixing parameter between ridge and lasso regression) and lambda (or the strength of the penalty on the coefficients).However, there’s a trick to glmnet models: for a single value of alpha, glmnet fits all values of lambda simultaneously! This is called the sub-model trick, because we can fit a number of different models simultaneously, and then explore the results of each sub-model after the fact. We can also exploit this trick to get faster-running grid searches, while still exploring finely-grained tuning grids.</p>
<p><strong>3. Example: glmnet tuning</strong></p>
<p>With glmnet models, I usually like to explore 2 values of alpha: 0 and 1, with a wide range of lambdas. caret will use the sub model trick to collapse the entire tuning grid down to 2 model fits, which will run pretty fast, even for 10 folds of cross-validation.Let’s start by making a custom tuning grid, with alphas of 0 and 1 and lambdas between 0 and point-1. We use the sequence function to make a sequence of lambdas and we use the length argument to determine the length of this sequence.Next we fit a glmnet model using the train function with our custom tuning grid, and plot the results.</p>
<p><strong>4. Compare models visually</strong></p>
<p>Recall that alpha equals 0 is ridge regression, and alpha equals 1 is lasso regression. In this case, we can see that lasso regression with a small lambda penalty is the best.</p>
<p><strong>5. Full regularization path</strong></p>
<p>We can also plot the full regularization path for all of the models with alpha = 0. This is a special plot, specific to glmnet models. On the left is the intercept only model (high value of lambda) and on the right is the full model with no penalty (low value of lambda). The plot shows how the regression coefficients are “shrunk” from right to left as you increase the strength of the penalty on coefficient size, and therefore decrease the complexity of the model. You can also see some lines hitting zero as we increase lambda, which represents these coefficients dropping out of the model.</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s explore this tuning grid on some other datasets.</p>
</section>
<section id="why-a-custom-tuning-grid" class="level2">
<h2 class="anchored" data-anchor-id="why-a-custom-tuning-grid">Why a custom tuning grid?</h2>
<blockquote class="blockquote">
<h2 id="question-16" class="anchored"><em>Question</em></h2>
<p>Why use a custom tuning grid for a <code>glmnet</code> model?<br> <br> ⬜ There’s no reason to use a custom grid; the default is always the best.<br> ✅ The default tuning grid is very small and there are many more potential <code>glmnet</code> models you want to explore.<br> ⬜ <code>glmnet</code> models are really slow, so you should never try more than a few tuning parameters.<br></p>
</blockquote>
<p>Good job! With a custom grid you can deeply explore machine learning models in caret.</p>
</section>
<section id="glmnet-with-custom-traincontrol-and-tuning" class="level2">
<h2 class="anchored" data-anchor-id="glmnet-with-custom-traincontrol-and-tuning">glmnet with custom trainControl and tuning</h2>
<p>As you saw in the video, the <code>glmnet</code> model actually fits many models at once (one of the great things about the package). You can exploit this by passing a large number of <code>lambda</code> values, which control the amount of penalization in the model. <code>train()</code> is smart enough to only fit one model per <code>alpha</code> value and pass all of the <code>lambda</code> values at once for simultaneous fitting.</p>
<p>My favorite tuning grid for <code>glmnet</code> models is:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="fu">expand.grid</span>(</span>
<span id="cb49-2"><a href="#cb49-2"></a>  <span class="at">alpha =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>,</span>
<span id="cb49-3"><a href="#cb49-3"></a>  <span class="at">lambda =</span> <span class="fu">seq</span>(<span class="fl">0.0001</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="dv">100</span>)</span>
<span id="cb49-4"><a href="#cb49-4"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This grid explores a large number of <code>lambda</code> values (100, in fact), from a very small one to a very large one. (You could increase the maximum <code>lambda</code> to 10, but in this exercise 1 is a good upper bound.)</p>
<p>If you want to explore fewer models, you can use a shorter lambda sequence. For example, <code>lambda = seq(0.0001, 1, length = 10)</code> would fit 10 models per value of alpha.</p>
<p>You also look at the two forms of penalized models with this <code>tuneGrid</code>: ridge regression and lasso regression. <code>alpha = 0</code> is pure ridge regression, and <code>alpha = 1</code> is pure lasso regression. You can fit a mixture of the two models (i.e.&nbsp;an elastic net) using an <code>alpha</code> between 0 and 1. For example, <code>alpha = 0.05</code> would be 95% ridge regression and 5% lasso regression.</p>
<p>In this problem you’ll just explore the 2 extremes – pure ridge and pure lasso regression – for the purpose of illustrating their differences.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Train a <code>glmnet</code> model on the <code>overfit</code> data such that <code>y</code> is the response variable and all other variables are explanatory variables. Make sure to use your custom <code>trainControl</code> from the previous exercise (<code>myControl</code>). Also, use a custom <code>tuneGrid</code> to explore <code>alpha = 0:1</code> and 20 values of <code>lambda</code> between 0.0001 and 1 per value of alpha.</li>
<li>Print <code>model</code> to the console.</li>
<li>Print the <code>max()</code> of the ROC statistic in <code>model[["results"]]</code>. You can access it using <code>model[["results"]][["ROC"]]</code>.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a><span class="co"># Train glmnet with custom trainControl and tuning: model</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb50-3"><a href="#cb50-3"></a>  y <span class="sc">~</span> ., </span>
<span id="cb50-4"><a href="#cb50-4"></a>  overfit,</span>
<span id="cb50-5"><a href="#cb50-5"></a>  <span class="at">tuneGrid =</span> <span class="fu">expand.grid</span>(</span>
<span id="cb50-6"><a href="#cb50-6"></a>    <span class="at">alpha =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>,</span>
<span id="cb50-7"><a href="#cb50-7"></a>    <span class="at">lambda =</span> <span class="fu">seq</span>(<span class="fl">0.0001</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="dv">20</span>)</span>
<span id="cb50-8"><a href="#cb50-8"></a>  ),</span>
<span id="cb50-9"><a href="#cb50-9"></a>  <span class="at">method =</span> <span class="st">"glmnet"</span>,</span>
<span id="cb50-10"><a href="#cb50-10"></a>  <span class="at">trControl =</span> myControl</span>
<span id="cb50-11"><a href="#cb50-11"></a>)</span>
<span id="cb50-12"><a href="#cb50-12"></a></span>
<span id="cb50-13"><a href="#cb50-13"></a><span class="co"># Print model to console</span></span>
<span id="cb50-14"><a href="#cb50-14"></a>model</span>
<span id="cb50-15"><a href="#cb50-15"></a></span>
<span id="cb50-16"><a href="#cb50-16"></a><span class="co"># Print maximum ROC statistic</span></span>
<span id="cb50-17"><a href="#cb50-17"></a><span class="fu">max</span>(model[[<span class="st">"results"</span>]][[<span class="st">"ROC"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Excellent work! I use this custom tuning grid for all my glmnet models – it’s a great place to start!</p>
</section>
<section id="interpreting-glmnet-plots" class="level2">
<h2 class="anchored" data-anchor-id="interpreting-glmnet-plots">Interpreting glmnet plots</h2>
<p>Here’s the tuning plot for the custom tuned <code>glmnet</code> model you created in the last exercise. For the <code>overfit</code> dataset, which value of <code>alpha</code> is better?</p>
<p>insert image</p>
<blockquote class="blockquote">
<h2 id="question-17" class="anchored"><em>Question</em></h2>
<p>???<br> <br> ⬜ <code>alpha = 0</code> (ridge)<br> ✅ <code>alpha = 1</code> (lasso)<br></p>
</blockquote>
<p>Correct! For this dataset, <code>alpha = 1</code> (or lasso) is better.</p>
</section>
</section>
<section id="preprocessing-your-data" class="level1">
<h1>4. Preprocessing your data</h1>
<p>In this chapter, you will practice using <code>train()</code> to preprocess data before fitting models, improving your ability to making accurate predictions.</p>
<section id="median-imputation" class="level2">
<h2 class="anchored" data-anchor-id="median-imputation">Median imputation</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Median imputation</strong></p>
<p>Real world data have missing values.</p>
<p><strong>2. Dealing with missing values</strong></p>
<p>This is a problem for most statistical or machine learning algorithms: they usually require numbers to work with, and don’t know what to do with missing data.One common approach is to throw out rows with missing data, but this is generally not a good idea. It can lead to biases in your dataset and generate over-confident models. It can also, in extreme cases, lead to you throwing out all of your data.A much better strategy is to use the median to guess what a missing value would be, if it weren’t missing. This is a very good idea if your data are “missing at random” and lets you model data that include rows with missing values.</p>
<p><strong>3. Example: mtcars</strong></p>
<p>Let’s generate some data with missing values.We’ll start with the mtcars dataset, which contains measurements of the physical characteristics of some cars. In this case, we want to predict the car’s MPG, based on the other attributes of the car.Let’s pretend some manufacturers don’t report their car’s horsepower, and randomly replace some points in this column with missing values.We can then split the dataset into a data frame of predictors (X) and the target we want to predict (Y). This demonstrates caret’s non-formula interface for modeling.Unfortunately, due to the missing values in X, when we go to fit the model, it fails with a cryptic error. This is a point where many new users get stuck, and need to come looking for help.</p>
<p><strong>4. A simple solution</strong></p>
<p>The simple solution to this problem is to pass “medianImpute” to the preProcess argument for train, which tells caret to impute the missing values in X with their medians.caret actually does this imputation INSIDE each fold of the cross validation, so you get an honest assessment of the entire modeling process: the random forest model is fit after the imputation.This model now runs without error, and does not require you as a data scientist to do any additional work to clean your data.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s practice using median imputation.</p>
</section>
<section id="median-imputation-vs.-omitting-rows" class="level2">
<h2 class="anchored" data-anchor-id="median-imputation-vs.-omitting-rows">Median imputation vs.&nbsp;omitting rows</h2>
<blockquote class="blockquote">
<h2 id="question-18" class="anchored"><em>Question</em></h2>
<p>What’s the value of median imputation?<br> <br> ⬜ It removes some variance from your data, making it easier to model.<br> ✅ It lets you model data with missing values.<br> ⬜ It’s useless; you should just throw out rows of data with any missings.<br></p>
</blockquote>
<p>Correct! Missing data can be a big headache unless you handle it.</p>
</section>
<section id="apply-median-imputation" class="level2">
<h2 class="anchored" data-anchor-id="apply-median-imputation">Apply median imputation</h2>
<p>In this chapter, you’ll be using a version of the Wisconsin Breast Cancer dataset. This dataset presents a classic binary classification problem: 50% of the samples are benign, 50% are malignant, and the challenge is to identify which are which.</p>
<p>This dataset is interesting because many of the predictors contain missing values and most rows of the dataset have at least one missing value. This presents a modeling challenge, because most machine learning algorithms cannot handle missing values out of the box. For example, your first instinct might be to fit a logistic regression model to this data, but prior to doing this you need a strategy for handling the <code>NA</code>s.</p>
<p>Fortunately, the <code>train()</code> function in <code>caret</code> contains an argument called <code>preProcess</code>, which allows you to specify that median imputation should be used to fill in the missing values. In previous chapters, you created models with the <code>train()</code> function using formulas such as <code>y ~ .</code>. An alternative way is to specify the <code>x</code> and <code>y</code> arguments to <code>train()</code>, where <code>x</code> is an object with samples in rows and features in columns and <code>y</code> is a numeric or factor vector containing the outcomes. Said differently, <code>x</code> is a matrix or data frame that contains the whole dataset you’d use for the <code>data</code> argument to the <code>lm()</code> call, for example, but excludes the response variable column; <code>y</code> is a vector that contains just the response variable column.</p>
<p>For this exercise, the argument <code>x</code> to <code>train()</code> is loaded in your workspace as <code>breast_cancer_x</code> and <code>y</code> as <code>breast_cancer_y</code>.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use the <code>train()</code> function to fit a <code>glm</code> model called <code>median_model</code> to the breast cancer dataset. Use <code>preProcess = "medianImpute"</code> to handle the missing values.</li>
<li>Print <code>median_model</code> to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># Load data</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>breast_cancer_x <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/breast_cancer_x.rds"</span>)</span>
<span id="cb51-3"><a href="#cb51-3"></a>breast_cancer_y <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/breast_cancer_y.rds"</span>)</span>
<span id="cb51-4"><a href="#cb51-4"></a></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="co"># Apply median imputation: median_model</span></span>
<span id="cb51-6"><a href="#cb51-6"></a>median_model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb51-7"><a href="#cb51-7"></a>  <span class="at">x =</span> breast_cancer_x, </span>
<span id="cb51-8"><a href="#cb51-8"></a>  <span class="at">y =</span> breast_cancer_y,</span>
<span id="cb51-9"><a href="#cb51-9"></a>  <span class="at">method =</span> <span class="st">"glm"</span>,</span>
<span id="cb51-10"><a href="#cb51-10"></a>  <span class="at">trControl =</span> myControl,</span>
<span id="cb51-11"><a href="#cb51-11"></a>  <span class="at">preProcess =</span> <span class="st">"medianImpute"</span></span>
<span id="cb51-12"><a href="#cb51-12"></a>)</span>
<span id="cb51-13"><a href="#cb51-13"></a></span>
<span id="cb51-14"><a href="#cb51-14"></a><span class="co"># Print median_model to console</span></span>
<span id="cb51-15"><a href="#cb51-15"></a>median_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Fantastic job! Caret makes it very easy to include model preprocessing in your model validation.</p>
</section>
<section id="knn-imputation" class="level2">
<h2 class="anchored" data-anchor-id="knn-imputation">KNN imputation</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. KNN imputation</strong></p>
<p>There are some problems with median imputation.</p>
<p><strong>2. Dealing with missing values</strong></p>
<p>It’s very fast, but it can produce incorrect results if the input data has a systematic bias and is missing not-at-random. In other words, if there is a pattern in the data that leads to missing values, median imputation can miss this.It is therefore useful to explore other strategies for missing imputation, particularly for linear models. (Tree based models such as random forests tend to be more robust to the missing-not-at-random case). One useful type of missing value imputation is k-nearest-neighbors, or knn imputation.This is a strategy for imputing missing values based on other, “similar” non-missing rows. This method tries to overcome the missing-not-at-random problem by inferring what the missing value would be, based on observations that are similar in other, non-missing variables.</p>
<p><strong>3. Example: missing not at random</strong></p>
<p>Fortunately, the train function has a built-in method to do this.Let’s make a dataset that has some missing-not-at-random data. We’ll look at the mtcars dataset, and pretend that smaller cars (those with a lower displacement) don’t report their horsepower.In this case, using median imputation will be incorrect. Since only medium and large sized cars report their horsepower, the median non-missing value for horsepower will be medium to large. This bias can lead to inaccurate models, as we’re assuming the wrong value for horsepower in these small cars.</p>
<p><strong>4. Example: missing not at random</strong></p>
<p>Using knn imputation is much better, and will use the displacement and number of cylinders variables to make an educated guess as to the value of horsepower. This will tend to use the smaller cars with known horsepower to guess the missing values.This model is more accurate, with an RMSE of 3.56 vs 3.61 for the model that used median imputation, but it’s a bit slower.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s explore knn imputation on some other datasets.</p>
</section>
<section id="comparing-knn-imputation-to-median-imputation" class="level2">
<h2 class="anchored" data-anchor-id="comparing-knn-imputation-to-median-imputation">Comparing KNN imputation to median imputation</h2>
<blockquote class="blockquote">
<h2 id="question-19" class="anchored"><em>Question</em></h2>
<p>Will KNN imputation always be better than median imputation?<br> <br> ✅ No, you should try both options and keep the one that gives more accurate models.<br> ⬜ Yes, KNN is a more complicated model than medians, so it’s always better.<br> ⬜ No, medians are more statistically valid than KNN and should always be used.<br></p>
</blockquote>
<p>Correct! Always try everything and decide the best option empirically.</p>
</section>
<section id="use-knn-imputation" class="level2">
<h2 class="anchored" data-anchor-id="use-knn-imputation">Use KNN imputation</h2>
<p>In the previous exercise, you used median imputation to fill in missing values in the breast cancer dataset, but that is not the only possible method for dealing with missing data.</p>
<p>An alternative to median imputation is k-nearest neighbors, or KNN, imputation. This is a more advanced form of imputation where missing values are replaced with values from other rows that are similar to the current row. While this is a lot more complicated to implement in practice than simple median imputation, it is very easy to explore in <code>caret</code> using the <code>preProcess</code> argument to <code>train()</code>. You can simply use <code>preProcess = "knnImpute"</code> to change the method of imputation used prior to model fitting.</p>
<p>package RANN is required</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Use the <code>train()</code> function to fit a <code>glm</code> model called <code>knn_model</code> to the breast cancer dataset.</li>
<li>Use KNN imputation to handle missing values.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="co"># Apply KNN imputation: knn_model</span></span>
<span id="cb52-2"><a href="#cb52-2"></a>knn_model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb52-3"><a href="#cb52-3"></a>  <span class="at">x =</span> breast_cancer_x, </span>
<span id="cb52-4"><a href="#cb52-4"></a>  <span class="at">y =</span> breast_cancer_y,</span>
<span id="cb52-5"><a href="#cb52-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span>,</span>
<span id="cb52-6"><a href="#cb52-6"></a>  <span class="at">trControl =</span> myControl,</span>
<span id="cb52-7"><a href="#cb52-7"></a>  <span class="at">preProcess =</span> <span class="st">"knnImpute"</span></span>
<span id="cb52-8"><a href="#cb52-8"></a>)</span>
<span id="cb52-9"><a href="#cb52-9"></a></span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="co"># Print knn_model to console</span></span>
<span id="cb52-11"><a href="#cb52-11"></a>knn_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Good work! As you can see, you can easily try out different imputation methods.</p>
</section>
<section id="compare-knn-and-median-imputation" class="level2">
<h2 class="anchored" data-anchor-id="compare-knn-and-median-imputation">Compare KNN and median imputation</h2>
<p>All of the preprocessing steps in the <code>train()</code> function happen in the training set of each cross-validation fold, so the error metrics reported include the effects of the preprocessing.</p>
<p>This includes the imputation method used (e.g.&nbsp;<code>knnImpute</code> or <code>medianImpute</code>). This is useful because it allows you to compare different methods of imputation and choose the one that performs the best out-of-sample.</p>
<p><code>median_model</code> and <code>knn_model</code> are available in your workspace, as is <code>resamples</code>, which contains the resampled results of both models. Look at the results of the models by calling</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="fu">dotplot</span>(resamples, <span class="at">metric =</span> <span class="st">"ROC"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and choose the one that performs the best out-of-sample.</p>
<blockquote class="blockquote">
<h2 id="question-20" class="anchored"><em>Question</em></h2>
<p>Which method of imputation yields the highest out-of-sample ROC score for your <code>glm</code> model?<br> <br> ⬜ KNN imputation is much better than median imputation.<br> ✅ KNN imputation is slightly better than median imputation.<br> ⬜ Median imputation is much better than KNN imputation.<br> ⬜ Median imputation is slightly better than KNN imputation.<br></p>
</blockquote>
<p>Nice!</p>
</section>
<section id="multiple-preprocessing-methods" class="level2">
<h2 class="anchored" data-anchor-id="multiple-preprocessing-methods">Multiple preprocessing methods</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Multiple preprocessing methods</strong></p>
<p>The preprocess argument to train can do a lot more than missing value imputation.</p>
<p><strong>2. The wide world of preProcess</strong></p>
<p>It exposes a very wide range of pre-processing steps that can have a large impact on the results of your models.You can also chain together multiple preprocessing steps. For example, you can use median imputation, then center and scale your data, then fit a glm model. This is a common “recipe” for preprocessing data prior to fitting a linear model.Note that there is an “order of operations” to the preprocessing steps. For example, median imputation always happens prior to centering and scaling, and principal components analysis always happens after centering and scaling. You can read the help file for the preProcess function for much more detail on this.</p>
<p><strong>3. Example: preprocessing mtcars</strong></p>
<p>Let’s load the mtcars dataset, and add some missing at random data.Now let’s use our linear model recipe: median imputation, then center and scale, then fit a glm model.This is as simple as passing a character vector of instructions to the preProcess argument for train. Imputation will happen first, then centering and scaling, then fitting the glm model.</p>
<p><strong>4. Example: preprocessing mtcars</strong></p>
<p>We can add additional transformations to our model as well, for example principle components analysis after centering and scaling. This yields a slightly more accurate model, in terms of RMSE.</p>
<p><strong>5. Example: preprocessing mtcars</strong></p>
<p>There are many other cool transformation we can use, for example the spatial sign transformation. This transformation projects your data onto a sphere, and is very useful for datasets with lots of outliers or particularly high dimensionality, but in this case it doesn’t improve our model.</p>
<p><strong>6. Preprocessing cheat sheet</strong></p>
<p>The number of preprocessing steps caret provides can be a little overwhelming, so I’ll leave you with this cheat sheet:First of all, always start with median imputation. This will save you all kinds of weird issues with messy datasets.Just remember to also try knn imputation if you suspect your data might have values missing not-at-random.Second, for linear models like lm, glm, and glmnet, always center and scale. You just get better results.Third, it’s worth trying PCA and spatial sign transformation for your linear models. Sometimes these methods can yield better results.Finally, tree-based models such as random forests or GBMs typically don’t need much preprocessing. You can usually get away with just median imputation.</p>
<p><strong>7. Let’s practice!</strong></p>
<p>Let’s try these transformations on some other datasets.</p>
</section>
<section id="order-of-operations" class="level2">
<h2 class="anchored" data-anchor-id="order-of-operations">Order of operations</h2>
<blockquote class="blockquote">
<h2 id="question-21" class="anchored"><em>Question</em></h2>
<p>Which comes first in <code>caret</code>’s <code>preProcess()</code> function: median imputation or centering and scaling of variables?<br> <br> ✅ Median imputation comes before centering and scaling.<br> ⬜ Centering and scaling come before median imputation.<br></p>
</blockquote>
<p>Correct! Centering and scaling require data with no missing values.</p>
</section>
<section id="combining-preprocessing-methods" class="level2">
<h2 class="anchored" data-anchor-id="combining-preprocessing-methods">Combining preprocessing methods</h2>
<p>The <code>preProcess</code> argument to <code>train()</code> doesn’t just limit you to imputing missing values. It also includes a wide variety of other <code>preProcess</code> techniques to make your life as a data scientist much easier. You can read a full list of them by typing <code>?preProcess</code> and reading the help page for this function.</p>
<p>One set of preprocessing functions that is particularly useful for fitting regression models is standardization: centering and scaling. You first <em>center</em> by subtracting the mean of each column from each value in that column, then you <em>scale</em> by dividing by the standard deviation.</p>
<p>Standardization transforms your data such that for each column, the mean is 0 and the standard deviation is 1. This makes it easier for regression models to find a good solution.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a logistic regression model using median imputation called <code>model</code> to the breast cancer data, then print it to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># Fit glm with median imputation</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb54-3"><a href="#cb54-3"></a>  <span class="at">x =</span> breast_cancer_x, </span>
<span id="cb54-4"><a href="#cb54-4"></a>  <span class="at">y =</span> breast_cancer_y,</span>
<span id="cb54-5"><a href="#cb54-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span>,</span>
<span id="cb54-6"><a href="#cb54-6"></a>  <span class="at">trControl =</span> myControl,</span>
<span id="cb54-7"><a href="#cb54-7"></a>  <span class="at">preProcess =</span> <span class="st">"medianImpute"</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>)</span>
<span id="cb54-9"><a href="#cb54-9"></a></span>
<span id="cb54-10"><a href="#cb54-10"></a><span class="co"># Print model</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li>Update the model to include two more pre-processing steps: centering and scaling.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1"></a><span class="co"># Update model with standardization</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb55-3"><a href="#cb55-3"></a>  <span class="at">x =</span> breast_cancer_x, </span>
<span id="cb55-4"><a href="#cb55-4"></a>  <span class="at">y =</span> breast_cancer_y,</span>
<span id="cb55-5"><a href="#cb55-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span>,</span>
<span id="cb55-6"><a href="#cb55-6"></a>  <span class="at">trControl =</span> myControl,</span>
<span id="cb55-7"><a href="#cb55-7"></a>  <span class="at">preProcess =</span> <span class="fu">c</span>(<span class="st">"medianImpute"</span>, <span class="st">"center"</span>, <span class="st">"scale"</span>)</span>
<span id="cb55-8"><a href="#cb55-8"></a>)</span>
<span id="cb55-9"><a href="#cb55-9"></a></span>
<span id="cb55-10"><a href="#cb55-10"></a><span class="co"># Print updated model</span></span>
<span id="cb55-11"><a href="#cb55-11"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! You can combine many different preprocessing methods with caret.</p>
</section>
<section id="handling-low-information-predictors" class="level2">
<h2 class="anchored" data-anchor-id="handling-low-information-predictors">Handling low-information predictors</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Handling low-information predictors</strong></p>
<p>In the real world, the data we’re using for predictive modeling is often messy.</p>
<p><strong>2. No (or low) variance variables</strong></p>
<p>Some variables in our dataset might not contain much information. For example, variables that are constant, or very close to constant, don’t contain much useful information and it can sometimes be useful to remove them prior to modeling.Nearly constant variables are particularly tricky, because it is easy for one fold of cross-validation to end up with a constant column. Constant columns can mess up a lot of models, and should be avoided. Furthermore, nearly constant columns contain little information, which means that these variables tend not to have an impact on the results of your model.In general, I remove extremely low-variance variables from my datasets prior to modeling. This speeds up my models and makes them run with fewer bugs and generally doesn’t have a large impact on their accuracy.</p>
<p><strong>3. Example: constant column in mtcars</strong></p>
<p>Let’s have a look at the mtcars dataset from the last video. We’ll add a constant-valued column to this dataset, and then try to fit our linear regression “recipe.”</p>
<p><strong>4. Example: constant column in mtcars</strong></p>
<p>As you can see, something has gone horribly wrong with this model, but it’s hard to tell what. All of the metrics are missing.This error is due to the constant-valued column, which has a standard deviation of 0. Therefore, when we try to scale the column by dividing by the standard deviation, we end up with a whole bunch of missing values, which throw off the subsequent stages of modeling.</p>
<p><strong>5. caret to the rescue (again)</strong></p>
<p>Fortunately, caret again saves us a lot of work. We can add “zv” to the preprocessing argument to remove constant-valued columns, or “nzv” to remove nearly constant columns. By adding the “zv” argument to our pca and regression recipe, we solve the error and get useful results out of our caret model.</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s explore nearly constant, or low-variance columns in more detail.</p>
</section>
<section id="why-remove-near-zero-variance-predictors" class="level2">
<h2 class="anchored" data-anchor-id="why-remove-near-zero-variance-predictors">Why remove near zero variance predictors?</h2>
<blockquote class="blockquote">
<h2 id="question-22" class="anchored"><em>Question</em></h2>
<p>What’s the best reason to remove near zero variance predictors from your data before building a model?<br> <br> ⬜ Because they are guaranteed to have no effect on your model.<br> ⬜ Because their p-values in a linear regression will always be low.<br> ✅ To reduce model-fitting time without reducing model accuracy.<br></p>
</blockquote>
<p>Correct! Low variance variables are unlikely to have a large impact on our models.</p>
</section>
<section id="remove-near-zero-variance-predictors" class="level2">
<h2 class="anchored" data-anchor-id="remove-near-zero-variance-predictors">Remove near zero variance predictors</h2>
<p>As you saw in the video, for the next set of exercises, you’ll be using the blood-brain dataset. This is a biochemical dataset in which the task is to predict the following value for a set of biochemical compounds:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="fu">log</span>((concentration of compound <span class="cf">in</span> brain) <span class="sc">/</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>      (concentration of compound <span class="cf">in</span> blood))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This gives a quantitative metric of the compound’s ability to cross the blood-brain barrier, and is useful for understanding the biological properties of that barrier.</p>
<p>One interesting aspect of this dataset is that it contains many variables and many of these variables have extremely low variances. This means that there is very little information in these variables because they mostly consist of a single value (e.g.&nbsp;zero).</p>
<p>Fortunately, <code>caret</code> contains a utility function called <code>nearZeroVar()</code> for removing such variables to save time during modeling.</p>
<p><code>nearZeroVar()</code> takes in data <code>x</code>, then looks at the ratio of the most common value to the second most common value, <code>freqCut</code>, and the percentage of distinct values out of the number of total samples, <code>uniqueCut</code>. By default, <code>caret</code> uses <code>freqCut = 19</code> and <code>uniqueCut = 10</code>, which is fairly conservative. I like to be a little more aggressive and use <code>freqCut = 2</code> and <code>uniqueCut = 20</code> when calling <code>nearZeroVar()</code>.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li><p><code>bloodbrain_x</code> and <code>bloodbrain_y</code> are loaded in your workspace.</p>
<ul>
<li>Identify the near zero variance predictors by running <code>nearZeroVar()</code> on the blood-brain dataset. Store the result as an object called <code>remove_cols</code>. Use <code>freqCut = 2</code> and <code>uniqueCut = 20</code> in the call to <code>nearZeroVar()</code>.</li>
<li>Use <code>names()</code> to create a vector containing all column names of <code>bloodbrain_x</code>. Call this <code>all_cols</code>.</li>
<li>Make a new data frame called <code>bloodbrain_x_small</code> with the near-zero variance variables removed. Use <code>setdiff()</code> to isolate the column names that you wish to keep (i.e.&nbsp;that you don’t want to remove.)</li>
</ul></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a><span class="co"># Load data</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>bloodbrain_x <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/bloodbrain_x.rds"</span>)</span>
<span id="cb57-3"><a href="#cb57-3"></a>bloodbrain_y <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/bloodbrain_y.rds"</span>)</span>
<span id="cb57-4"><a href="#cb57-4"></a></span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="co"># Identify near zero variance predictors: remove_cols</span></span>
<span id="cb57-6"><a href="#cb57-6"></a>remove_cols <span class="ot">&lt;-</span> <span class="fu">nearZeroVar</span>(bloodbrain_x, <span class="at">names =</span> <span class="cn">TRUE</span>, </span>
<span id="cb57-7"><a href="#cb57-7"></a>                           <span class="at">freqCut =</span> <span class="dv">2</span>, <span class="at">uniqueCut =</span> <span class="dv">20</span>)</span>
<span id="cb57-8"><a href="#cb57-8"></a></span>
<span id="cb57-9"><a href="#cb57-9"></a><span class="co"># Get all column names from bloodbrain_x: all_cols</span></span>
<span id="cb57-10"><a href="#cb57-10"></a>all_cols <span class="ot">&lt;-</span> <span class="fu">names</span>(bloodbrain_x)</span>
<span id="cb57-11"><a href="#cb57-11"></a></span>
<span id="cb57-12"><a href="#cb57-12"></a><span class="co"># Remove from data: bloodbrain_x_small</span></span>
<span id="cb57-13"><a href="#cb57-13"></a>bloodbrain_x_small <span class="ot">&lt;-</span> bloodbrain_x[ , <span class="fu">setdiff</span>(all_cols, remove_cols)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Near zero variance variables can cause issues during cross-validation.</p>
</section>
<section id="preprocess-and-nearzerovar" class="level2">
<h2 class="anchored" data-anchor-id="preprocess-and-nearzerovar">preProcess() and nearZeroVar()</h2>
<blockquote class="blockquote">
<h2 id="question-23" class="anchored"><em>Question</em></h2>
<p>Can you use the <code>preProcess</code> argument in <code>caret</code> to remove near-zero variance predictors? Or do you have to do this by hand, prior to modeling, using the <code>nearZeroVar()</code> function?<br> <br> ✅ Yes! Set the <code>preProcess</code> argument equal to <code>"nzv"</code>.<br> ⬜ No, unfortunately. You have to do this by hand.<br></p>
</blockquote>
<p>Yes!</p>
</section>
<section id="fit-model-on-reduced-blood-brain-data" class="level2">
<h2 class="anchored" data-anchor-id="fit-model-on-reduced-blood-brain-data">Fit model on reduced blood-brain data</h2>
<p>Now that you’ve reduced your dataset, you can fit a <code>glm</code> model to it using the <code>train()</code> function. This model will run faster than using the full dataset and will yield very similar predictive accuracy.</p>
<p>Furthermore, zero variance variables can cause problems with cross-validation (e.g.&nbsp;if one fold ends up with only a single unique value for that variable), so removing them prior to modeling means you are less likely to get errors during the fitting process.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a <code>glm</code> model using the <code>train()</code> function and the reduced blood-brain dataset you created in the previous exercise.</li>
<li>Print the result to the console.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="co"># Fit model on reduced data: model</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb58-3"><a href="#cb58-3"></a>  <span class="at">x =</span> bloodbrain_x_small, </span>
<span id="cb58-4"><a href="#cb58-4"></a>  <span class="at">y =</span> bloodbrain_y, </span>
<span id="cb58-5"><a href="#cb58-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span></span>
<span id="cb58-6"><a href="#cb58-6"></a>)</span>
<span id="cb58-7"><a href="#cb58-7"></a></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="co"># Print model to console</span></span>
<span id="cb58-9"><a href="#cb58-9"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Excellent job! As discussed previously, glm generates a lot of warnings about convergence, but they’re never a big deal and you can use the out-of-sample accuracy to make sure your model makes good predictions.</p>
</section>
<section id="principle-components-analysis-pca" class="level2">
<h2 class="anchored" data-anchor-id="principle-components-analysis-pca">Principle components analysis (PCA)</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Principle components analysis (PCA)</strong></p>
<p>Principle components analysis (or PCA) is one of my favorite preprocessing steps for linear regression models. You’ll notice that I used it as an example in many of the previous videos.</p>
<p><strong>2. Principle components analysis</strong></p>
<p>PCA is incredibly useful because it combines all the low-variance and correlated variables in your dataset into a single set of high-variance, perpendicular predictors. As we saw before, low variance variables can be problematic for cross-validation, but can also contain useful information. It’s better to find a systematic way to use that information, rather than throw it away.Furthermore, perpendicular predictors are useful because they are perfectly uncorrelated. Linear regression models have trouble with correlation between variables (also known as collinearity), and PCA elegantly removes this issue from the equation.</p>
<p><strong>3. PCA: a visual representation</strong></p>
<p>PCA searches for high-variance linear combinations of the input data that are perpendicular to each other. The first component of PCA is the highest variance component, and is the highest variance axis of the original dataset. The second PCA component has the second highest variance, and so on.This diagram illustrates how PCA works. We have 2 correlated variables, x and y. When plotted together, we can see their relationship. PCA transforms the data with respect to this correlation, and finds a new variable (the long diagonal arrow pointing up and to the right) that reflects the shared correlation of x and y. After finding the first PCA component, the second PCA component is constrained to be perpendicular, and is the second arrow going up and to the left.In other words, the first PCA component reflects the similarity between x and y, while the second PCA component emphasizes the difference between x and y. This idea is easy to illustrate in 2 dimensions, but also extends to multiple dimensions.</p>
<p><strong>4. Example: blood-brain data</strong></p>
<p>Let’s take a look at the blood-brain dataset, which contains lots of predictors, many of which are low-variance. We can use the nearZeroVar function from the caret package to identify these variables.</p>
<p><strong>5. Example: blood-brain data</strong></p>
<p>We can start by just removing the zero variance predictors from the dataset with the “zv” argument, prior to modeling. This yields some warnings, but no error, and our models run successfully.</p>
<p><strong>6. Example: blood-brain data</strong></p>
<p>Next, we can try removing low variance variables with the “nzv” argument. This gets rid of all the warnings and yields slightly better accuracy.</p>
<p><strong>7. Example: blood-brain data</strong></p>
<p>Finally, we can do PCA on the full dataset, removing only the zero-variance predictors, which contain no information. This gives the best results, because we include the low-variance predictors in the model, but combine them together in an intelligent way using PCA.</p>
<p><strong>8. Let’s practice!</strong></p>
<p>Finally, we can do PCA on the full dataset, removing only the zero-variance predictors, which contain no information. This gives the best results, because we include the low-variance predictors in the model, but combine them together in an intelligent way using PCA.</p>
</section>
<section id="using-pca-as-an-alternative-to-nearzerovar" class="level2">
<h2 class="anchored" data-anchor-id="using-pca-as-an-alternative-to-nearzerovar">Using PCA as an alternative to nearZeroVar()</h2>
<p>An alternative to removing low-variance predictors is to run PCA on your dataset. This is sometimes preferable because it does not throw out all of your data: many different low variance predictors may end up combined into one high variance PCA variable, which might have a positive impact on your model’s accuracy.</p>
<p>This is an especially good trick for linear models: the <code>pca</code> option in the <code>preProcess</code> argument will center and scale your data, combine low variance variables, and ensure that all of your predictors are orthogonal. This creates an ideal dataset for linear regression modeling, and can often improve the accuracy of your models.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a <code>glm</code> model to the full blood-brain dataset using the <code>"pca"</code> option to <code>preProcess</code>.</li>
<li>Print the model to the console and inspect the result.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># Fit glm model using PCA: model</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb59-3"><a href="#cb59-3"></a>  <span class="at">x =</span> bloodbrain_x, </span>
<span id="cb59-4"><a href="#cb59-4"></a>  <span class="at">y =</span> bloodbrain_y,</span>
<span id="cb59-5"><a href="#cb59-5"></a>  <span class="at">method =</span> <span class="st">"glm"</span>, </span>
<span id="cb59-6"><a href="#cb59-6"></a>  <span class="at">preProcess =</span> <span class="st">"pca"</span></span>
<span id="cb59-7"><a href="#cb59-7"></a>)</span>
<span id="cb59-8"><a href="#cb59-8"></a></span>
<span id="cb59-9"><a href="#cb59-9"></a><span class="co"># Print model to console</span></span>
<span id="cb59-10"><a href="#cb59-10"></a>model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! Note that the PCA model’s accuracy is slightly higher than the <code>nearZeroVar()</code> model from the previous exercise. PCA is generally a better method for handling low-information predictors than throwing them out entirely.</p>
</section>
</section>
<section id="selecting-models-a-case-study-in-churn-prediction" class="level1">
<h1>5. Selecting models: a case study in churn prediction</h1>
<p>In the final chapter of this course, you’ll learn how to use <code>resamples()</code> to compare multiple models and select (or ensemble) the best one(s).</p>
<section id="reusing-a-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="reusing-a-traincontrol">Reusing a trainControl</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Reusing a trainControl</strong></p>
<p>In this chapter, we will work on a more realistic dataset:</p>
<p><strong>2. A real-world example</strong></p>
<p>customer churn at a telecom company. We will work through fitting a couple different predictive models, and then compare them and choose the best one.In order to do a proper apples-to-apples comparison between models, we’ll need to explicitly define the training and test folds and make sure each model uses exactly the same split for each fold.We can do this by pre-defining a trainControl object, which explicitly specifies which rows are used for model building and which are used as holdouts. This trainControl object can then be used across multiple models.</p>
<p><strong>3. Example: customer churn data</strong></p>
<p>Before we start modeling, lets load the customer churn data, from the C50 package in R. Then we can summarize the target variable, and find that about 14% of the customers churned.</p>
<p><strong>4. Example: customer churn data</strong></p>
<p>Next, we make train / test indexes for cross validation using caret’s createFolds function.Note that these folds preserve the class distribution: the first fold has about a 14% churn rate.</p>
<p><strong>5. Example: customer churn data</strong></p>
<p>Now, we use these folds to create a trainControl object, which we can re-use to fit multiple models. Each model fit with this train control will have exactly the same cross-validation folds.This will allow us to later compare these models and be sure we are making a fair comparison.</p>
<p><strong>6. Let’s practice!</strong></p>
<p>Let’s practice making trainControl objects for multiple models.</p>
</section>
<section id="why-reuse-a-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="why-reuse-a-traincontrol">Why reuse a trainControl?</h2>
<blockquote class="blockquote">
<h2 id="question-24" class="anchored"><em>Question</em></h2>
<p>Why reuse a <code>trainControl</code>?<br> <br> ⬜ So you can use the same <code>summaryFunction</code> and tuning parameters for multiple models.<br> ⬜ So you don’t have to repeat code when fitting multiple models.<br> ⬜ So you can compare models on the exact same training and test data.<br> ✅ All of the above.<br></p>
</blockquote>
<p>Nice one!</p>
</section>
<section id="make-custom-traintest-indices" class="level2">
<h2 class="anchored" data-anchor-id="make-custom-traintest-indices">Make custom train/test indices</h2>
<p>As you saw in the video, for this chapter you will focus on a real-world dataset that brings together all of the concepts discussed in the previous chapters.</p>
<p>The churn dataset contains data on a variety of telecom customers and the modeling challenge is to predict which customers will cancel their service (or churn).</p>
<p>In this chapter, you will be exploring two different types of predictive models: <code>glmnet</code> and <code>rf</code>, so the first order of business is to create a reusable <code>trainControl</code> object you can use to reliably compare them.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li><p><code>churn_x</code> and <code>churn_y</code> are loaded in your workspace.</p>
<ul>
<li>Use <code>createFolds()</code> to create 5 CV folds on <code>churn_y</code>, your target variable for this exercise.</li>
<li>Pass them to <code>trainControl()</code> to create a reusable <code>trainControl</code> for comparing models.</li>
</ul></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a><span class="co"># Load data</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>churn_x <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/churn_x.rds"</span>)</span>
<span id="cb60-3"><a href="#cb60-3"></a>churn_y <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"data/churn_y.rds"</span>)</span>
<span id="cb60-4"><a href="#cb60-4"></a></span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="co"># Create custom indices: myFolds</span></span>
<span id="cb60-6"><a href="#cb60-6"></a>myFolds <span class="ot">&lt;-</span> <span class="fu">createFolds</span>(churn_y, <span class="at">k =</span> <span class="dv">5</span>)</span>
<span id="cb60-7"><a href="#cb60-7"></a></span>
<span id="cb60-8"><a href="#cb60-8"></a><span class="co"># Create reusable trainControl object: myControl</span></span>
<span id="cb60-9"><a href="#cb60-9"></a>myControl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(</span>
<span id="cb60-10"><a href="#cb60-10"></a>  <span class="at">summaryFunction =</span> twoClassSummary,</span>
<span id="cb60-11"><a href="#cb60-11"></a>  <span class="at">classProbs =</span> <span class="cn">TRUE</span>, <span class="co"># IMPORTANT!</span></span>
<span id="cb60-12"><a href="#cb60-12"></a>  <span class="at">verboseIter =</span> <span class="cn">TRUE</span>,</span>
<span id="cb60-13"><a href="#cb60-13"></a>  <span class="at">savePredictions =</span> <span class="cn">TRUE</span>,</span>
<span id="cb60-14"><a href="#cb60-14"></a>  <span class="at">index =</span> myFolds</span>
<span id="cb60-15"><a href="#cb60-15"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! By saving the indexes in the train control, we can fit many models using the same CV folds.</p>
</section>
<section id="reintroducing-glmnet" class="level2">
<h2 class="anchored" data-anchor-id="reintroducing-glmnet">Reintroducing glmnet</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Reintroducing glmnet</strong></p>
<p>Recall the glmnet model we learned about earlier.</p>
<p><strong>2. glmnet review</strong></p>
<p>It is a linear regression model with built-in variable selection and is a great baseline model for any predictive modeling problem. It is almost always the first model I try on new datasets.It is a useful baseline, because it is fast, uses variable selection to ignore noisy variables, and also provides linear regression coefficients you can use to understand patterns in your data. It yields models that are just as interpretable as models from the lm or glm functions in R.A business analyst could use these coefficients to understand key drivers of churn, but even if you only care about predictions, glmnet is a solid baseline that fits quickly and often provided very accurate models.</p>
<p><strong>3. Example: glmnet on churn data</strong></p>
<p>Glmnet models are simple, fast, and interpretable. Let’s fit one to the churn dataset.After fitting the model, we can plot the results, and look at the relationship between alpha and lambda and the AUC of the model.</p>
<p><strong>4. Visualize results</strong></p>
<p>In this case, it looks like an alpha of 1 yields the best results on the churn dataset. Caret automatically chooses the best values for alpha and lambda, so we don’t need to do anything after looking at this plot, but its useful to understand how our models works.</p>
<p><strong>5. Plot the coefficients</strong></p>
<p>We can also plot the glmnet coefficients, and see how our best model evolves as we increase or decrease the penalty on the coefficients.</p>
<p><strong>6. Let’s practice!</strong></p>
</section>
<section id="glmnet-as-a-baseline-model" class="level2">
<h2 class="anchored" data-anchor-id="glmnet-as-a-baseline-model">glmnet as a baseline model</h2>
<blockquote class="blockquote">
<h2 id="question-25" class="anchored"><em>Question</em></h2>
<p>What makes <code>glmnet</code> a good baseline model?<br> <br> ✅ It’s simple, fast, and easy to interpret.<br> ⬜ It always gives poor predictions, so your other models will look good by comparison.<br> ⬜ Linear models with penalties on their coefficients always give better results.<br></p>
</blockquote>
<p>Correct! You can interpret the coefficients the same way as the coefficients from an <code>lm</code> or <code>glm</code> model.</p>
</section>
<section id="fit-the-baseline-model" class="level2">
<h2 class="anchored" data-anchor-id="fit-the-baseline-model">Fit the baseline model</h2>
<p>Now that you have a reusable <code>trainControl</code> object called <code>myControl</code>, you can start fitting different predictive models to your churn dataset and evaluate their predictive accuracy.</p>
<p>You’ll start with one of my favorite models, <code>glmnet</code>, which penalizes linear and logistic regression models on the size and number of coefficients to help prevent overfitting.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a <code>glmnet</code> model to the churn dataset called <code>model_glmnet</code>. Make sure to use <code>myControl</code>, which you created in the first exercise and is available in your workspace, as the <code>trainControl</code> object.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># Fit glmnet model: model_glmnet</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>model_glmnet <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb61-3"><a href="#cb61-3"></a>  <span class="at">x =</span> churn_x, </span>
<span id="cb61-4"><a href="#cb61-4"></a>  <span class="at">y =</span> churn_y,</span>
<span id="cb61-5"><a href="#cb61-5"></a>  <span class="at">metric =</span> <span class="st">"ROC"</span>,</span>
<span id="cb61-6"><a href="#cb61-6"></a>  <span class="at">method =</span> <span class="st">"glmnet"</span>,</span>
<span id="cb61-7"><a href="#cb61-7"></a>  <span class="at">trControl =</span> myControl</span>
<span id="cb61-8"><a href="#cb61-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! This model uses our custome CV folds and will be easily compared to other models.</p>
</section>
<section id="reintroducing-random-forest" class="level2">
<h2 class="anchored" data-anchor-id="reintroducing-random-forest">Reintroducing random forest</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Reintroducing random forest</strong></p>
<p>Next, lets try a random forest model on the churn dataset. After glmnet, random forest is always the second model I try on any new predictive modeling problem.</p>
<p><strong>2. Random forest review</strong></p>
<p>Random forests are slower than glmnet models, and are a bit more of a black-box in terms of interpretability, but in a lot of situations can yield much more accurate models with little parameter tuning. Another important aspect of random forests is that they require little pre-processing. There’s no need to log transform or otherwise normalize your predictors, and they handle the missing-not-at-random case pretty well, even with median imputation. They also automatically capture threshold effects and variable interactions by default, both of which occur often in real-world data. These features make random forests typically (though not always) more accurate than glmnet models, and are also easier to tune (but slower-running).</p>
<p><strong>3. Random forest on churn data</strong></p>
<p>This model is even easier to fit than glmnet. The default caret values for the tuning parameters are great, so we don’t need a custom tuning grid. Let’s use our custom trainControl object from the last video, and fit a random forest model to the churn data using the ranger package.</p>
<p><strong>4. Random forest on churn data</strong></p>
<p>As with the glmnet model, we can plot the results from the cross-validation and see how mtry relates to AUC. Again, caret has automatically chooses the best results for mtry, so we don’t need to do anything after viewing this plot, but it’s a useful method for understanding the model.</p>
<p><strong>5. Let’s practice!</strong></p>
</section>
<section id="random-forest-drawback" class="level2">
<h2 class="anchored" data-anchor-id="random-forest-drawback">Random forest drawback</h2>
<blockquote class="blockquote">
<h2 id="question-26" class="anchored"><em>Question</em></h2>
<p>What’s the drawback of using a random forest model for churn prediction?<br> <br> ⬜ Tree-based models are usually less accurate than linear models.<br> ✅ You no longer have model coefficients to help interpret the model.<br> ⬜ Nobody else uses random forests to predict churn.<br></p>
</blockquote>
<p>Yup! Random forests are a little bit harder to interpret than linear models, though it is still possible to understand them.</p>
</section>
<section id="random-forest-with-custom-traincontrol" class="level2">
<h2 class="anchored" data-anchor-id="random-forest-with-custom-traincontrol">Random forest with custom trainControl</h2>
<p>Another one of my favorite models is the random forest, which combines an ensemble of non-linear decision trees into a highly flexible (and usually quite accurate) model.</p>
<p>Rather than using the classic <code>randomForest</code> package, you’ll be using the <code>ranger</code> package, which is a re-implementation of <code>randomForest</code> that produces almost the exact same results, but is faster, more stable, and uses less memory. I highly recommend it as a starting point for random forest modeling in R.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Fit a random forest model to the churn dataset. Be sure to use <code>myControl</code> as the <code>trainControl</code> like you’ve done before and implement the <code>"ranger"</code> method.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># Fit random forest: model_rf</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>model_rf <span class="ot">&lt;-</span> <span class="fu">train</span>(</span>
<span id="cb62-3"><a href="#cb62-3"></a>  <span class="at">x =</span> churn_x, </span>
<span id="cb62-4"><a href="#cb62-4"></a>  <span class="at">y =</span> churn_y,</span>
<span id="cb62-5"><a href="#cb62-5"></a>  <span class="at">metric =</span> <span class="st">"ROC"</span>,</span>
<span id="cb62-6"><a href="#cb62-6"></a>  <span class="at">method =</span> <span class="st">"ranger"</span>,</span>
<span id="cb62-7"><a href="#cb62-7"></a>  <span class="at">trControl =</span> myControl</span>
<span id="cb62-8"><a href="#cb62-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! This random forest uses the custom CV folds, so we can easily compare it to the baseline model.</p>
</section>
<section id="comparing-models" class="level2">
<h2 class="anchored" data-anchor-id="comparing-models">Comparing models</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Comparing models</strong></p>
<p>After fitting 2 (or more models), the next step is deciding which one makes the best predictions on new data.</p>
<p><strong>2. Comparing models</strong></p>
<p>First of all, we have to make sure they were fit on the exact same training and test sets during cross-validation, so we’re sure that we’re making an apples-to-apples comparison of their results.We want to pick the model with the highest average AUC across all 10 folds, but also typically want a model with a low standard deviation in AUC.Fortunately, the caret package provides a handy function for collecting the results from multiple models. This function is called “resamples” and provides a variety of methods for assessing which of 2 models is the best for a given dataset.</p>
<p><strong>3. Example: resamples() on churn data</strong></p>
<p>Let’s use the resamples function to compare our glmnet and random forest models on the churn dataset.First, we make a list of models, and name each one for future reference.Next, we collect all the results from all the different cross-validation folds using the resamples function.</p>
<p><strong>4. Summarize the results</strong></p>
<p>Finally, we can summarize the results using the summary function on the resamples object, and choose which model is the best on this dataset.</p>
<p><strong>5. Let’s practice!</strong></p>
<p>Let’s practice with the resamples function.</p>
</section>
<section id="matching-traintest-indices" class="level2">
<h2 class="anchored" data-anchor-id="matching-traintest-indices">Matching train/test indices</h2>
<blockquote class="blockquote">
<h2 id="question-27" class="anchored"><em>Question</em></h2>
<p>What’s the primary reason that train/test indices need to match when comparing two models?<br> <br> ⬜ You can save a lot of time when fitting your models because you don’t have to remake the datasets.<br> ⬜ There’s no real reason; it just makes your plots look better.<br> ✅ Because otherwise you wouldn’t be doing a fair comparison of your models and your results could be due to chance.<br></p>
</blockquote>
<p>Correct! Train/test indexes allow you to evaluate your models <em>out of sample</em> so you know that they work!</p>
</section>
<section id="create-a-resamples-object" class="level2">
<h2 class="anchored" data-anchor-id="create-a-resamples-object">Create a resamples object</h2>
<p>Now that you have fit two models to the churn dataset, it’s time to compare their out-of-sample predictions and choose which one is the best model for your dataset.</p>
<p>You can compare models in <code>caret</code> using the <code>resamples()</code> function, provided they have the same training data and use the same <code>trainControl</code> object with preset cross-validation folds. <code>resamples()</code> takes as input a list of models and can be used to compare dozens of models at once (though in this case you are only comparing two models).</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li><p><code>model_glmnet</code> and <code>model_rf</code> are loaded in your workspace.</p>
<ul>
<li>Create a <code>list()</code> containing the <code>glmnet</code> model as <code>item1</code> and the <code>ranger</code> model as <code>item2</code>.</li>
<li>Pass this list to the <code>resamples()</code> function and save the resulting object as <code>resamples</code>.</li>
<li>Summarize the results by calling <code>summary()</code> on <code>resamples</code>.</li>
</ul></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a><span class="co"># Create model_list</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>model_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">item1 =</span> model_glmnet, <span class="at">item2 =</span> model_rf)</span>
<span id="cb63-3"><a href="#cb63-3"></a></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="co"># Pass model_list to resamples(): resamples</span></span>
<span id="cb63-5"><a href="#cb63-5"></a>resamples <span class="ot">&lt;-</span> <span class="fu">resamples</span>(model_list)</span>
<span id="cb63-6"><a href="#cb63-6"></a></span>
<span id="cb63-7"><a href="#cb63-7"></a><span class="co"># Summarize the results</span></span>
<span id="cb63-8"><a href="#cb63-8"></a><span class="fu">summary</span>(resamples)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Amazing! The resamples function gives us a bunch of options for comparing models, that we’ll explore further in the next exercises.</p>
</section>
<section id="more-on-resamples" class="level2">
<h2 class="anchored" data-anchor-id="more-on-resamples">More on resamples</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. More on resamples</strong></p>
<p>Resamples provides a ton of cool methods</p>
<p><strong>2. Comparing models</strong></p>
<p>for comparing models. It’s one of my favorite functions in the caret package (thanks Max!) and actually inspired me to write my own package (caretEnsemble) for ensembling lists of caret models.</p>
<p><strong>3. Box-and-whisker</strong></p>
<p>Let’s start with a simple box and box-and-whisker plot of AUC scores. We can use this to chose the model with the highest average AUC in this case the random forest model.</p>
<p><strong>4. Dot plot</strong></p>
<p>We can also use a dotplot to show the same information in a visually simpler manner.</p>
<p><strong>5. Density plot</strong></p>
<p>A density plot shows the full distribution of AUC scores using a kernel density plot, and can be a useful way to look for outlier folds with unusually high or low AUC.</p>
<p><strong>6. Scatter plot</strong></p>
<p>We can also use a scatterplot to directly compare the AUC on all 10 cross-validation folds. This plot shows us that on every fold, the random forest model provided higher AUC than the glmnet model, and would make us very confident in choosing the random forest model for this particular churn modeling problem.</p>
<p><strong>7. Another dot plot</strong></p>
<p>Finally, if we had many models to compare (let’s pretend we’d also fit an SVM, a GBM, and a decision tree model), we can still summarize them using the same functions. In this case, I typically choose the dotplot, which gives a very clean summary, even for dozens of models.Here, it seems that the random forest model gives us very good predictions on our churn data.</p>
<p><strong>8. Let’s practice!</strong></p>
<p>Let’s explore the resamples plots in more detail.</p>
</section>
<section id="create-a-box-and-whisker-plot" class="level2">
<h2 class="anchored" data-anchor-id="create-a-box-and-whisker-plot">Create a box-and-whisker plot</h2>
<p><code>caret</code> provides a variety of methods to use for comparing models. All of these methods are based on the <code>resamples()</code> function. My favorite is the box-and-whisker plot, which allows you to compare the distribution of predictive accuracy (in this case AUC) for the two models.</p>
<p>In general, you want the model with the higher median AUC, as well as a smaller range between min and max AUC.</p>
<p>You can make this plot using the <code>bwplot()</code> function, which makes a box and whisker plot of the model’s out of sample scores. Box and whisker plots show the median of each distribution as a line and the interquartile range of each distribution as a box around the median line. You can pass the <code>metric = "ROC"</code> argument to the <code>bwplot()</code> function to show a plot of the model’s out-of-sample ROC scores and choose the model with the highest median ROC.</p>
<p>If you do not specify a metric to plot, <code>bwplot()</code> will automatically plot 3 of them.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Pass the <code>resamples</code> object to the <code>bwplot()</code> function to make a box-and-whisker plot. Look at the resulting plot and note which model has the higher median ROC statistic. Be sure to specify which metric you want to plot.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="co"># Create bwplot</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="fu">bwplot</span>(resamples, <span class="at">metric =</span> <span class="st">"ROC"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! I’m a big fan of box and whisker plots for comparing models.</p>
</section>
<section id="create-a-scatterplot" class="level2">
<h2 class="anchored" data-anchor-id="create-a-scatterplot">Create a scatterplot</h2>
<p>Another useful plot for comparing models is the scatterplot, also known as the xy-plot. This plot shows you how similar the two models’ performances are on different folds.</p>
<p>It’s particularly useful for identifying if one model is consistently better than the other across all folds, or if there are situations when the inferior model produces better predictions on a particular subset of the data.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Pass the <code>resamples</code> object to the <code>xyplot()</code> function. Look at the resulting plot and note how similar the two models’ predictions are (or are not) on the different folds. Be sure to specify which metric you want to plot.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="co"># Create xyplot</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="fu">xyplot</span>(resamples, <span class="at">metric =</span> <span class="st">"ROC"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nice one! These scatterplots let you see if one model is always better than the other.</p>
</section>
<section id="ensembling-models" class="level2">
<h2 class="anchored" data-anchor-id="ensembling-models">Ensembling models</h2>
<p>That concludes the course! As a teaser for a future course on making ensembles of <code>caret</code> models, I’ll show you how to fit a stacked ensemble of models using the <code>caretEnsemble</code> package.</p>
<p><code>caretEnsemble</code> provides the <code>caretList()</code> function for creating multiple <code>caret</code> models at once on the same dataset, using the same resampling folds. You can also create your own lists of <code>caret</code> models.</p>
<p>In this exercise, I’ve made a <code>caretList</code> for you, containing the <code>glmnet</code> and <code>ranger</code> models you fit on the churn dataset. Use the <code>caretStack()</code> function to make a stack of <code>caret</code> models, with the two sub-models (<code>glmnet</code> and <code>ranger</code>) feeding into another (hopefully more accurate!) <code>caret</code> model.</p>
<p><strong>Steps</strong></p>
<ol type="1">
<li>Call the <code>caretStack()</code> function with two arguments, <code>model_list</code> and <code>method = "glm"</code>, to ensemble the two models using a logistic regression. Store the result as <code>stack</code>.</li>
<li>Summarize the resulting model with the <code>summary()</code> function.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co"># Load package</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="fu">library</span>(caretEnsemble)</span>
<span id="cb66-3"><a href="#cb66-3"></a></span>
<span id="cb66-4"><a href="#cb66-4"></a>model_list <span class="ot">&lt;-</span> <span class="fu">caretList</span>(</span>
<span id="cb66-5"><a href="#cb66-5"></a>  <span class="at">x          =</span> churn_x, </span>
<span id="cb66-6"><a href="#cb66-6"></a>  <span class="at">y          =</span> churn_y,</span>
<span id="cb66-7"><a href="#cb66-7"></a>  <span class="at">methodList =</span> <span class="fu">c</span>(<span class="at">item1 =</span> <span class="st">"glmnet"</span>, <span class="at">item2 =</span> <span class="st">"ranger"</span>),</span>
<span id="cb66-8"><a href="#cb66-8"></a>  <span class="at">trControl  =</span> myControl</span>
<span id="cb66-9"><a href="#cb66-9"></a>)</span>
<span id="cb66-10"><a href="#cb66-10"></a></span>
<span id="cb66-11"><a href="#cb66-11"></a><span class="co"># Create ensemble model: stack</span></span>
<span id="cb66-12"><a href="#cb66-12"></a>stack <span class="ot">&lt;-</span> <span class="fu">caretStack</span>(model_list, <span class="at">method =</span> <span class="st">"glm"</span>)</span>
<span id="cb66-13"><a href="#cb66-13"></a></span>
<span id="cb66-14"><a href="#cb66-14"></a><span class="co"># Look at summary</span></span>
<span id="cb66-15"><a href="#cb66-15"></a><span class="fu">summary</span>(stack)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Great work! The <code>caretEnsemble</code> package gives you an easy way to combine many caret models. Now for a brief farewell message from Max…</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Theory. Coming soon …</p>
<p><strong>1. Summary</strong></p>
<p>We hope that you’ve enjoyed this course and found it helpful.</p>
<p><strong>2. What you’ve learned</strong></p>
<p>In summary, you’ve learned how to use R and the caret package to carry out the basic steps of model fitting and evaluation using out-of-sample error and cross-validation. You looked at how to tune model parameters for better results. And you applied data preprocessing techniques like median and knn imputation and PCA to avoid problems due to missing data or correlated predictors.</p>
<p><strong>3. Goals of the caret package</strong></p>
<p>A major goal of the caret package is to simplify many common steps in the predictive modeling process and to help you try different types of models and pre-processing techniques without being exposed to the specific syntax within each R package.This is just the beginning; each data set that you encounter is likely to have its own idiosyncrasies and might require different approaches. Fortunately, R has a wealth of predictive modeling algorithms that you can use to solve your problems.</p>
<p><strong>4. Go build some models!</strong></p>
<p>Thanks for spending time with us. Now go build some models!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'alternate';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Content 2022 by <a href="https://www.startupengineer.io/authors/schwarz/">Joschka Schwarz</a> <br> All content licensed under a <a href="https://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International license (CC BY-NC 4.0)</a></div>   
    <div class="nav-footer-right">Made with and <a href="https://quarto.org/">Quarto</a><br> <a href="https://www.github.com/jwarz/jwarz.github.io">View the source at GitHub</a></div>
  </div>
</footer>



<script src="../../../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>
---
title: "Factor Analysis in R"
author: "Joschka Schwarz"
---

```{r}
#| include: false
source(here::here("R/setup-ggplot2-tie.R"))
options(dplyr.summarise.inform = FALSE)
```

The world is full of unobservable variables that can't be directly measured. You might be interested in a construct such as math ability, personality traits, or workplace climate. When investigating constructs like these, it's critically important to have a model that matches your theories and data. This course will help you understand dimensionality and show you how to conduct exploratory and confirmatory factor analyses. With these statistical techniques in your toolkit, you'll be able to develop, refine, and share your measures. These analyses are foundational for diverse fields including psychology, education, political science, economics, and linguistics.

# 1. Evaluating your measure with factor analysis

In Chapter 1, you will learn how to conduct an EFA to examine the statistical properties of a measure designed around one construct.

## Introduction to Exploratory Factor Analysis (EFA)

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Introduction to EFA**

Hi, I’m Jennifer Brussow, and I'm a psychometrician - which is a fancy way to say I work in the field of measurement.

**2. Psycho + metrics**

Psychometrics is the study of unobservable variables - "psycho" meaning "of the mind" and "metrics" meaning "related to measurement." Researchers develop measures to capture unobservable variables, such as personality or IQ, and factor analysis is a valuable tool for use both during and after the development process. In Chapter 1, you'll learn how to examine the statistical properties of a measure designed around one construct.

**3. Learning objectives**

In our first lesson, you'll start by running a unidimensional exploratory factor analysis, or EFA, on examinees' responses to questions, which we'll refer to as items. Next, you'll look at the results of the EFA to examine two key pieces of output. Items' factor loadings quantify their relationship to the underlying factor, which tells you how well each item is performing. Individuals' factor scores provide an estimate of the amount of the underlying factor each examinee possesses, which helps assign scores to examinees.

**4. Factor Analysis' relationship to other analyses**

You may be familiar with some related ways of analyzing data. Factor analysis can be thought of as midway between classical test theory and structural equation modeling. Whereas classical test theory reports scores as the unweighted sum of item scores, factor analysis assigns item weights according to the correlation matrix. These correlations allow us to infer the presence of a latent variable or variables. Structural equation modeling extends this approach to model the relationships between latent variables.

**5. Types of Factor Analysis**

It's important to note that there are two different types of factor analysis: exploratory and confirmatory. Exploratory factor analysis is used during measure development to explore factor structure and determine which items do a good job of measuring the construct. Confirmatory factor analysis is used to validate a measure after development.

**6. Package**

This course primarily uses the psych package, which was developed by William Revelle. You can load the package using the library() function.

**7. Dataset**

You'll use the gcbs dataset in the first chapter. This dataset contains 2,495 responses to 15 multiple choice questions, or items, which are designed to test respondents' level of belief in conspiracies.

**8. Item types**

Items in the gcbs dataset are categorized into five conspiracy facets.For example, Item 2, "The government permits or perpetrates acts of terrorism on its own soil, disguising its involvement," is a government malfeasance item. Item 8, "Evidence of alien contact is being concealed from the public," is an extraterrestrial coverup item.

**9. Factor structure**

The 15 items are hypothesized to reflect five lower-order factors corresponding to their five types. These five factors share a single higher-order factor: conspiracist belief. Hierarchical factor structures like this require structural equation modeling to estimate, but exploratory and confirmatory factor analysis can estimate either a single-factor or five-factor structure.

**10. Factor structure**

In Chapter 1, you'll ignore the five lower-order factors and use a single-factor EFA to estimate the items' relationship to conspiracist belief. This analysis will give you information about how well each item measures a single underlying factor and information about how much of the factor each examinee possesses. You'll learn how to deal with multiple factors in later chapters.

**11. Using the fa() function**

The fa() function is your ticket to running EFAs in the psych package. The object created from this function contains lots of valuable information such as items' factor loadings, individuals' factor scores, and fit statistics. In the first lesson of this chapter, you'll learn how to use the fa() function to run a single-factor EFA, access and interpret its output, and diagram the results.

**12. Let's practice!**

Now that we've covered the basic theory behind factor analysis let's get to some actual code!

## Starting out with a unidimensional EFA

Let's begin by using the `psych` package and conducting a single-factor explanatory factor analysis (EFA). The `fa()` function conducts an EFA on your data. When you're using this in the real world, be sure to use a dataset that only contains item responses - other types of data will cause errors and/or incorrect results. In the `gcbs` dataset, these are examinees' responses to 15 items from the Generic Conspiracist Beliefs Scale, which is designed to measure conspiracist beliefs. 

An EFA provides information on each item's relationship to a single factor hypothesized to be represented by each of the items. EFA results give you basic information about how well items relate to that hypothesized construct.

Be sure to save the analysis result object so you can return to it later.

**Steps**

1. Load the `psych` package to gain access to the necessary functions for your exploratory factor analysis. 
2. Then, run a single-factor EFA on the `gcbs` dataset and save the result to an object named `EFA_model`.
3. Finally, call the `EFA_model` object to see how the items in the dataset relate to the extracted factor.

```{r}
#| message: false
# Load the psych package
library(psych)

# Data
gcbs <- readRDS("data/GCBS_data.rds")
 
# Conduct a single-factor EFA
EFA_model <- fa(gcbs)

# View the results
EFA_model
```

Nice job! You now know how to conduct a single-factor EFA, which tells you each variable's relationship to the factor of interest. You can see in the results that the function has named the factor MR1. This name is due to it being the first factor extracted using minimum residual estimation.

## Viewing and visualizing the factor loadings

Each `fa()` results object is actually a list, and each element of the list contains specific information about the analysis, including factor loadings. Factor loadings represent the strength and directionality of the relationship between each item and the underlying factor, and they can range from -1 to 1. 

You can also create a diagram of loadings. The `fa.diagram()` function takes a result object from `fa()` and creates a path diagram showing the items’ loadings ordered from strongest to weakest. Path diagrams are more common for structural equation modeling than for factor analysis, but this type of visualization can be a helpful way to represent your results.

**Steps**

1. View the items' factor loadings by accessing the `loadings` element of the results object. These values show the strength and direction of their relationships.
2. Then, visualize the EFA results in a path diagram.

```{r}
# Set up the single-factor EFA
EFA_model <- fa(gcbs)

# View the factor loadings
EFA_model$loadings

# Create a path diagram of the items' factor loadings
fa.diagram(EFA_model)
```

Great work! Now you can view factor loadings as a matrix or visualized as a path diagram.

## Interpreting individuals' factor scores

The `EFA_model` object also contains a named list element, `scores`, which contains factor scores for each person. These factor scores are an indication of how much or how little of the factor each person is thought to possess. Factor scores are not computed for examinees with missing data.

**Steps**

1. Use `rowSums()` to see the total scores for the first six respondents. These values tell you how much of the construct they possess.

```{r}
# Take a look at the first few lines of the response data and their corresponding sum scores
head(gcbs)
rowSums(head(gcbs))
```

2. Use `head()` to look at the first few lines of the response data and their sum scores. Comparing these helps illustrate the relationship between responses and factor scores.

```{r}
# Take a look at the first few lines of the response data and their corresponding sum scores
head(gcbs)
rowSums(head(gcbs))

# Then look at the first few lines of individuals' factor scores
head(EFA_model$scores)
```

3. To get a feel for how the factor scores are distributed, use `summary()` to look at summary statistics.

```{r}
# Take a look at the first few lines of the response data and their corresponding sum scores
head(gcbs)
rowSums(head(gcbs))

# Then look at the first few lines of individuals' factor scores
head(EFA_model$scores)

# To get a feel for how the factor scores are distributed, look at their summary statistics and density plot.
summary(EFA_model$scores)
```

4. Use `plot()` and `density()` to create a density plot of the estimated factor scores for a visual representation. Density plots show the distribution of data over a continuous interval and can give you a sense of what your data look like.

```{r}
# Take a look at the first few lines of the response data and their corresponding sum scores
head(gcbs)
rowSums(head(gcbs))

# Then look at the first few lines of individuals' factor scores
head(EFA_model$scores)

# To get a feel for how the factor scores are distributed, look at their summary statistics and density plot.
summary(EFA_model$scores)

plot(density(EFA_model$scores, na.rm = TRUE), 
     main = "Factor Scores")
```

Congrats! Now you know how to view individuals' factor scores.

## Overview of the measure development process

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Overview of the measure development process**

Now that you know how to conduct a single-factor EFA, you're ready to start thinking about how it fits into the process of developing a measure.

**2. Development process**

When you're creating a measure of an unobservable variable or variables, you typically want to follow this process. Steps 1, 2, and 4 are theoretical and don't involve any coding so we won't spend much time on those.

**3. Development process**

When you have determined what construct you want to measure, the first step is to write questions, or items, for your measure. Always write more items than you think you'll need since they probably won't all perform as well as you'd like.After you've got enough items developed, the next step is to collect pilot data from a representative sample to test the measure. These data will be used to examine your measure and see how it is functioning before you use it for real. You can think of the gcbs dataset as pilot data for these 15 items. Once you've got pilot data, the first step is to check out what the dataset looks like.

**4. Inspecting your dataset**

To get a sense for your data, use the describe() function to see basic information about each of the items in the dataset.If you look at the first row of output, you can see in the column called n that item Q1 has 2,495 responses, a mean of 3-point-47, and a standard deviation of 1-point-46.You'll notice that the minimum and maximum are 0 and 5 for these items because they've been scored on a Likert scale.

**5. Development process**

Now that you know some basic features of your dataset, you have to consider which analyses you want to run. If you want to both develop and confirm a theory of how items are related to underlying factors, you'll want to use both EFA and CFA on your dataset. In that case, you'll need to split the dataset - step 5 here.

**6. Splitting the dataset**

To do that, create a set of random indices, then use them to divide the dataset.First, you'll determine the number of rows, N, in the dataset and set up a sequence from 1 to N. Next, you'll use the sample() function to select half of those numbers at random, then assign them to an object called indices_EFA. The other half of the numbers in the sequence are assigned to another object called indices_CFA. Once those sets of indices are established, you'll use them to create two datasets: one for your EFA, and one for your CFA. By creating a theory with half of the data, then testing it on the other half, you'll avoid overfitting your model or falsely confirming your theory.

**7. Development process**

Now that your sample is split into random halves, you'll want to make sure the two halves are similar - step 6 in this process. If the halves aren't similar, they aren't good representations of the population and aren't appropriate to evaluate your measure.

**8. Inspecting the halves**

The psych package provides some convenience functions to examine a dataset according to a grouping variable. To accomplish this, create a grouping variable from the indices you created to split the data.

**9. Inspecting the halves**

The grouping variable can then be bound onto the gcbs dataset as a new column using the cbind() function.This grouping variable provides the information needed by describeBy() and statsBy(), which you can use to view some key summary statistics. Watch out though - while the group argument of describeBy() has to be a vector, the group argument of statsBy() has to be the name of a column in your dataframe.

**10. Let's practice!**

Let's see these functions in action.

## Descriptive statistics of your dataset

The `psych` package provides several functions to help you visualize your data. The `describe()` function tells you basic statistics about each variable in your dataset, including the number of complete cases, the mean, standard deviation, minimum, maximum, range, skew, and kurtosis. 

You can also view graphical representations of the error bars for different variables using `error.dots()` and `error.bars()`. Both of these graphical representations are created from the summary statistics available from calling `describe()`.

**Steps**

1. Check out the basic descriptive statistics provided by the `describe()` function.


```{r}
# Basic descriptive statistics
describe(gcbs)
```

2. Create a **dot** chart of the mean scores and confidence intervals for each variable in the dataset.


```{r}
# Graphical representation of error
error.dots(gcbs)
```

3. Create a **bar** chart of the mean scores and confidence intervals for each variable in the dataset.


```{r}
# Graphical representation of error
error.bars(gcbs)
```

Great job! Now you know how to get a feel for your dataset with basic descriptive statistics and visualizations of error.

## Splitting your dataset

During the measure development process, it's important to conduct EFA and CFA on separate datasets because using the same dataset can lead to inflated model fit statistics. Instead, you can split your dataset in half, then use one half for the EFA and the other half for the CFA.

**Steps**

1. Split the dataset in half using two sets of indices to determine which rows belong to each dataset. 
2. Use the first set of indices to create a dataset for your EFA, then use the second set for your CFA dataset.

```{r}
# Establish two sets of indices to split the dataset
N <- nrow(gcbs)
indices <- seq(1, N)
indices_EFA <- sample(indices, floor((.5*N)))
indices_CFA <- indices[!(indices %in% indices_EFA)]

# Use those indices to split the dataset into halves for your EFA and CFA
gcbs_EFA <- gcbs[indices_EFA, ]
gcbs_CFA <- gcbs[indices_CFA, ]
```

Nice job splitting the dataset! Splitting your dataset is useful for creating train/test datasets for machine learning as well as for testing many other types of models.

## Comparing the halves of your dataset

Just as you inspected the features of your full dataset, it's important to examine the halves after you've split the data. You can always use `describe()` on each dataset, but the `psych` package also provides some functions to help compare a dataset according to a grouping variable. 

In this exercise, you'll use the indices created when splitting the dataset to create a grouping variable and attach it to the `gcbs` dataset. Once that grouping variable is set up, you can use `describeBy()` and `statsBy()` to view basic descriptive statistics as well as between-group statistics.

A word of warning: while the `group` argument of `describeBy()` has to be a vector, the `group` argument of `statsBy()` has to be the name of a column in your dataframe. Plan accordingly!

**Steps**

1. To better understand the halves, first create a dichotomous grouping variable from the indices you created in the last exercise (`indices_EFA` and `indices_CFA`).

```{r}
# Use the indices from the previous exercise to create a grouping variable
group_var <- vector("numeric", nrow(gcbs))
group_var[indices_EFA] <- 1
group_var[indices_CFA] <- 2
```

2. Bind that variable onto the dataset.


```{r}
# Use the indices from the previous exercise to create a grouping variable
group_var <- vector("numeric", nrow(gcbs))
group_var[indices_EFA] <- 1
group_var[indices_CFA] <- 2

# Bind that grouping variable onto the gcbs dataset
gcbs_grouped <- cbind(gcbs, group_var)
```

3. Use `describeBy()` and `statsBy()` to compare stats across groups.


```{r}
# Use the indices from the previous exercise to create a grouping variable
group_var <- vector("numeric", nrow(gcbs))
group_var[indices_EFA] <- 1
group_var[indices_CFA] <- 2

# Bind that grouping variable onto the gcbs dataset
gcbs_grouped <- cbind(gcbs, group_var)

# Compare stats across groups
describeBy(gcbs_grouped, group = group_var)
statsBy(gcbs_grouped, group = "group_var")
```

Great work navigating `describeBy()` and `statsBy()`! These functions are a quick and easy way to compare stats across groups.

## Measure features: correlations and reliability

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Measure features: correlations and reliability**

By this point, you've looked at basic descriptive statistics of your dataset and learned how to split the data into random halves. When writing a description of your measure, you'll also want to include some more detailed information.

**2. Correlations**

Correlations are the standard way of reporting relationships between variables. The lowerCor() function provides this data in a more reader-friendly format than base R's cor() function. The diagonal of ones represents the perfect correlation between each item and itself, and the other values are the correlations between each pair of items. lowerCor() displays only the lower triangle of the correlation matrix, so each pair's correlation is only displayed once. This correlation matrix is your first clue about factor structure. Groups of items that are more strongly correlated typically load onto the same factor.

**3. Testing correlations' significance: p-values**

Once you've used lowerCor() to find the correlations between items, you will likely also want to report their significance and confidence intervals. corr.test() can be used to generate both of these metrics for inter-item correlations. corr.test() generates a lot of output when you run it, and results are given as a full matrix instead of just the lower half like lowerCor(). Its result object is a list, so you can specify named list elements to get only the information you want to view. In this example, we are accessing the 'p' list element to get the p-values for each of the correlations. This slide displays the p-values for the correlations of the items. All those zeroes indicate statistically significant correlations. This is unsurprising given that the gcbs dataset has over 2,000 cases since statistical significance is affected by sample size.

**4. Testing correlations' significance: confidence intervals**

You can also use corr-dot-test() to view confidence intervals for each of the correlations. By default, corr-dot-test() calculates 95% confidence intervals around the correlation value, r. This means that if we repeated the experiment many times with datasets drawn from the same population, the calculated confidence intervals would contain the true value 95% of the time. These confidence intervals are important to report for many types of publications.The output above shows the results for the first item, Q1.

**5. Coefficient alpha**

Coefficient alpha, also called Cronbach's alpha, is another important statistic to report during measure development. This statistic is a measure of the internal consistency of your measure, which is also called reliability. Most fields of research prefer measures whose alpha is greater than 0-point-8. Using the alpha() function, you can see that the gcbs items have a coefficient alpha of 0-point-93, which suggests excellent reliability.

**6. Coefficient alpha**

The output from the alpha() function will also tell you some basic stats for each item as well as how the overall alpha value would be affected if an item were dropped. If dropping an item would cause alpha to increase, that's an indicator that that item isn't performing as well.

**7. Split-Half reliability**

Split-half reliability is another common statistic showing internal consistency. It reflects how well two halves of the test relate to each other. The splitHalf() function displays several common split-half statistics. You will likely want to report the average split-half reliability, which happens to be 0-point-93: the same value as coefficient alpha! This is coincidental, but the reliability metrics are conceptually similar, so it's not surprising.

**8. Let's practice!**

Now, let's put these functions into practice.

## Viewing and testing correlations

One of the easiest ways to get a feel for your dataset is to examine the relationships of your variables with each other. While base R has the `cor()` function, the `psych` package has the `lowerCor()` function, which only displays the lower triangle of the correlation matrix for easier viewing and interpretation.

You can also use the `corr.test()` function to view several probability values, including p-values from t-tests of each correlation and confidence intervals for the correlations. P-values are corrected using the Holm correction by default.

**Steps**

1. View the lower triangle of the correlation matrix.


```{r}
# Take a look at some correlation data
lowerCor(gcbs, use = "pairwise.complete.obs")
```

2. Check out the p-values created when calculating correlations. Significant values mean items are meaningfully correlated.


```{r}
# Take a look at some correlation data
corr.test(gcbs, use = "pairwise.complete.obs")$p
```

3. View the confidence intervals created when calculating correlations.


```{r}
# Take a look at some correlation data
corr.test(gcbs, use = "pairwise.complete.obs")$ci
```

Nice job! Now you can view variables' correlations as well as p-values and confidence intervals for those correlations.

## Internal reliability

You know how to examine how individual items perform in your measure, but what about how well those items relate to each other - the overall internal reliability of a measure? Coefficient alpha (also called Cronbach's alpha) and split-half reliability are two common ways of assessing reliability. These statistics are a function of the measure length and items' interrelatedness, which you just investigated by looking at the correlation matrix.

In reliability values greater than 0.8 are desired, though some fields of study have higher or lower guidelines.

**Do the results of `alpha()` and `splitHalf()` indicate the `gcbs` dataset has acceptable reliability?**

**Steps**

1. Use `alpha()` to get estimates of coefficient alpha and inspect the results. Be sure to check out the information about how reliability would change if items were dropped.

```{r}
# Estimate coefficient alpha
alpha(gcbs)
```

2. Use `splitHalf()` to estimate split-half reliability.


```{r}
# Estimate coefficient alpha
alpha(gcbs)

# Calculate split-half reliability
splitHalf(gcbs)
```

> *Question*
> ---
> <br>
> <br>
> ✅ Yes, both indices are above 0.8.<br>
> ⬜ No, the coefficient alpha is below 0.8.<br>
> ⬜ Yes, both indices are below 0.8.<br>
> ⬜ Yes, the split-half reliability is below0.8.<br>

That's it! Both indices are well over 0.8. These are great results that would be a good candidate for publication.

## When to use EFA

For which of these measure development situations would an exploratory factor analysis be appropriate?

> *Question*
> ---
> ???<br>
> <br>
> ⬜ You are piloting a measure, and the items are clearly assigned to factors based on theory.<br>
> ✅ You are piloting a measure, but you're not sure which factor(s) each item measures.<br>
> ⬜ You are finalizing a measure that has been previously piloted.<br>
> ⬜ You are drafting items for a new measure.<br>

That's right! Exploratory factor analysis is great when you're not sure about which factor(s) each item should map to.

# 2. Multidimensional EFA

This chapter will show you how to extend the single-factor EFA you learned in Chapter 1 to multidimensional data.

## Determining dimensionality

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Determining dimensionality**

You now know how to do a single-factor EFA, which is useful for seeing how each item relates to a single hypothesized factor. However, you may be wondering, "Haven't I also heard about EFA as a method for dimensionality reduction?" If so, you're right! In the context of measure development, we think of this as figuring out how many unobservable factors are represented by the items on the measure.

**2. How many dimensions does your data have?**

In a truly exploratory situation, you may not know which factors the items on your measure are related to - or even how many factors are represented by the items on your measure.

**3. The bfi dataset**

To switch things up a bit, you'll be using the Big Five Inventory, or bfi, dataset, which contains 2,800 subjects' responses to 25 questions.

**4. Big five personality taits**

Five questions measure each of the big five personality traits: extraversion, agreeableness, openness, conscientiousness, and neuroticism. These "big 5" traits have been extensively studied and are agreed upon by many personality researchers.The bfi dataset in the psych package includes three demographic variables. Since your analyses only work with item response data, I've removed those for you. Though we clearly already know the scientific theory behind this measure and dataset, we'll pretend we don't have this information for the purpose of learning how to run EFAs.

**5. The bfi dataset**

If you use head() to look at the first six rows of the data, you can see that item responses range from 1 to 6, representing respondents' ratings on a six-point scale ranging from Very Inaccurate to Very Accurate. You'll also notice that the column names each consist of a letter and a number. These indicate the personality trait that the item is hypothesized to measure and the question number. For example, A1 is the first question for the agreeableness trait.

**6. Setup: split your dataset**

You'll remember from Chapter 1 that when you are going to use the same dataset for both exploratory and confirmatory analyses, it's important to split the data. Using the same dataset for both can result in overfitting. We'll use the same splitting strategy as in Chapter 1. Here, you'll use one-half of the data for the EFA and the other for the CFA.

**7. Setup: split your dataset**

Checking the output from head() verifies you've created two distinct halves.

**8. An empirical approach to dimensionality**

Though we know the theorized factors for the bfi dataset, you may not always have a theory to guide analysis. In the absence of theory, you can use an empirical approach to quantify dimensionality.To figure out the number of factors the items represent, you can look at eigenvalues, which are a way of quantifying the unique factors within a correlation matrix. We'll work through an applied example of using eigenvalues next.

**9. Calculate the correlation matrix**

Eigenvalues are calculated from matrices, so our first step is to calculate the correlation matrix. Note that we are using the half of the dataset we separated out for the EFA. Also, the correlation matrix is calculated using observations that are pairwise complete.

**10. Eigenvalues**

Once you've got the correlation matrix, you can use it with eigen() to calculate the eigenvalues. The result is a list object containing several pieces of information. Check out the values element to view the eigenvalues.A general rule is that eigenvalues greater than 1 represent meaningful factors. You can count these values in the results, but there's also a quick way to visualize this information.

**11. Scree plots**

You can visualize eigenvalues with the scree plot created by using the scree() function on a correlation matrix.

**12. Scree plots**

You'll get output like this, complete with a horizontal line to help you count the values greater than 1.

**13. Let's practice!**

Let's go try this out!

## Splitting the BFI dataset

For this chapter, you'll be using the `bfi` dataset, which consists of responses to 25 items measuring the Big Five personality traits. I've trimmed the dataset down to only the item responses for your use. Since you'll be doing both exploratory and confirmatory factor analyses on this data, you'll want to start out by splitting the dataset. You'll use the same process that you learned in Chapter 1 when you split the `gcbs` dataset.

**Steps**

1. Split `bfi` in half using two sets of indices (`indices_EFA` and `indices_CFA`) to determine which rows belong to each dataset. 
2. Use the first set of indices to create a dataset for your EFA, then use the second set for your CFA dataset.

```{r}
# Establish two sets of indices to split the dataset
data("bfi")
bfi <- bfi |> dplyr::select(-c(gender, education, age))

N <- nrow(bfi)
indices <- seq(1, N)
indices_EFA <- sample(indices, floor((.5*N)))
indices_CFA <- indices[!(indices %in% indices_EFA)]

# Use those indices to split the dataset into halves for your EFA and CFA
bfi_EFA <- bfi[indices_EFA, ]
bfi_CFA <- bfi[indices_CFA, ]
```

Nice job remembering how to split your dataset! This is important for ensuring you have different data for your exploratory and confirmatory analyses.

## Calculating eigenvalues

To empirically determine the dimensionality of your data, a common strategy is to examine the eigenvalues. Eigenvalues are numeric representations of the amount of variance explained by each factor or component. Eigenvalues are calculated from a correlation matrix, so you'll need to use `cor()` to calculate and store the dataset's correlation matrix before calculating eigenvalues. You'll need to specify that you want to use pairwise complete observations. The default is to use everything, but if your dataset has any missing values, this will leave you with a matrix full of NAs.

You'll do these calculations on the `bfi_EFA` dataset you just created - remember, you're saving the data in `bfi_CFA` for your confirmatory analysis!

**Steps**

1. Use `cor()` to calculate the correlation matrix for your EFA dataset. Set the value of the `use` argument to use pairwise-complete observations.
2. Next, use that correlation matrix with the `eigen()` function to get eigenvalues.
3. The eigenvalues are stored in the `values` element of the `eigenvals` list object. Take a look!

```{r}
# Calculate the correlation matrix first
bfi_EFA_cor <- cor(bfi_EFA, use = "pairwise.complete.obs")

# Then use that correlation matrix to calculate eigenvalues
eigenvals <- eigen(bfi_EFA_cor)

# Look at the eigenvalues returned
eigenvals$values
```

Great work! Now you know how to use the correlation matrix to calculate eigenvalues from a dataset.

## Creating a scree plot

The scree plot is a visual representation of eigenvalues. Visual inspection of the scree plot is a quick and easy way to get a feel for the dimensionality of your dataset. Like the `eigen()` function in the previous exercise, the `scree()` function takes a correlation matrix as its argument. Eigenvalues can be generated from a principal component analysis or a factor analysis, and the `scree()` function calculates and plots both by default. Since `eigen()` finds eigenvalues via principal components analysis, we will use `factors = FALSE` so our scree plot will only display the values corresponding to those results.

**Steps**

1. Once again, calculate the correlation matrix.
2. Next, use that correlation matrix function to create a scree plot.

```{r}
# Calculate the correlation matrix first
bfi_EFA_cor <- cor(bfi_EFA, use = "pairwise.complete.obs")

# Then use that correlation matrix to create the scree plot
scree(bfi_EFA_cor, factors = FALSE)
```

Nice job! Now you can create a scree plot from the eigenvalues.

## Interpreting the scree plot

A commonly used criterion for selecting the optimal number of factors is to only consider factors with eigenvalues greater than 1. `scree()` includes a solid horizontal line at 1 on the y-axis to help you quickly interpret your results. Run the code below to recreate the scree plot from the `bfi_EFA` data you created in the previous exercise. Based on the results, how many factors are recommended?

```{r}
# Calculate the correlation matrix
bfi_EFA_cor <- cor(bfi_EFA, use = "pairwise.complete.obs")

# Use the correlation matrix to create the scree plot
scree(bfi_EFA_cor, factors = FALSE)
```

> *Question*
> ---
> ???<br>
> <br>
> ⬜ 3 factors<br>
> ⬜ 4 factors<br>
> ⬜ 5 factors<br>
> ✅ 6 factors<br>

Right! The scree plot recommends six factors for this data. 

## Understanding multidimensional data

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Multidimensionality: What does it mean?**

So, now you're working with multidimensional data - but what does that mean? What does the number of factors tell you, and why are you getting conflicting information from theory and empirical analyses?

**2. Factors = constructs**

The answers are in the relationship of theory to statistics. A construct is a hypothesized attribute that can't be directly observed or measured. Examples of commonly studied constructs include self-determination, reasoning ability, and extraversion.

**3. Factors = constructs**

Typically, measures are designed to measure specific constructs. While constructs are theory-driven, factors are their mathematical counterparts. Each factor corresponds to a construct.

**4. Interpreting confirmatory analyses**

When you conduct a confirmatory analysis, you evaluate the strength of the hypothesized relationships between items and the constructs they were designed to measure.Model fit statistics provide information about how well the hypothesis fits the data, and factor loadings quantify the relationships between items and constructs for reporting and interpretability. We'll talk about this more in the following chapters.

**5. Interpreting exploratory analyses**

Without theory, you conduct exploratory analyses guided by mathematical values like eigenvalues. You'll continue the exploration by running a multidimensional EFA to see how the items relate to each of those factors.While all of this information can be very helpful in a situation where you don't know much about your data, a lack of theoretical grounding can make these results very difficult to interpret. You can make an educated guess from the factor loadings resulting from your EFA, but this can be challenging.

**6. Running a multidimensional EFA**

Running a multidimensional EFA works just like a unidimensional EFA. All that you have to change is the nfactors argument. In the exercises, you'll go with the number of factors recommended from the scree plot, which was six. As you'll remember, the theory behind the dataset recommended five factors. We'll discuss this disagreement in more detail later and offer some empirical ways to compare different models. Remember, to view a summary of results from the model object, all you have to do is enter the model object on its own line. No need to use the summary argument!

**7. Factor loadings**

As before, you'll be interested in the factor loadings, which represent each item's relationship to each underlying construct. However, the factor loadings look pretty different for a multidimensional EFA! Here are the loadings for the first 15 items. As you can see, the six factors are represented by the six columns. You'll notice the factors have been assigned arbitrary names, and that they're not in the order you'd expect. This is due to the rotation that happens during the mathematical process behind a multidimensional EFA.You'll also notice that some item/factor pairings don't have loadings. The results automatically exclude negligible factor loadings for ease of interpretation.Interpreting these loadings can be challenging. Unlike a CFA, the factors don't have assigned meanings, so the user is left to infer these meanings based on the patterns of item loadings. For example, we can guess that factor MR5 is closely related to agreeableness since the A items all have strong relationships. We can also guess that item A1 should be inversely scored due to its negative relationship with the factor.

**8. Factor scores**

Individuals' factor scores also look different. Rather than a single factor score, each person now has a factor score estimated for each of the six factors. As before, any missing data means that factor scores will not be estimated, as we can see with person 65237.These factor scores shouldn't be interpreted until you have a good working hypothesis for what each of the factors in your EFA represents. Once you have that hypothesis, you can make inferences about the constructs.

**9. Let's practice!**

Okay! Now it's your turn to run a multidimensional EFA.

## Conducting a multidimensional EFA

Now that you've examined the eigenvalues and scree plot to find the data-driven recommended number of factors, you can get down to actually running the multidimensional EFA. In Chapter 1, you ran a unidimensional EFA by using the `fa()` function. To run a multidimensional EFA, you'll want to use the `nfactors` argument to specify the number of factors desired.

As in the previous exercises, you'll want to be sure to run this analysis on the `bfi_EFA` dataset you created earlier.

**Steps**

1. Run a multidimensional EFA using the `fa()` function and the number of factor recommended by the scree plot.  
2. View your model object in the console.

```{r}
# Run the EFA with six factors (as indicated by your scree plot)
EFA_model <- fa(bfi_EFA, nfactors = 6)

# View results from the model object
EFA_model
```

Nice work! Now you can say you've run a multidimensional EFA!

## Interpreting the results

As before, you'll be interested in items' factor loadings and individuals' factor scores. These will be interpreted in the same way, but since your EFA is multidimensional, you’ll get results for each factor.

Remember, an item's loadings represent the amount of information it provides for each factor. Items’ meaningful loadings will be displayed in the output. You’ll notice that many items load onto more than one factor, which means they provide information about multiple factors. This may not be desirable for measure development, so some researchers consider **only** the strongest loading for each item. 

Each examinee will have a factor score for each factor, so that the matrix won't include blanks. However, examinees with missing data will receive NA scores on all factors.

**Steps**

1. Reinforce your learning from the previous exercise: run that multidimensional EFA again using `fa()`!

```{r}
# Run the EFA with six factors (as indicated by your scree plot)
EFA_model <- fa(bfi_EFA, nfactors = 6)
```

2. Look at the items' factor loadings, which are stored in the `loadings` list element of the result object.

```{r}
# Run the EFA with six factors (as indicated by your scree plot)
EFA_model <- fa(bfi_EFA, nfactors = 6)

# View items' factor loadings
EFA_model$loadings
```

3. Then, use the `head()` function to take a look at the first few rows of examinees' factor scores, which are stored in the `scores` list element.

```{r}
# Run the EFA with six factors (as indicated by your scree plot)
EFA_model <- fa(bfi_EFA, nfactors = 6)

# View items' factor loadings
EFA_model$loadings

# View the first few lines of examinees' factor scores
head(EFA_model$scores)
```

You got the most important pieces of information from your EFA! Nicely done!

## Investigating model fit

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Model fit**

Now that you can run multidimensional EFAs, it's time to learn how to interpret various model fit statistics.

**2. Absolute vs. relative model fit**

When thinking about model fit, there are two different types of fit statistics you can consider. Absolute fit statistics are useful for making a judgment about whether or not a model fits adequately. These fit statistics have set ranges and meanings, and they have established cutoff values that are commonly used to determine whether a model has good fit. Examples include the chi-square test, TLI, and RMSEA.Relative fit statistics don't have set ranges or meanings, and they are only useful when comparing nested models estimated from the same dataset. We'll focus on the BIC in this course.

**3. Absolute fit statistics**

When it comes down to it, all of the absolute fit statistics attempt to quantify the discrepancy between the observed data and the data that would be expected given the model. These three common fit statistics represent this difference on different scales and are calculated differently.Ideally, the chi-square test would have a non-significant result, meaning the observed and expected data aren't significantly different. However, since the value of this test is affected by sample size, this rarely occurs for large datasets. Both TLI and RMSEA range from 0 to 1. The TLI, or Tucker-Lewis Index, is also known as the penalized non-normal fit index, meaning that more complex models are penalized for adding additional parameters. This can be roughly understood as how well the observed data match the expected data. Larger TLI values are better: a model can be considered to have good fit if the value is greater than 0-point-90. RMSEA, or the Root Mean Square Error of Approximation, quantifies the differences between the observed and expected data. RMSEA values are interpreted in the opposite direction as TLI values: smaller values are preferred. Values less than 0-point-05 can be said to indicate good fit.

**4. Finding the fit statistics**

All the fit statistics discussed here are displayed in the model output. As you can see, when we run the multidimensional EFA on the bfi_EFA dataset with six factors, the chi-square value of 618-point-43 is significantly different from zero. This isn't ideal, but it's unsurprising given the sample size.You can also see the TLI value is point-916, which is above the cutoff, and the RMSEA is 0-point-045, which is below the cutoff. These are good values that indicate that the model adequately fits the data.You'll notice these values also contain the BIC value for this model, which is -576-point-87. However, since relative fit statistics don't have any value on their own, this doesn't mean much to us yet.

**5. Relative model fit**

To use relative fit statistics, we need two different models to compare. If you remember, the theory behind the BFI dataset recommended five factors, while the eigenvalues recommended six factors. Let's set up those two models by changing up the nfactors argument.When looking at BICs, the lowest BIC is always preferred. You can see that for these two models, the BIC is lower for the bfi_eigen model, which was estimated with six factors.

**6. In sum: evaluating fit**

To sum up, when you are in the process of model development, the first step is to make sure your model or models have adequate fit according to the absolute fit statistics.If you are comparing multiple models that all have good fit, you can use relative fit statistics to make an empirical determination about which model is mathematically preferred.

**7. Let's practice!**

Now you know how to evaluate models' absolute and relative fit statistics! Let's apply these principles to your data.

## Interpret absolute model fit statistics

Now that you know the basics of model fit, let's take a look at the absolute fit statistics for your six-factor EFA on the `bfi_EFA` dataset. 

Those results show the following absolute fit statistics. Which of these indices meet the criteria for good fit?


|Chi-square test |   TLI| RMSEA|
|:---------------|-----:|-----:|
|p-value         | 0.916| 0.045|

> *Question*
> ---
> ???<br>
> <br>
> ⬜ Chi-square test and TLI<br>
> ✅ TLI and RMSEA<br>
> ⬜ Only RMSEA<br>
> ⬜ Only chi-square test<br>

That's right! The TLI is above the 0.90 cutoff for good fit, and the RMSEA is below the 0.05 cutoff for good fit.

## Selecting the best model

Now use your knowledge of finding and interpreting absolute and relative model fit statistics to select the best model for your data. When I introduced this dataset I said that the items were theorized to load onto five factors, but you may have noticed that your scree plot indicated six factors. You might be wondering which you should trust. Not to worry - you can use fit statistics to make am empirical decision about how many factors to use.

First, you'll use the `bfi_EFA` dataset to run EFAs with each of the hypothesized number of factors. Then, you can look at the BIC, which is a relative fit statistic, to compare models. Remember, the lowest BIC is preferred!

**Steps**

1. Run both EFAs on the `bfi_EFA` dataset - one with five factors according to the theory, and one with six factors according to the eigenvalues.
2. Take a look at the BIC value for each of the models. The BIC is stored in the `BIC` list element of the results object.

```{r}
# Run each theorized EFA on your dataset
bfi_theory <- fa(bfi_EFA, nfactors = 5)
bfi_eigen <- fa(bfi_EFA, nfactors = 6)

# Compare the BIC values
bfi_theory$BIC
bfi_eigen$BIC
```

Nice work! You can see that the eigenvalue-driven model has a much lower BIC, so it is  empirically preferred.

# 3. Confirmatory Factor Analysis

This chapter will cover conducting CFAs with the sem package. Both theory-driven and EFA-driven CFA structures will be covered.

## Setting up a CFA

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Setting up a CFA**

At this point in the course, you've successfully conducted both single- and multi-factor exploratory factor analyses. Now let's talk about how to conduct a confirmatory factor analysis.

**2. Why a confirmatory analysis?**

It's all in the name: whereas exploratory analyses estimate all possible variable/factor relationships to focus on exploration, confirmatory analyses explicitly specify variable/factor relationships. Confirmatory analyses are used when you want to test a theory you have already developed.Also, CFA results are generally what you want to publish when you are presenting a newly developed measure to the world. While some journals will publish exploratory results, many peer-reviewed sources want confirmatory results from a separate dataset.

**3. Creating a CFA from EFA results**

One way to set up a CFA is to use the results of your EFA. This image shows the significant loadings from the six-factor EFA you ran at the end of Chapter 2. The solid black lines denote positive loadings and, the dotted red lines denote negative loadings. The psych package features a wrapper function that automatically creates CFA syntax from the significant loadings from the EFA.

**4. Using the wrapper function to set up a CFA**

The structure.sem() wrapper function turns an estimated EFA model into CFA syntax. You can see that the results are expressed with arrows showing the factors' relationships to the variables, the names of the parameters associated with those estimated relationships, and the starting values for the parameters.

**5. Syntax created from the wrapper function**

An illustration, let's take a look at the first entry, which is for parameter F4A1. This represents the path between item A1 and the inferred factor MR5.  In the parameter, this is factor 4, while in the path, it is factor 5. The fa() function automatically names the extracted factors from an EFA before rotation, which is why the numbers don't always match up. Be sure to keep track of these relationships during your analyses.Notice that in the Path column, the directional arrow goes from the factor to the item. This is because, in the underlying theory of statistical modeling, the examinee's level of the latent trait predicts their item responses. In the Parameter column, you'll see that the wrapper function has named the parameter quantifying the relationship between item A1 and the inferred MR5 factor as F4A1. Finally, the NA in the Value column indicates that the starting value for this parameter will be chosen at random during estimation.

**6. Creating CFA syntax from your theory**

The structure.sem() wrapper function will do most of the work for you if you're creating the CFA syntax from EFA results. However, much of the time, you'll want to set up your CFA syntax from the item/factor loadings specified by a theory. The code here sets up the syntax based on the theory underlying the BFI dataset. Remember that there are five hypothesized factors: Agreeableness, Conscientiousness, Extraversion, Neuroticism, and Openness.To set up the syntax, create short and memorable names for your factors, then assign items to each factor. The factor name is followed by a colon, and the items are listed in a comma-separated list.This string variable is sufficient to set up the item/factor relationships, but you'll also need to add in the variances and covariances. The cfa() function from the sem package will automatically do this for you. We're going to set the reference-dot-indicators argument of this function to FALSE. This sets the factor variances to 1 rather than estimating them freely. While not ideal for all situations, this speeds up estimation of the model. In a real application, you should make this decision based on your theory.

**7. Let's create some syntax!**

All right, now you know how to create syntax for a CFA from EFA results or from your theory. Let's go practice these new skills with some exercises.

## Creating CFA syntax from EFA results

The `psych` package provides the wrapper function `structure.sem()` to help you easily turn your EFA results into syntax that can be used to conduct a CFA using the `sem()` function in the `sem` package. This convenience function can save you a lot of time in writing that syntax, so feel free to use it if you agree with the results of your EFA.

**Steps**

1. First, conduct a five-factor EFA on the EFA half of the `bfi` dataset.
2. Then, use the resulting model object as an argument to the `structure.sem()` function to set up the syntax.

```{r}
# Conduct a five-factor EFA on the EFA half of the dataset
EFA_model <- fa(bfi_EFA, nfactors = 5)

# Use the wrapper function to create syntax for use with the sem() function
EFA_syn <- structure.sem(EFA_model)
```

Nice! The EFA_syn object now contains syntax you can plug into the sem() function.

## Creating CFA syntax from theory

While it's easy to create CFA syntax from EFA results, it's a bit trickier to get the syntax set up when you're working directly from a theory. One way to create syntax that can be used with the `sem()` function is to create a series of equations showing which item-factor loadings should be estimated. When creating this matrix, the factor names come first, and a colon separates them from a comma-separated list of items. Once you've set up the initial equations, you can use the `cfa()` function to have the `sem` package add variances and covariances to the model.

**Steps**

1. Write a set of equations showing the five items that load onto each of the five factors: AGE, CON, EXT, NEU, OPE.

```{r}
# Set up syntax specifying which items load onto each factor
theory_syn_eq <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5
NEU: N1, N2, N3, N4, N5
OPE: O1, O2, O3, O4, O5
"
```

2. Use the `cfa()` function to have variances and covariances automatically added to the model.

```{r}
# Package
library(sem)

# Set up syntax specifying which items load onto each factor
theory_syn_eq <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5
NEU: N1, N2, N3, N4, N5
OPE: O1, O2, O3, O4, O5
"

# Feed the syntax in to have variances and covariances automatically added
theory_syn <- cfa(text = theory_syn_eq, 
                  reference.indicators = FALSE)
```

Now you have theory-driven syntax that can be used to conduct a CFA!

## Understanding the sem() syntax

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Understanding the sem() syntax**

In the previous exercises, you set up syntax for running a CFA using the sem() function. Let's take a look at some of the parts that go into that syntax.

**2. Relationships between variables and factors**

If you take a look at what the cfa() function created from your initial input of factors, one of the first things you'll see is syntax expressing the relationships between the factors and the variables that map to them. You'll see three columns of information for each estimated parameter. First, you see the relationship as expressed by a directional path arrow. Notice the direction of the arrows in the relationships - the relationships go from the factors to the items. This is because in the theory underlying factor analyses, the examinees' levels of the latent traits predict their responses on individual items. This is a little counterintuitive at first, but it's important to understand how the analyses work on a conceptual level.Next, the Parameter column contains a name that is automatically assigned to each parameter - lam stands for lambda, which is common notation for these relationships. Finally, there's a starting value to be used in estimation. The StartValue column is blank here because the starting values weren't specified. If you have hypothesized or previously estimated values, you could specify them here to speed up estimation. It's fine not to specify them, though - the sem() function will randomly choose starting values.

**3. Factor variances**

Another type of relationship you'll see in the syntax is factor variances. You'll notice that these are expressed with bidirectional arrows. In order to make the model estimable, these values are fixed, so you'll see they don't get parameter names. The StartValue is 1 because these parameter values are fixed at 1.

**4. Factor covariances**

The relationships between the latent factors are also included in the model as factor covariances, which are also assigned bidirectional arrows. Their parameter names feature a C for covariance followed by brackets enclosing the two factors that covary.When factors covary, it means that respondents' levels of those factors are related, so the factors are probably also theoretically linked as well.

**5. Item variances**

Finally, you'll see the item-level variances expressed in the syntax. These are also bidirectional arrows, and parameter names are assigned with a V for variance followed by the item name within brackets.

**6. Running the CFA**

Hopefully, you now have a bit better understanding of the syntax that goes into a CFA. Good news: actually running the CFA is way easier than understanding the syntax! All you have to do is plug in your syntax object and your dataset into the sem() function.

**7. Interpreting the output**

When you use the summary() function on the CFA results object, you get similar output to what you got from an EFA. You can see the fit statistics at the top,followed by information about residuals. Below that, there are r-square values for the observed variables. These give you information about how much of the variance in the latent factor each item is capable of explaining.Finally, you get the parameter estimates. These include unstandardized regression coefficients from each item/factor relationship, standard errors, Z-values and their corresponding p-values, and the path representation of the relationship.

**8. Let's practice!**

Now you've got an understanding of the syntax underlying a CFA, you've seen how easy it is to run a CFA once you've got the syntax set up, and you've taken a look at the resulting output. Let's go practice all these new skills!

## Components of sem() syntax

Which of the following path entries defines the relationship between Agreeableness and the second item in the `sem()` syntax?

> *Question*
> ---
> ???<br>
> <br>
> ⬜ AGE->A1<br>
> ✅ AGE->A2<br>
> ⬜ A1<->A1</-><br>
> ⬜ AGE<->AGE</-><br>

That's it, nice!

## Run a CFA and interpret loadings

It's finally time to actually run a CFA! You've got the syntax all set up, and now all that's left is to plug it into the `sem()` function along with the appropriate dataset.

Now that you've created syntax and run the model, it's time to look at the results. Output can be viewed using the `summary()` function. After the fit statistics, you'll see the r-squared values for each of the items, which show the proportion of variance in the factor explained by that item. Below those, you'll see parameter estimates for the item/factor relationships (denoted with `lam[]`), the covariances between factors (denoted with `C[]`), and variances of each individual item (denoted with `V[]`).

**Steps**

1. Use the theory-based syntax you created earlier in this chapter to run a confirmatory factor analysis using the `sem()` function.

```{r}
# Use the sem() function to run a CFA
theory_CFA <- sem(theory_syn, data = bfi_CFA)
```

2. Just like with the EFAs, you can use the `summary()` function to view the results of your CFA.

```{r}
# Use the sem() function to run a CFA
theory_CFA <- sem(theory_syn, data = bfi_CFA)

# Use the summary function to view fit information and parameter estimates
summary(theory_CFA)
```

Congrats, now you know how to run a CFA and access the results!

## Examine item loadings

Take a look at the item/factor loadings in `theory_CFA`. Which of the `A` items loads most strongly onto the Agreeableness, or AGE, factor?

> *Question*
> ---
> ???<br>
> <br>
> ⬜ Item A2<br>
> ✅ [Item A3]<br>
> ⬜ Item A4<br>
> ⬜ Item A5<br>

That's right! With a loading of 1.03, Item A3 is most strongly related to the AGE factor.

## Investigating model fit

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Investigating model fit**

Just like with an EFA, you'll also need to investigate and report on model fit statistics for a CFA.

**2. Default fit statistics**

By default, the only absolute fit statistic the summary() function prints is the log likelihood test. You can take a look at that, but as you'll recall, the p-value from this test is often significant due to sample size even though the desired result is a lack of significance.

**3. Changing the options**

In order to get some more meaningful fit statistics, you can set the fit.indices option to include some common fit statistics. The CFI, GFI, and RMSEA are all absolute fit statistics. By using the options() function, you are setting the fit.indices option in the global environment, so the specified indices will always be displayed.The RMSEA should be familiar to you from the EFA chapters. We'll add the GFI, or Goodness of Fit Index, and the CFI, or Comparative Fit Index, which are other fit statistics available from the fit.indices option. The CFI and GFI are conceptually similar to the TLI we discussed in the previous chapter, and the guidelines for "good" values are correspondingly the same. You'll remember from the previous chapter that an RMSEA less than 0.05 is generally considered good model fit.

**4. Absolute model fit**

As promised, you can see that the summary output starts with the likelihood ratio test, which is significant. In theory, we want this to be a non-significant result, but in practice, that rarely happens. Below the likelihood ratio test, you'll see the fit statistics we added. The Goodness of Fit Index here is approximately 0-point-853. A common guideline for this index is that you want it to be greater than 0-point-9. Below that, you'll see the RMSEA. Remember that ideally, you want this value to be less than 0-point-05. For the last absolute fit index, you'll see the CFI. The calculation for this index is similar to the TLI, and it should be interpreted similarly. Ideally, this value would also be greater than 0-point-9.

**5. Relative fit**

The relative fit statistic in the output is the BIC, which is also included in the summary output by default. This isn't much good when you're looking at a single model, but it can be used to compare models.In addition to looking at the summary output, you can also access it by viewing the BIC list element of the result object from the summary() function. This can come in handy if you want to store the BICs from multiple models in a dataframe.

**6. Relative fit: comparing models**

For example, let's look at the BICs for the theory-based CFA and the EFA-based CFA you created from the EFA results. Remember that the lower BIC is preferred, so these results indicate that the theory-based model fits better.Relative fit indices such as the BIC are only useful when comparing nested models that are fit to the same dataset. You shouldn't ever try to compare relative fit indices from non-nested models or from results calculated from different datasets.

**7. Let's practice!**

That's it for your brief overview of how to access and interpret fit statistics from a CFA. Now that you have an understanding of fit statistics let's take these skills and put them into practice.

## Absolute fit statistics

The absolute fit statistic reported in the CFA output is the likelihood ratio Chi-square test, which tests the hypothesis that the estimated model works as well as the null model. You've seen this fit statistic in the previous chapter, so you probably remember that the criteria for this test are very difficult to meet. Most models have a statistically significant result, which is not desirable here, since it means model fit is statistically worse.

After checking the absolute model fit statistics displayed by the `summary()` function, determine whether the likelihood ratio test is statistically significant.

**Would the GFI for this model be considered acceptable?**

**Steps**

1. Set the `fit.indices` option to include several common fit indices.
2. View the summary output from the theory-based CFA and look for the likelihood ratio test.

```{r}
# Set the options to include various fit indices so they will print
options(fit.indices = c("CFI", "GFI", "RMSEA", "BIC"))

# Use the summary function to view fit information and parameter estimates
summary(theory_CFA)
```

> *Question*
> ---
> <br>
> <br>
> ⬜ Yes, it is above 0.9.<br>
> ⬜ Yes, it is below 0.9.<br>
> ⬜ No, it is above 0.9.<br>
> ✅ No, it is below 0.9.<br>

That's right - the GFI is less than 0.9, which means it's below the commonly used criterion.

## Relative fit statistics

In this exercise, we'll use the relative fit statistics from two models to compare their fit. When you have two models that both fit well, relative fit statistics can help you decide which model to select. Since the bfi dataset has a strong theory underlying it - the big five personality factors are commonly accepted and studied - we would like to see the theory-based model fit better than our exploratory EFA-based model.

**Which model is preferred according to its BIC?**

**Steps**

1. First, let's use the CFA syntax we created from the EFA results to run an EFA-based CFA.

```{r}
# Run a CFA using the EFA syntax you created earlier
EFA_CFA <- sem::sem(EFA_syn, data = bfi_CFA)
```

2. Next, display the BIC by calling its list element within the summary output.

```{r}
# Run a CFA using the EFA syntax you created earlier
EFA_CFA <- sem(EFA_syn, data = bfi_CFA)

# Locate the BIC in the fit statistics of the summary output
summary(EFA_CFA)$BIC
```

3. Finally, look at both models' BICs to see which model fits better.

```{r}
# Run a CFA using the EFA syntax you created earlier
EFA_CFA <- sem(EFA_syn, data = bfi_CFA)

# Locate the BIC in the fit statistics of the summary output
summary(EFA_CFA)$BIC

# Compare EFA_CFA BIC to the BIC from the CFA based on theory
summary(theory_CFA)$BIC
```

> *Question*
> ---
> <br>
> <br>
> ✅ The theory-based model, because its BIC is lower.<br>
> ⬜ The theory-based model, because its BIC is higher.<br>
> ⬜ The EFA-based model, because its BIC is lower.<br>
> ⬜ The EFA-based model, because its BIC is higher.<br>

That's right! The theory-based model is preferred due to its lower BIC.

# 4. Refining your measure and/or model

This chapter will reinforce the difference between EFAs and CFAs and offer suggestions for improving your model and/or measure.

## EFA vs. CFA revisited

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. EFA vs. CFA revisited**

This chapter is going to be about improving model fit, but first, let's revisit the differences between EFAs and CFAs. When looking at results to think about model improvement, it is especially important to keep this distinction in mind.

**2. Review of the differences between EFA &amp; CFA**

EFAs and CFAs are mathematically and conceptually different. EFAs estimate all possible item/factor relationships in order to help you identify patterns in the data. This is useful when you don't have a well-developed theory. In contrast, CFAs only estimate the variable/factor relationships that you specify in order to test your theory. CFA results are generally what you'll want to publish when you're developing a new measure.

**3. Differences in factor loadings**

These differences in models, combined with the fact that you are using different halves of the dataset for your EFAs and CFAs, mean that your estimated factor loadings will differ, even for the same item/factor relationships.Let's look at the first five lines of output from the EFA and CFA estimated loadings. You'll notice that the output looks different: the EFA loadings are a matrix showing every item/factor combination, while the CFA loadings are listed one on each row.

**4. Comparing factor loadings**

Another important thing to be attentive to is the factor naming conventions. You'll see in the CFA output that the first loading for factor 4 and item A1 is actually the relationship between A1 and MR5. These differences are due to the rotation involved in EFA estimation. So, the first row of the CFA output, which shows a loading of -0-point-503, is equivalent to row 1, column 4 in the EFA output, which shows a loading of -0-point-390 after rounding.

**5. Differences in factor scores**

The factor scores also differ between the EFA and CFA. To investigate this, the first step is to get the factor scores from each model. This is a bit more involved with the CFA results, as you'll want to use the fscores() function. Here, you'll see we're calculating factor scores from the CFA we ran based on the EFA results in order to ensure maximum comparability. We're also using the bfi_EFA dataset - again, for maximum comparability.With the EFA results, you can just access the scores list element in the model object. Remember that this model was created using the bfi_EFA dataset, so if there were no differences between the model parameters, these scores would be identical.

**6. Differences in factor scores, visualized**

To visualize the differences in factor scores obtained from the EFA and CFA, we can use a density plot. This is similar to how we plotted factor scores in Chapter 1, but now we'll add a second density curve using lines().As you can see from this graph, the score distributions are not identical, which indicates that the model parameters are different. The factor scores from the EFA parameters are represented by the blue density curve, and factor scores from the CFA parameters are represented by the red density curve. Notice how the blue EFA distribution is flatter and less normal than the CFA distribution.

**7. Let's practice!**

Okay, we've reviewed the differences between EFAs and CFAs and examined some evidence showing those differences. Now it's time for you to put this into action.

## Differences in estimated factor loadings

The differences between EFAs and CFAs are evident when examining the factor loadings. Not only are the procedures mathematically different, but the number of estimated parameters is also different. By default, EFAs estimate all possible item/factor pairs, while CFAs only estimate specified item/factor relationships. Let's take a look at a few of those estimated loadings and see how they differ.

**Which of these loadings represent the EFA and CFA estimates of the relationship between item A1 and the fourth factor (named MR5)?**

**Steps**

1. Check out the first five rows of `loadings` in `EFA_model`. Remember that the EFA estimates all possible item/factor pairs.
2. Look at the first five loadings in `EFA_model`. This output only estimates specified item/factor relationships.

```{r}
# View the first five rows of the EFA loadings
EFA_model$loadings[1:5,]

# View the first five loadings from the CFA estimated from the EFA results
summary(EFA_CFA)$coeff[1:5,]
```

> *Question*
> ---
> <br>
> <br>
> ⬜ 0.24 &amp; -0.50<br>
> ✅ -0.39 &amp; -0.50<br>
> ⬜ -0.39 &amp; -0.08<br>
> ⬜ 0.24 &amp; 0.82<br>

Yep! These are the EFA and CFA estimates of the loading of item A1 on factor MR5 (which is the fourth factor after rotation).

## Plotting differences in persons' factor scores

Factor loadings aren't the only parameters that differ between EFA and CFA results. Individuals' factor scores also differ when they are calculated from the EFA or CFA parameters. To illustrate this, we'll look at how factor scores for individuals in the `bfi_EFA` dataset differ when they are calculated from the EFA model versus from the CFA model by examining those scores' density plots.

**Steps**

1. First, save the scores from the `scores` named list element from the `EFA_model` object into a new object. Since this model was created from the `bfi_EFA` dataset, the factor scores are from that dataset.
2. Next, use `fscores()` to calculate and extract individuals' factor scores using the CFA model object with the same `bfi_EFA` dataset.
3. Finally, use the `plot()` and `lines()` functions to graph the densities of the individuals' factor scores on the first factor.

```{r}
# Extracting factor scores from the EFA model
EFA_scores <- EFA_model$scores

# Calculating factor scores by applying the CFA parameters to the EFA dataset
CFA_scores <- fscores(EFA_CFA, data = bfi_EFA)

# Comparing factor scores from the EFA and CFA results from the bfi_EFA dataset
plot(density(EFA_scores[,1], na.rm = TRUE), 
    xlim = c(-3, 3), ylim = c(0, 1), col = "blue")
lines(density(CFA_scores[,1], na.rm = TRUE), 
    xlim = c(-3, 3), ylim = c(0, 1), col = "red")
```

Excellent job! You'll notice these density plots look different - that's because individuals' estimated factor scores are different depending on which model you used to calculate them.

## Adding loadings to improve fit

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Adding loadings to improve model fit**

Now that we've reviewed the differences between EFAs and CFAs, we'll look at how to improve model fit.

**2. When to make adjustments**

While EFAs estimate all variable/factor loadings, CFAs only estimate the loadings you specify. If you run your CFA and get disappointing fit statistics, adding additional loadings is one way to improve model fit.

**3. Adding loadings to the syntax**

One way to select loadings to add is to look at the results of an EFA with the number of factors dictated by your theory. I've done this for you and picked a couple promising item/factor relationships to add: the fourth Neuroticism item could load to the Extraversion factor, and the third Extraversion item could load to the Neuroticism factor. Both of these proposed relationships hinge on a correlation between the Neuroticism and Extraversion factors. If we look at the summary stats from the original, theory-based CFA, we can see that these factors have a small positive correlation, so this isn't a totally implausible adjustment to the theory. Of course, in a real data application, you'll want to carefully evaluate the theoretical implications of adding loadings.

**4. Adding new loadings to the syntax**

Here's a graphical representation of what adding loadings looks like. You're effectively saying that the Neuroticism factor can predict responses to item E3 and the Extraversion factor can predict responses to item N4. These new relationships are shown here by bold green arrows.

**5. Adding new loadings to the syntax**

The first step to adding new loadings is to alter the syntax for the CFA. You can do this by adding the new relationships to the equations used to create the syntax. You can see that we've added item N4 to the Extraversion factor, which is abbreviated EXT in our syntax, and we've also added item E3 to the Neuroticism factor, which is abbreviated NEU.Next, you'll feed those equations into the cfa() function to create syntax compatible with the sem() function used to run the CFA.Once you've got the syntax set up, you can go ahead and plug that revised syntax into the sem() function to run the CFA. As before, remember to continue using the bfi_CFA dataset, since this is still a CFA.

**6. Comparing the original and revised models**

Now, let's conduct a likelihood ratio test. As you may remember, this tests to see whether the two models fit statistically differently. When you are testing a model against the null model, you want this to be non-significant; however, when you are comparing two specified models, a significant result indicates that one model fits significantly better and is preferred. As the legend at the bottom shows, the stars after the p-value indicate a statistically significant difference, so this is a good result!

**7. Comparing the original and revised models**

Another fit index to consider is the CFI. The higher value corresponds to the better-fitting model. You can see that the revised model's CFI is higher here.

**8. Comparing the original and revised models**

The final fit index we'll look at will be the RMSEA. The first value in the output shows the RMSEA value. The next values are the bounds of the 90% confidence interval, which are NA here due to how the model is specified.The important thing here is to identify the lower RMSEA, which is associated with the revised model. As you'll recall, you ideally want the RMSEA to be less than 0.05. Neither of these are, but at least you're a bit closer with the revised model!For more information about calculating and interpreting these and other fit indices, check out this website.

**9. Let's practice!**

Now that you've seen a demonstration of adding loadings and comparing models, it's time to try it for yourself!

## Add loadings to improve fit

Adding more item/factor relationships will always improve your model fit because more parameters are always going to fit the data more precisely. However, when adding loadings, you want to be sure they are justifiable by theory. A good place to start is with loadings that were strong in an EFA with the same number of factors (on a separate dataset, of course!) - you can consider whether those suggested item/factor relationships might be justified by theory. If they are supported by your theory, you can add them to your CFA.

**Steps**

1. First, let's add some of the other strong factor loadings from the EFA. The fourth neuroticism item could load to Extraversion, and the third extraversion item could load to Neuroticism.

```{r}
# Add some plausible item/factor loadings to the syntax
theory_syn_add <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5, N4
NEU: N1, N2, N3, N4, N5, E3
OPE: O1, O2, O3, O4, O5
"
```

2. Next, use the `cfa()` function to convert your series of equations into `sem()`-compatible syntax.

```{r}
#Add some plausible item/factor loadings to the syntax
theory_syn_add <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5, N4
NEU: N1, N2, N3, N4, N5, E3
OPE: O1, O2, O3, O4, O5
"

# Convert your equations to sem-compatible syntax
theory_syn2 <- cfa(text = theory_syn_add, reference.indicators = FALSE)
```

3. Finally, run a CFA using your new syntax.

```{r}
# Add some plausible item/factor loadings to the syntax
theory_syn_add <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5, N4
NEU: N1, N2, N3, N4, N5, E3
OPE: O1, O2, O3, O4, O5
"

# Convert your equations to sem-compatible syntax
theory_syn2 <- cfa(text = theory_syn_add, reference.indicators = FALSE)

# Run a CFA with the revised syntax
theory_CFA_add <- sem(model = theory_syn2, data = bfi_CFA)
```

Great! You've added item/factor loadings for some conceivable relationships.

## Compare original model to model with added loadings

Once you have a revised version of the theory-based model with added loadings, it's time to compare it to the original theory-based model. By adding loadings, you are actually saying that those items measure more than one construct, so you would want to carefully evaluate the additions' impacts on your theory. For this exercise, we'll conduct a likelihood ratio test, then compare the CFIs and RMSEAs.

**Steps**

1. Use the `anova()` function to conduct a likelihood ratio test to see whether the models fit significantly differently.

```{r}
# Conduct a likelihood ratio test
anova(theory_CFA, theory_CFA_add)
```

2. Check out the fit indices for each model to see which fits better.


```{r}
# Conduct a likelihood ratio test
anova(theory_CFA, theory_CFA_add)

# Compare the comparative fit indices - higher is better!
summary(theory_CFA)$CFI
summary(theory_CFA_add)$CFI
```

3. Investigate the RMSEAs for each model to see which fits better.


```{r}
# Conduct a likelihood ratio test
anova(theory_CFA, theory_CFA_add)

# Compare the comparative fit indices - higher is better!
summary(theory_CFA)$CFI
summary(theory_CFA_add)$CFI

# Compare the RMSEA values - lower is better!
summary(theory_CFA)$RMSEA
summary(theory_CFA_add)$RMSEA
```

Yep, the revised CFA fits better! In real life, you would carefully consider whether the new loadings make sense with your theory.

## Evaluate added loadings with relative fit stats

In the previous exercise, you used several absolute fit statistics to compare the original theory-based CFA to the version with added item loadings. You can also use relative fit statistics like the BIC to compare models like these. 

**According to the BIC values, which model is preferred?**

**Steps**

1. Check out the models' BIC values to see which one is preferred.

```{r}
# Compare BIC values
summary(theory_CFA)$BIC
summary(theory_CFA_add)$BIC
```

> *Question*
> ---
> <br>
> <br>
> ⬜ The original model is preferred due to its lower BIC.<br>
> ⬜ The original model is preferred due to its higher BIC.<br>
> ✅ The model with added loadings is preferred due to its lower BIC.<br>
> ⬜ The model with added loadings is preferred due to its higher BIC.<br>

Exactly! The model with added loadings has a lower BIC, which indicates it is the preferred model.

## Improving fit by removing loadings

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Removing loadings to improve fit**

The last lesson was about adding loadings to improve fit. You can also remove loadings to improve fit by getting rid of weak item/factor relationships.

**2. What does it mean to remove a loading?**

For this lesson, you'll learn how to remove a loading by deleting the loading of item O4 to the Openness factor. If you inspect the CFA results, you'll notice that this was the weakest loading, with a value of 0-point-287.

**3. What does it mean to remove a loading?**

Here's what deleting loadings from the model looks like conceptually. In this example, you are effectively not only deleting the loading, you are also excluding the O4 item from the model since there are no other loadings associated with that item. By deleting this loading, you are effectively revising the measure by removing that item.

**4. Removing a loading in the syntax**

The process for changing up the syntax and rerunning the CFA is just like when you were adding an item. First, you'll remove item O4 from the equations used to create the original syntax. This actually tells the package not to estimate the relationship between item O4 and the Openness factor. Then, as before, use the cfa() function to convert those equations to sem-compatible syntax.

**5. Running the revised CFA**

You'll notice when you run the CFA with the revised syntax; you get a new warning. Since you've effectively removed item O4 from your model, the sem() function doesn't like that it's still in your input dataset. Don't worry - it's just a warning, not an error. It's difficult to turn this off, so just be sure to review the warning messages and make sure nothing unexpected pops up.

**6. Comparing the original and revised models**

You may recall that when you added loadings, the first type of comparison was to run a likelihood ratio test. Since you've discarded an item, though, the models aren't run on the same dataset, and the likelihood ratio test can't be run.Instead, let's first look at the fit indices. As you'll see, the model with the deleted item and loading has a higher CFI and is therefore preferred.

**7. Comparing the original and revised models**

You can also still consult the RMSEAs. The difference here isn't as noticeable, but you can see that the RMSEA is a teeny bit lower for the revised model. Again, for more information about calculating and interpreting fit indices, check out this website, which covers the indices in this lesson as well as several others.

**8. Let's practice!**

Okay! This is conceptually very different from adding loadings, but the code required is pretty similar. Let's go try this out.

## Remove loadings to improve fit

Removing weak item/factor relationships will typically improve your model fit because you're estimating only meaningful parameters. However, when removing loadings, you want to be sure you are okay with removing the item from your measure. Removing an item's loading effectively means that item is no longer included in your measure, and scores on that item won't be considered in the analysis.

**Steps**

1. First, let's remove the weakest factor loading from the CFA, which is the fourth Openness item's loading on its factor.

```{r}
# Remove the weakest factor loading from the syntax
theory_syn_del <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5
NEU: N1, N2, N3, N4, N5
OPE: O1, O2, O3, O5
"
```

2. Next, convert your series of equations into `sem()` compatible syntax.

```{r}
# Remove the weakest factor loading from the syntax
theory_syn_del <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5
NEU: N1, N2, N3, N4, N5
OPE: O1, O2, O3, O5
"

# Convert your equations to sem-compatible syntax
theory_syn3 <- cfa(text = theory_syn_del, reference.indicators = FALSE)
```

3. Finally, run a CFA using your new syntax.

```{r}
# Remove the weakest factor loading from the syntax
theory_syn_del <- "
AGE: A1, A2, A3, A4, A5
CON: C1, C2, C3, C4, C5
EXT: E1, E2, E3, E4, E5
NEU: N1, N2, N3, N4, N5
OPE: O1, O2, O3, O5
"

# Convert your equations to sem-compatible syntax
theory_syn3 <- cfa(text = theory_syn_del, reference.indicators = FALSE)

# Run a CFA with the revised syntax
theory_CFA_del <- sem(model = theory_syn3, data = bfi_CFA)
```

Great! You've removed the weakest item/factor loading.

## Compare original model to model with deleted loadings

Once you have a revised version with that weak loading deleted, it's time to compare it to the original theory-based model. If you were the developer of this measure, you would probably hope that the original version would fit better, since you would have carefully constructed items to measure your theoretical constructs. In practice, though, it can be tricky to know whether or not items are actually performing well, and sometimes you might want to drop items to create a stronger measure. For this exercise, we'll compare the CFIs and RMSEAs.

**Steps**

1. Check out the absolute fit indices for each model to see which fits better.
2. Investigate the RMSEAs for each model to see which fits better.

```{r}
# Compare the comparative fit indices - higher is better!
summary(theory_CFA)$CFI
summary(theory_CFA_del)$CFI

# Compare the RMSEA values - lower is better!
summary(theory_CFA)$RMSEA
summary(theory_CFA_del)$RMSEA
```

Once again, the revised CFA fits better! In real life, you would carefully consider whether you are okay with excluding that loading and dropping that item.

## Evaluate deleted loadings with relative fit stats

In the previous exercise, you used several absolute fit statistics to compare the original theory-based CFA to the version with added item loadings. You can also use relative fit statistics like the BIC to compare models like these. 

**According to the BIC values, which model is preferred?**

**Steps**

1. Check out the models' BIC values to see which one is preferred.

```{r}
# Compare BIC values
summary(theory_CFA)$BIC
summary(theory_CFA_del)$BIC
```

> *Question*
> ---
> <br>
> <br>
> ⬜ The original model is preferred due to its lower BIC.<br>
> ⬜ The original model is preferred due to its higher BIC.<br>
> ✅ The model with a deleted loading is preferred due to its lower BIC.<br>
> ⬜ The model with a deleted loading is preferred due to its higher BIC.<br>

Exactly! The model with a deleted loading has a lower BIC, which indicates it is the preferred model.

## Wrap-Up Video

Theory. Coming soon ...
<p class="dc-cookie-banner-text">                DataCamp and our partners use cookies and similar technologies to improve your learning experience, offer data science content relevant to your interests, improve the site and to show more relevant advertisements. You can change your mind at any time.            



**1. Now you can conduct and interpret EFAs and CFAs!**

All right, that's it for this course!

**2. Things you can do**

Along the way, you learned several skills that will help you through the process of developing, refining, and reporting results from a measure. You can conduct both uni- and multi-dimensional EFAs, which help you explore the structure of your data when you don't have a theory. You also learned how to conduct CFAs to confirm your model, either from a structure based on EFA results or from a structure based on a theory. Finally, you learned how to interpret both absolute and relative fit statistics to compare models and make adjustments if needed.

**3. More information**

As you may have guessed, there's a lot more to factor analysis than we had the time to cover here. For more information, check out the documentation for the psych and sem packages or pick up a book on multivariate analysis. I recommend Applied Multivariate Statistical Analysis by Johnson &amp; Wichern, which will walk you through the mathematics of these analyses while maintaining a focus on application.The next level to this sort of analysis is structural equation modeling, which allows you to estimate hierarchical relationships between latent variables. There's a great DataCamp course that you can take next if you're interested!

**4. Congrats!**

So, finally, congrats, and thanks for taking this course.


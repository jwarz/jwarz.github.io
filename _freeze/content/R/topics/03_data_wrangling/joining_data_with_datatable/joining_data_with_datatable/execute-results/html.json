{
  "hash": "a5516ac274dade5a2576123fbbabc315",
  "result": {
    "markdown": "---\ntitle: \"Joining Data with data.table in R\"\nauthor: \"Joschka Schwarz\"\ntoc-depth: 2\n---\n\n\n\n\n**Short Description**\n\nThis course will show you how to combine and merge datasets with data.table.\n\n**Long Description**\n\nIn the real world, data sets typically come split across many tables while most data analysis functions in R are designed to work with single tables of data. In this course, you'll learn how to effectively combine data sets into single tables using data.table. You'll learn how to add columns from one table to another table,\\nhow to filter a table based on observations in another table, and how to identify records across multiple tables matching complex criteria. Along the way, you'll learn how to troubleshoot failed join operations and best practices for working with complex data sets. After completing this course you'll be well on your way to be a data.table master!\\n\n\n# 1. Joining Multiple data.tables \n\nThis chapter will show you how to perform simple joins that will enable you to combine information spread across multiple tables.\n\n## Welcome to the course\n\nTheory. Coming soon ...\n\n\n**1. Welcome to the course**\n\nHi, my name is Scott Ritchie. I'll be your instructor for this course on joining data in R with data table. Welcome, and I look forward to seeing you in the course.\n\n**2. Joining data.tables**\n\nA join describes the action of combining information from two different data tables into a single data table. This is a fundamental skill when working with multiple data sources. The majority of R's functions for analyzing and visualizing data are designed to work on a single data frame or data table. But, you'll often find data you want to analyze is spread across multiple datasets, that may come from different sources. For example, you might be working with two data tables in your customer database. One containing their demographic information, shown in blue, and another containing their shipping address, shown in orange. The question is: how do you build a single data table containing all the information about each customer? Joins are an efficient and reliable way of solving this type of problem.\n\n**3. Course overview**\n\nIn chapter one of the course, you'll learn how to use the merge function to perform four types of joins that you can find in any data-driven language. In chapter two you'll learn how to incorporate joins directly into your data table workflows. In chapter three, you'll learn how to diagnose and avoid common join errors. Finally, in chapter four you'll learn how to concatenate data tables that have the same columns, and how to transform them between wide and long formats.\n\n**4. Table keys**\n\nThe first skill you need to learn is to identify the join key columns. These are the columns you need in each data table to match the rows between them for a join. No matter what type of join you want to do, you will always need to know which columns to use as join keys. Returning to the customer database example, to match the rows between the two data tables you would need to use the values stored in the name column, as you can see from their highlighted matching values.\n\n**5. Inspecting `data.tables` in your R session**\n\nTo identify join keys, you will need to learn about the contents of the data tables you are working with. There are a few different ways you can do this. The first way is using the tables() function. It will show you all data tables in your R session, along with their number of rows, their number and names of their columns, and how much space they occupy in terms of memory. It will also tell you any columns you have set as their keys, which you'll learn in the next chapter.\n\n**6. Inspecting `data.tables` in your R session**\n\nAnother way is using the str() function. This is a general purpose function that will show you the type of data stored in any R object, in this case, a data table along with the types and first few entries of each column.\n\n**7. Inspecting `data.tables` in your R session**\n\nFinally, typing in the variable name and hitting enter in the console will show you the values stored in a data table. If it has more than 100 rows, only the first and last five rows are displayed by default.\n\n**8. Let's practice!**\n\nNow lets explore some of the data tables you will be using in this course. \n\n## Exploring data.tables\n\nIn this exercise, you will explore two `data.table`s: \n\n* `netflix`: contains information about some of the <a href=\"https://www.netflix.com\">Netflix</a> \noriginal series released in 2017\n* `imdb`: contains ratings for some TV shows and movies obtained from <a href=\"https://www.imdb.com\">IMDB</a>\n\n*This course touches on a lot of concepts you may have forgotten, so if you ever need a quick refresher, download the <a href=\"https://datacamp-community-prod.s3.amazonaws.com/6fdf799f-76ba-45b1-b8d8-39c4d4211c31\">data.table Cheat Sheet</a> and keep it handy!*\n\n**Steps**\n\n1. Use the `tables()` function to show all the `data.tables`s in your R session (along with their number of rows, columns and other info). \n2. Use the `head()` function to print the first 6 rows of `netflix` and `imdb`. \n3. Print the `str()`ucture of `netflix` and `imdb`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(data.table)\n\n# Load data\nnetflix <- fread(\"data/netflix_2017.csv\")\nimdb    <- fread(\"data/imdb_ratings.csv\")\n\n# What data.tables are in my R session?\ntables()\n\n# View the first six rows \nhead(netflix)\nhead(imdb)\n\n# Print the structure\nstr(netflix)\nstr(imdb)\n```\n:::\n\n\nNice work! Let's take a closer look at these `data.table`s!\n\n## Identifying join keys\n\nThe `netflix` and `imdb` `data.table`s from the previous exercise have been loaded into your workspace. \n\n> *Question*\n> ---\n> Which columns can be used to match the rows across these two `data.table`s?<br>\n> <br>\n> ⬜ The `\"release_date\"` column in `netflix` and the `\"title\"` column in `imdb`.<br>\n> ⬜ The `\"episodes\"` column in `netflix` and the `\"rating\"` column in `imdb`.<br>\n> ✅ The `\"title\"` column in both `netflix` and `imdb`.<br>\n\nWell done! Remember that columns that link observations across `data.table`s are known as \"join keys\".\n\n## Multiple data.tables, multiple keys\n\nThree new `data.table`s are available in your workspace: `area`, `capitals`, and `population`, containing basic statistics about the geography and demographics of Australia.\n\n> *Question*\n> ---\n> Which columns can be used to match rows across these three `data.table`s?<br>\n> <br>\n> ⬜ None, because no column is present in all three `data.table`s.<br>\n> ⬜ The `\"state\"` column in `area` and `capitals`. But no key can uniquely identify rows in `population` and `capitals`.<br>\n> ✅ The `\"state\"` column for joining `area` and `capitals`, and the `\"city\"` column for `capitals` and `population`.<br>\n\nExcellent! A `data.table` may have different join key columns depending on the other `data.table` it is joined to.\n\n## The merge function\n\nTheory. Coming soon ...\n\n**1. The merge function**\n\nNow that you can successfully identify join keys, it's time to learn how to perform joins using the merge() function.\n\n**2. Joins**\n\nIn this chapter, you will learn four different joins. The inner join, the full join, the left join, and the right join. Each of these joins give a different result, based on what observations are present in one data table but not in the other.All four are standard joins that originally come from database query languages, such as SQL. So the concepts and skills you will learn in this chapter are widely applicable, not just for the data table package in R. In this chapter, you will learn how to do these joins using the merge() function. This function comes from base R but is extended in the data table package to work efficiently with data tables.\n\n**3. Inner join**\n\nAn inner join combines the columns of two data tables, keeping only the observations present in both data tables, that is, rows whose value in the join key column can be found in both data tables.Returning to our example customer database, an inner join of the demographics data table, shown in blue, to the shipping addresses data table, shown in orange, creates a new data table containing all the columns from both data tables, containing just the people with entries in both; those highlighted in pink, yellow, and green. An inner join is the default behavior of the merge() function.  It takes two data tables as inputs, one to its x and one to its y arguments, along with the name of the key column in each data table to the by.x and by.y arguments respectively.\n\n**4. The by argument**\n\nWhen the key columns have the same name in both data tables, you can use the by argument instead to avoid typing the column name twice.\n\n**5. Full join**\n\nIf you want to keep all observations that are present in either data table you can supply an additional argument to the merge() function; setting the all argument to be equal to TRUE. This is known as a full join or a full outer join. Observations which were present in only one data table will have missing values in the columns from the other data table, as shown in the white cells in the result.\n\n**6. Let's practice!**\n\nIn the next lesson, you will learn about left joins and right joins. But now, it's time for you to practice inner joins and full joins.\n\n## Inner join\n\nTwo `data.table`s are available in your workspace:  \n\n* `netflix`: contains a selection of original series released by <a href=\"https://www.netflix.com\">Netflix</a> in 2017\n* `imdb`: contains average user ratings for a selection of TV shows and movies from <a href=\"https://www.imdb.com\">IMDB</a>. \nYour goal is use the <a href=\"https://www.rdocumentation.org/packages/data.table/topics/merge\">`merge()`</a> function to perform an inner join to build a new `data.table` containing all series from `netflix` that have a rating in `imdb`.\n\n**Steps**\n\n1. Remind yourself of the contents of both `data.table`s by printing them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print the data.tables in your R session\nnetflix\nimdb\n```\n:::\n\n\n2. Use the correct column to inner join `netflix` and `imdb` using the `merge()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inner join netflix and imdb\nmerge(netflix, imdb, by = \"title\")\n```\n:::\n\n\nGreat job! Inner joins are useful when you want to build a complete set of information for observations that are present in both `data.table`s.\n\n## Full join\n\nUsing the same `data.table`s as the previous exercise, this time use `merge()` to perform a full join to build a new `data.table` containing all rows present in either `netflix` or `imdb`.\n\n**Steps**\n\n1. Use the `merge()` function to full join the `netflix` and `imdb` `data.table`s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full join netflix and imdb\nmerge(netflix, imdb, by = \"title\", all = TRUE)\n```\n:::\n\n\n2. Try swapping the order of the `netflix` and `imdb` `data.table`s in the merge function to see what changes!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full join imdb and netflix\nmerge(imdb, netflix, by = \"title\", all = TRUE)\n```\n:::\n\n\nNice work! The new `data.table` contains all TV shows and movies listed in either `netflix` or `imdb`.\n\n## Left and right joins\n\nTheory. Coming soon ...\n\n**1. Left and right joins**\n\nThere are two more joins you can perform using the merge() function, left joins and the right joins.\n\n**2. Left joins**\n\nA left join keeps only the observations that are present in the data table on the left side of the join. In other words, a left join will add information from the data table on the right to the data table on the left. This is useful when you have two data tables from different sources, but you're really only interested in the observations from one.The data table on the left side of the join is the data table given to the x argument of the merge() function. To perform a left join with the merge() function, you set the argument all.x to be equal to TRUE.\n\n**3. Right joins**\n\nConversely, a right join keeps only the observations that are present in the data table on the right side of the join. The data table on the right side of the join is the data table given to the y argument of the merge() function. To perform a right join with the merge() function you set the argument all.y to be equal to TRUE.\n\n**4. Right joins - Left joins**\n\nThe outcome is the same as swapping the order of the data tables in the merge() function and performing a left join. Most people find one or the other to fit more naturally when thinking about data and stick to that. Its only in rare cases when joining multiple data tables in a sequence of joins where you might need to use both left and right joins.\n\n**5. Default values**\n\nAny arguments you don't specify in a function call in R take on their default values. For example, the arguments all, all.x, and all.y for the merge() function have a default value of FALSE. You can look up the default values for any function's arguments by using the help() function.\n\n**6. Exercise instructions**\n\nIn the code exercises throughout the rest of the course, you will be instructed to join one data table to another using the wording you see on the slide. Regardless of the type of join, the data table that you see after the word \"to\" should always be placed on the left side of the join in your code.So if we ask you to join the shipping data.table to the demographics data table, the demographics data table should always be on the left side of the join: the first argument to the merge function.\n\n**7. Let's practice!**\n\nGo ahead and code some left and right joins.\n\n## Left join\n\nIn this exercise, you will practice left joins! In a left join, rows from only the left (or the first) `data.table` will be retained. \n\nBoth `netflix` and `imdb` are available in your workspace.\n\n**Steps**\n\n1. Use the `merge()` function to left join `imdb` *to* `netflix`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left join imdb to netflix\nmerge(netflix, imdb, by = \"title\", all.x = TRUE)\n```\n:::\n\n\nFantastic! Did you notice that missing information for observations that are not present in the right table of the join contain `NA`s for the right `data.table`'s columns?\n\n## Right join\n\nIn this exercise, you will right join `imdb` *to* `netflix`. The resulting `data.table` should contain all entries from `imdb` with the release date and the number of episodes added for titles that are also listed in the `netflix` `data.table`.\n\n**Steps**\n\n1. Use the `merge()` function to right join `imdb` *to* `netflix`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Right join imdb to netflix\nmerge(netflix, imdb, by = \"title\", all.y = TRUE)\n```\n:::\n\n\n2. Compare the right join you performed in the previous step to the left join of `netflix` *to* `imdb`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare to a left join of netflix to imdb\nmerge(imdb, netflix, by = \"title\", all.x = TRUE)\n```\n:::\n\n\nNicely done! Right joins and left joins are essentially the same, with the order of input `data.table`s swapped in the join.\n\n## Mastering simple joins\n\nThree new `data.tables` have been loaded into your R session containing information about the geography and population of Australia: `area`, `capitals`, and `population`. Your goal is to perform a sequence of joins to build a single `data.table` containing information about the geographical area of each Australian state and the population of its capital city, storing the final result in a new variable: `australia_stats`. There are three `data.tables` so you will need to perform two joins. First, you will join `capitals` and `population`, and then you will join the resulting `data.table` to the `area`.\n\n**Steps**\n\n1. Identify the key column so you can join `capitals` and `population`. Assign the column name as a string to `capitals_population_key`. \n2. Using this key, left join `population` to `capitals`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\ncapitals   <- fread(\"data/australia_population/australia_capitals.csv\")\npopulation <- fread(\"data/australia_population/australia_cities_top20.csv\", drop = \"percentage\") \narea       <- fread(\"data/australia_population/australia_area.csv\",         drop = \"precentage\")\n\n# Identify the key for joining capitals and population\ncapitals_population_key <- \"city\"\n\n# Left join population to capitals\ncapital_pop <- merge(capitals, population, by = capitals_population_key, all.x = TRUE)\ncapital_pop\n```\n:::\n\n\n3. Identify the key column so you can join `capital_pop` and `area`. Assign the column name as a string to `capital_pop_area_key`. \n4. Using this key, inner join `area` to `capital_pop`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify the key for joining capital_pop and area\ncapital_pop_area_key <- \"state\"\n\n# Inner join area to capital pop\naustralia_stats <- merge(capital_pop, area, by = capital_pop_area_key)\n\n# Print the final result\naustralia_stats\n```\n:::\n\n\nWell done! Mastering these joins enables you to combine information in many different ways to build the right `data.table` to ask your data science questions of interest.\n\n# 2. Joins Using data.table Syntax\n\nIn this chapter you will perform joins using the data.table syntax, set and view data.table keys, and perform anti-joins.\n\n## Joins using data.table syntax\n\nTheory. Coming soon ...\n\n**1. data.table syntax**\n\nCongratulations on completing the first chapter and welcome back. In this lesson, you will perform joins using the data table syntax.\n\n**2. Recap of the data.table syntax**\n\nThe general form of a data table is shown here. It can be read out loud as \"Take DT, filter its rows in i, then compute on columns j grouped by values in columns by.\n\n**3. Joins**\n\nTo perform a join using this syntax, you pass another data table to the i argument. This can be read out loud as \"Join DT to i using the column in on as the join key\".You can think of it as just any other filter operation in i, except here you're filtering the rows in DT based on those that have matches to rows in i.\n\n**4. Right joins**\n\nThis naturally leads to the definition of a right join. Like any other subset operation in R, values that have no match return missing values. So here, rows from the data table you are subsetting on in the i argument are kept in the result, with missing values where there was no match in the main data table.\n\n**5. The on argument**\n\nJoin key columns are supplied to the on argument. This follows similar rules to the j and by arguments in the data table syntax. If you use the list function or its alias you can enter the join key column name as if it was a variable.You can also use a character vector to specify the join key. This also allows you to store the join key in a variable that you pass to the on argument. Note that here we haven't used the list function or its alias, so the data table syntax looks for the join underscore key variable, not for a column with the same name.\n\n**6. Left joins**\n\nTo perform a left join you can swap the order of the data tables, so that the data table on the left side of the join is passed to the i argument. To left join the demographics data table shown in blue to the shipping data table shown in orange we swap the order of data tables from the previous slide and perform a right join on the demographics data table.\n\n**7. Inner joins**\n\nTo perform an inner join you supply an additional argument, nomatch equals zero. This tells the data table syntax to ignore rows that cannot be matched between the two data tables, giving you an inner join.\n\n**8. Full joins**\n\nIt is not possible to perform a full join with the data table syntax, so you will need to rely on the merge function you learned in chapter 1. Remember to set all equal to TRUE to perform a full join!\n\n**9. Anti-joins**\n\nFinally, another type of join you can perform using the data table syntax is an anti-join. This filters the main data table on the left so that it contains only rows that have no match in the data table on the right.Anti joins are performed by adding an exclamation mark, known as the \"not\" operator, before the data table you want to filter on in the i argument.\n\n**10. Let's practice!**\n\nLater on in this chapter you will learn how to use the other functionality of the data table syntax while joining data tables. For now, its your turn to try out joins using the data table syntax.\n\n## Right join with the data.table syntax\n\n`capitals` and `population`, the two `data.table`s containing information about the geography and population of Australia are available in your workspace. Your goal is to add the state of each city to the `population` by performing a right join using the `data.table` syntax.\n\n**Steps**\n\n1. Right join `population` to `capitals` using the `data.table` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Right join population to capitals using data.table syntax\ncapitals[population, on = .(city)]\n```\n:::\n\n\n2. To compare the output, right join `population` to `capitals` using the `merge()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Right join using merge\nmerge(capitals, population, by = \"city\", all.y = TRUE)\n```\n:::\n\n\nNice work! Did you notice the difference in row ordering in the result? This is because joins using the `data.table` syntax treat the `i` argument like a subset operation, so it returns rows in the order they appear in the `data.table` given to the `i` argument, while the `merge()` function sorts rows based on the values in the key column.\n\n## Inner join with the data.table syntax\n\nIn the last exercise, you right joined `population` to `capitals`. The result contained all rows from `population` and had some `NA`s. In this exercise, you will perform an inner join instead, retaining rows only from both the tables.\n\n**Steps**\n\n1. Inner join `population` to `capitals` using the `data.table` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inner join with the data.table syntax\ncapitals[population, on = .(city), nomatch = 0]\n```\n:::\n\n\nGreat job! If you are performing many inner joins, you can change the default behaviour of `nomatch` by setting `options(datatable.nomatch = 0)` in your R session.\n\n## Anti-joins\n\nAnti-joins are useful when you want to filter rows in one table not found in the other. \nYour goal is to filter the `population` so that it does not contain the state capitals, and filter the `area` so that it only contains administrative areas, not the major Australian states.\n\n**Steps**\n\n1. Filter `population` so the result doesn't contain any rows from `capitals`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Anti-join capitals to population\npopulation[!capitals, on = .(city)]\n```\n:::\n\n\n2. Filter `area` so the result doesn't contain any rows from `capitals`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Anti-join capitals to area\narea[!capitals, on = .(state)]\n```\n:::\n\n\nNicely done! Anti-joins are a useful way of identifying rows that have no match in another `data.table`.\n\n## Setting and viewing data.table keys\n\nTheory. Coming soon ...\n\n**1. Setting and viewing data.table keys**\n\nIn this lesson, you will learn how to set and view the keys of a data table.\n\n**2. Setting `data.table` keys**\n\nIn the previous lesson you learned how to perform joins using the data table syntax. In each case, you had to use the on argument to specify how to match rows between the two data tables. However, it is possible to tell R which columns are keys for each data table in advance of a join, removing the need for the on argument. This is useful if you find yourself performing several different joins with a single data table.Setting a key will also sort a data table by that column in memory, which makes joining and filtering operations on that columns much faster for large data tables.With that in mind, its useful to know you can set multiple key columns for a single data table. You'll learn more about joins that require multiple keys in the next chapter.\n\n**3. The `setkey()` function**\n\nThe setkey() function is used for this purpose.It takes a single data table as its first argument, then any number of key column names as its remaining arguments.These can be entered as if they were variables, or can be wrapped inside quotes, either will work.If you don't provide any column names to the setkey() function, it will use all columns of the data table as its keys!\n\n**4. The `setkey()` function**\n\nWhen keys are set for two data tables, you can use the data table syntax without the on argument for performing joins.\n\n**5. Setting keys programmatically**\n\nYou can also use the setkeyv() function to set the keys of a data table by passing in a character vector of the key column names. This is useful if you want to set the keys of a data table programmatically, where your key column names are stored in another variable.\n\n**6. Getting keys**\n\nYou can check whether a data table has any key columns set by using the haskey() function, and get the key you've set by using the key() function.\n\n**7. Getting keys**\n\nIf you haven't set the key for a data table then the haskey() function will return FALSE and the key() function will return NULL.\n\n**8. Viewing all `data.tables` and their keys**\n\nThe tables() function you learned about in the very first lesson will also show you the keys you have set for any data tables in your R session.\n\n**9. Let's practice!**\n\nNow it's your turn to play with keys.\n\n## Setting keys\n\nThe `netflix` and `imdb` `data.table`s are available in your workspace. Your goal is to set the keys for both `data.table`s so that you can perform a series of joins without needing to specify the join keys each time.\n\n**Steps**\n\n1. Set `title` as the key of both `netflix` and `imdb` using `setkey()`. \n2. Inner join `imdb` to `netflix` without specifying the `on` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the keys\nsetkey(netflix, \"title\")\nsetkey(imdb, \"title\")\n\n# Inner join\nnetflix[imdb, nomatch = 0]\n```\n:::\n\n\nGood job! Using `setkey()` will also sort the rows of a `data.table` by the key columns. This makes joins and filter operations on the keys more efficient, and can be much faster for large `data.tables`.\n\n## Getting keys\n\nYou can also get and set the keys programmatically. In this exercise, only one of `netflix` and `imdb` has their key set. Your job is to find out which `data.table` has had their key set, then use that to set the key for the other `data.table`.\n\n**Steps**\n\n1. Check whether `netflix` and `imdb` have had any key set. \n2. Assign the key of the `data.table` which has a key to `the_key`. \n3. Set the key of the other `data.table` using `the_key`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check for keys\nhaskey(netflix)\nhaskey(imdb)\n\n# Find the key\nthe_key <- key(netflix)\n\n# Set the key for the other data.table\nsetkeyv(imdb, the_key)\n```\n:::\n\n\nFantastic! The `key()` function is a useful way of reducing typing errors that can happen when manually typing long keys or multiple keys over and over again. This can be used together with the `haskey()` and `setkeyv()` functions for programmatic key checking and setting.\n\n## Incorporating joins into your data.table workflow\n\nTheory. Coming soon ...\n\n\n**1. Incorporating joins into your data.table workflow**\n\nThe real power of using the data table syntax for performing joins is that it allows you to incorporate joins into your other data table workflows. This enables you to perform rapid data analysis when your data is spread across multiple data tables.\n\n**2. Chaining data.table expressions**\n\nThe most flexible way of incorporating joins into your data table workflows is by chaining data table expressions.In the first expression, you perform your join operation. Then the second data table expression allows you to work on the result with any of the other data table expression functionality you've learned in the previous course.The general form on the slide can be read as \"Join DT1 to DT2 using the column in on as the join key. Then in the result, filter by rows in i, compute on columns j grouped by values in columns by.\"\n\n**3. Join then compute**\n\nHere's an example. We have two data tables, one filled with information about the business's customers,\n\n**4. Join then compute**\n\nand a second with details of the purchase history.\n\n**5. Join then compute**\n\nTo get the average spent per sale for return customers grouped by gender, we chain two data table expressions. In the first, we join customers to purchases, then in the second, we filter to customers with more than 1 sale, calculate the average spent per sale in j, grouped by the gender column in by.\n\n**6. Computation with joins**\n\nYou can also use the j argument to compute on columns in the same data table expression as a join. This is a memory efficient way to perform calculations on the result of a join because the data table expression will create only the join result for the columns used in j in memory. This can save a lot of time and memory for large data tables!\n\n**7. Joining and column creation**\n\nColumn creation can also be performed in the same data table expression as a join. The new column will be added to the main data table on the left side of the join. In the example on the slide, after joining purchases to customers, we are adding a new column, return_customers to the customers data table, which is computed based on the sales column from the purchases data table in the result of the join.\n\n**8. Grouping by matches**\n\nThe by argument gains a special symbol, .EACHI, when used in a join expression. This lets you group computation in j by each row in the data table on the right side of the join.This can be read as \"Join DT1 to DT2, then for each row in DT2 group calculations in j by the matching rows in DT1.\"\n\n**9. Grouping by matches**\n\nIn this example, we used by = .EACHI to count the number of shipping addresses associated with each person in the customers data table.\n\n**10. Grouping by columns with joins**\n\nThe by argument also works slightly differently than normal when used in a join expression.It can only be provided columns from the main data table on the left side of the join, and you can only perform computation on columns from the main data table.\n\n**11. Grouping by columns with joins**\n\nFor example, you could left join shipping to customers to calculate the average age, grouped by gender, of customers with shipping addresses, because both the age and gender columns are in the customers data table.\n\n**12. Let's practice!**\n\nNow its time for you to join data tables while doing some computations!\n\n## Exploring the Australian population\n\nYour goal is to calculate the total percentage of people living in major cities of Australia (listed in `capitals`). For this exercise, `population` has a new column (`\"percentage\"`) containing the percentage of people living in each of its listed cities.\n\n**Steps**\n\n1. First, inner join `capitals` to `population`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read data\npopulation <- fread(\"data/australia_population/australia_cities_top20.csv\")\n\n# Inner join capitals to population\npopulation[capitals, on = .(city), nomatch = 0]\n```\n:::\n\n\n2. In the same `data.table` expression, <a href=\"https://www.rdocumentation.org/packages/base/topics/sum\">`sum()`</a> the `\"percentage\"` column to calculate the total percentage of people living in major Australian cities.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join and sum\npopulation[capitals, on = .(city), nomatch = 0,\n           j = sum(percentage)]\n```\n:::\n\n\nWell done! Using the `j` argument to compute information from the result of the join will allow you to quickly ask and answer questions about your data. Here in a single command you've learnt roughly 65% of Australians live in one of its major cities.\n\n## Finding multiple matches\n\nTwo new `data.table`s have been loaded in your workspace:  \n\n* `life_exp`: contains the life expectancy of each country in 2010 sourced from the <a href=\"https://www.gapminder.org\">Gapminder foundation</a> \n* `continents`: contains a mapping between each country and the continent(s) they are part of built from information provided by <a href=\"https://www.countries-ofthe-world.com/\">Countries-ofthe-World.com</a>. \nIn this exercise, you will find the countries that are listed in more than one continent\n\n**Steps**\n\n1. Complete the code to build a `data.table` containing the *number of matches* in `continents` for each row in `life_exp`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nlife_exp   <- fread(\"data/life_expectancy/gapminder_life_expectancy_2010.csv\")\ncontinents <- fread(\"data/life_expectancy/continents.csv\") \n\n# How many continents is each country listed in?\ncontinents[life_exp, on = .(country), .N, \n           by = .EACHI]\n```\n:::\n\n\n2. Chain a second `data.table[]` expression to the first to filter the result of the previous step to contain just countries with more than one match between `life_exp` and `continents`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What countries are listed in multiple continents?\ncontinents[life_exp, on = .(country), .N, \n           by = .EACHI][N > 1]\n```\n:::\n\n\n## Exploring world life expectancy\n\nThe two `data.table`s from the previous exercise have been loaded into your workspace:\n\n* `life_exp`: contains the life expectancy of each country in 2010 sourced from the <a href=\"https://www.gapminder.org\">Gapminder foundation</a> \n* `continents`: contains a mapping between each country and the continent(s) they are part of built from information provided by <a href=\"https://www.countries-ofthe-world.com/\">Countries-ofthe-World.com</a>. \nYour goal this time is to calculate the average life expectancy across countries within each continent.\n\n**Steps**\n\n1. Inner join `life_exp` to `continents` and calculate the <a href=\"https://www.rdocumentation.org/packages/base/topics/mean\">`mean()`</a> `\"years\"` of life expectancy grouped by the `\"continent\"` column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change names\nsetnames(life_exp, old = \"life_expectancy\", new = \"years\")\n\n# Calculate average life expectancy per continent:\navg_life_expectancy <- continents[life_exp, on = .(country), \n                                  nomatch = 0][, j = mean(years), \n                                               by = .(continent)]\navg_life_expectancy\n```\n:::\n\n\nExcellent work! Using `by = .EACHI` is a useful way of checking your join has the number of matches you expect, and finding rows that may cause problems in downstream analysis. Remember if you want to use `by=` to group computations in `j` by another column you will need to chain a second `data.table[]` expression.\n\n# 3. Diagnosing and Fixing Common Join Problems\n\nThis chapter will discuss common problems and errors encountered when performing data.table joins and show you how to troubleshoot and avoid them.\n\n## Complex keys\n\nTheory. Coming soon ...\n\n**1. Complex keys**\n\nWelcome back. In this lesson, you'll learn how to diagnose misspecified joins, and how to use more complex join keys.\n\n**2. Misspecified joins**\n\nA misspecified join is one where you don't use the correct join keys. This can lead to a variety of errors and malformed data tables.All of these are good indicators you need to go back and double-check your join keys.\n\n**3. Column type mismatch**\n\nIf you see an error message with the word \"bmerge\" and \"typeof\" it means that the join key columns you've specified have different types, so they can't be matched.You might be using the wrong columns,\n\n**4. Column type mismatch**\n\nOr the columns may have been loaded in as different types and need converting so that both have the same type.\n\n**5. Malformed full joins - no common key values**\n\nIf the columns have the same type, then the output and difficulty of diagnosing the problem will depend on the type of join, and whether the columns coincidentally have any values in common. If the columns have no values in common then a full join will lead to the two data tables being stacked, and filled with missing values.\n\n**6. Malformed right and left joins - no common key values**\n\nA right or left join will just return the rows from one of the data tables, with columns from the other filled entirely with missing values.\n\n**7. Malformed inner joins - no common key values**\n\nAnd an inner join will have zero rows.\n\n**8. Malformed joins - coincidental common key values**\n\nIf you use the wrong key, but the columns coincidentally share some common values, the problem can be much harder to pick up. So its important to check that the result of your join makes sense.\n\n**9. Avoiding misspecified joins**\n\nThe best way to avoid misspecified joins is to take the time to learn about the information each column contains so that you can critically reason about how to match rows before attempting a join.There are several factors that can make identifying join keys more difficult than the examples you've encountered in previous lessons.\n\n**10. Keys with different column names**\n\nSometimes the join keys might have different column names in each data table.In these cases, you use the by dot x and by dot y arguments in the merge() function,and in the data table join syntax you use an equals operator in the on argument, or in the character vector supplied to the on argument.\n\n**11. Multi-column keys**\n\nYou may also need multiple columns to match rows between data tables. This can be because the information that uniquely identifies rows is split across multiple columns,\n\n**12. Multi-column keys**\n\nor because there are multiple entries for each entity.\n\n**13. Specifying multiple keys with merge()**\n\nIn the merge() function, multiple key columns are supplied as a character vector to the by argument.If one or more of these keys has different column names in both data tables, you will need to supply a character vector to both the by dot x and by dot y arguments. Join key column names are matched in the order they appear in each character vector.\n\n**14. Specifying multiple keys with the data.table syntax**\n\nWhen using the data table syntax, multiple keys can be supplied separated by commas.Columns that have different names are specified using an equals sign.\n\n**15. Final Slide**\n\nNow, its your turn to practice with complex keys.\n\n## Keys with different names\n\nYou have been contracted by a local school to perform some analysis using their internal databases. Two of those datasets are available in your R session: \n\n* `students`: contains information about the students attending the school \n* `guardians`: contains information about the adult who is the primary point of contact for the school for each student. \nYour goal is to build a new `data.table` containing all the information about the guardian for each student.\n\n**Steps**\n\n1. Use the `merge()` function to full join `guardians` to `students` using the `\"name\"` column as the join key. Do the results look correct?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nstudents  <- fread(\"data/school_db/school_db_students.tsv\")\nguardians <- fread(\"data/school_db/school_db_guardians.tsv\")\n\n# Full join\nmerge(students, guardians, by = \"name\", all = TRUE)\n```\n:::\n\n\n2. Now see what happens when you left join `guardians` to `students` with the `merge()` function using `\"name\"` as the join key.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left join\nmerge(students, guardians, by = \"name\", all.x = TRUE)\n```\n:::\n\n\n3. Perform an inner join using the `data.table` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inner join\nstudents[guardians, on = .(name), nomatch = 0]\n```\n:::\n\n\n4. Explore the `data.table`s in your console to find the column in each of `students` and `guardians` that matches rows between them, then modify the code to use these column names to perform an inner join.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What are the correct join key columns?\nstudents[guardians, on = .(guardian = name), nomatch = 0]\n```\n:::\n\n\nNice work! Knowing what to expect when a join goes wrong will help you quickly catch and diagnose problems in the future. Remember, join keys can have different column names in each `data.table`.\n\n## Multi-column keys\n\nTwo new datasets are available in your R session: \n\n* `subjects`: contains the subject each student is taking each semester this year \n* `locations`: contains the room allocations for each subject\nYour goal is to build a new `data.table` with the locations of each subject for each student.\n\n**Steps**\n\n1. Right join `locations` to `subjects` using the `\"subject\"` and `\"semester\"` columns in both `data.tables` as two separate join key columns. You should get an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nsubjects  <- fread(\"data/school_db/school_db_subjects.tsv\")\nsetnames(subjects, old = \"class\", new = \"subject\")\n\nlocations <- fread(\"data/school_db/school_db_locations.tsv\")\nsetnames(locations, old = \"class\", new = \"subject\")\nlocations[, semester := as.character(semester)]\n\n# Right join\nsubjects[locations, on = .(subject, semester)]\n```\n:::\n\n\n2. Print the `str()`ucture of `subjects` and `locations`. \n3. Is the class of the `semester` column same in both? If yes, assign `TRUE` to `same_class`, else assign `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Structure \nstr(subjects)\nstr(locations)\n\n# Does semester have the same class? \nsame_class <- FALSE\n```\n:::\n\n\n4. Use the `as.integer()` function to change the class of the `\"semester\"` column in `locations`.\n5. Right join `locations` to `subjects` again, using the `data.table` syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fix the column class\nlocations[, semester := as.integer(semester)]\n\n# Right join\nsubjects[locations, on = .(subject, semester)]\n```\n:::\n\n\nGreat job! Sometimes you will need to make the column types consistent to perform a successful join.\n\n## Multi-key, single-key\n\nIn addition to `locations`, you will work with the `teachers` dataset in this exercise. It contains information about the teacher for each subject. The teacher of each subject does not change between semesters. Your goal is to build a new `data.table` containing the room allocation for each subject, using the `teachers` and `locations` `data.table`s.\n\n**Steps**\n\n1. Identify the key column(s) for joining `teachers` and `locations` and assign it as a character vector in the form `c(\"teachers_join_key\" = \"locations_join_key\")` to the `join_key` variable. \n2. Using the `data.table` syntax, right join `locations` to `teachers` using the `join_key` variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nteachers <- fread(\"data/school_db/school_db_teachers.tsv\")\nsetnames(teachers, old = \"subject\", new = \"topic\")\n\n# Identify and set the keys\njoin_key <- c(\"topic\" = \"subject\")\n\n# Right join\nteachers[locations, on = join_key]\n```\n:::\n\n\nFantastic job! Even though the previous exercise required the `\\\\\"subject\\\\\"` and `\\\\\"semester\\\\\"` columns from `locations` as the join key, here only the `\\\\\"subject\\\\\"` column was required to match its rows to `teachers`. Remember the join keys depend on the two `data.tables` in the join!\n\n## Tricky columns\n\nTheory. Coming soon ...\n\n**1. Problem columns**\n\nIn the last lesson you learned how to work with complex join keys, and how to diagnose and fix problems arising from misspecified joins. In this lesson you will learn how to diagnose common problems you may encounter with data table columns when joining.\n\n**2. Common column names**\n\nWhen joining two data tables you may sometimes find that they share column names which are not the join keys.An example is shown on the slide. Both data tables have \"name\", \"gender\", and \"age\" columns, and you can see that to join these two data tables, you would need to match the name and parent columns for the join keys.Common column names like this pose two challenges: they make it harder to correctly identify the join keys and they make it harder to interpret the result of the join.\n\n**3. Common column names**\n\nSo what happens to these columns in a join?With the data table syntax, columns from the data table passed to the i argument will have \"i dot\" added to the start of their column names.\n\n**4. Common column names with merge()**\n\nWhen using the merge() function, these common column names will instead have \"dot x\" or \"dot y\" added to the end, denoting which of the input data tables they came from.\n\n**5. Adding context with your own suffixes**\n\nThe suffixes argument to the merge() function allows you to use different suffixes than just \"dot x\" and \"dot y\". This is a useful way of providing helpful context to the result of the join.\n\n**6. Renaming columns**\n\nAnother solution is to rename these columns, either before or after the join. This can be done with the setnames() function.You can either give it a single character vector to give new names to all the columns in a data table, or two character vectors to rename a subset of columns.\n\n**7. Joining with `data.frames`**\n\nAnother problem you may run into is mixing of data tables and data frames in your R session. The merge() function also works for data frames, and can also be used to join a data frame with a data table.Sometimes, data frames store the unique identifying information about their rows in the rownames. You will need to extract these if you want to use them as the join keys or want to keep that information in the result of the join.The simplest way to do this is to convert it to a data table using the as dot data dot table function along with the keep dot rownames argument to convert this into a column with the column name of your choice.\n\n**8. Let's practice!**\n\nIt's time to join data tables with tricky columns.\n\n## Column name suffixes\n\nThe three `data.table`s containing information about the geography and population of Australia have been loaded into your R session: `capitals`, `area`, and `population`. Both `area` and `population` now have a column named `\"percentage\"`. The `\"percentage\"` column in `area` contains the percentage of total land mass each state occupies. The `\"percentage\"` column in `population` contains the percentage of the total population living in each `city`.\n\n**Steps**\n\n1. Use the `merge()` function to inner join `population` to `capitals` and save the result to `capital_pop`. \n2. Use the `merge()` function to left join `area` to `capital_pop` and view the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inner join\ncapital_pop <- merge(capitals, population, by = \"city\")\n\n# Left join\nmerge(capital_pop, area, by = \"state\", all.x = TRUE)\n```\n:::\n\n\n3. This time, left join `area` to `capital_pop` changing the suffixes of the two `\"percentage\"` columns to `\".pop\"` and `\".area\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inner join from step 1\ncapital_pop <- merge(capitals, population, by = \"city\")\n\n# Left join with suffixes\nmerge(capital_pop, area, by = \"state\", all.x = TRUE, suffixes = c(\".pop\", \".area\"))\n```\n:::\n\n\nGood job! Changing the suffixes is good practice because it makes it easier to know what each column represents when you come back to the joined `data.table` at a later time.\n\n## Joining a data.frame\n\nThe `netflix` and `imdb` datasets have been loaded into your R session. Your goal is to add IMBD ratings to all series in the `netflix` dataset, but this time `netflix` has been loaded in as a `data.frame` instead of a `data.table`.\n\n**Steps**\n\n1. Convert `netflix` to a `data.table` using the `as.data.table()` function so that its rownames become a column named `\"series\"`. \n2. Right join the new `data.table` you've just created,`netflix_dt`, to `imdb` using the `data.table` join syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load data\nnetflix <- netflix |> tibble::column_to_rownames(\"title\")\n\n# Convert netflix to a data.table\nnetflix_dt <- as.data.table(netflix, keep.rownames = \"series\")\n\n# Right join\nimdb[netflix_dt, on = .(title = series)]\n```\n:::\n\n\nNice one! You can use the `merge()` function to join a `data.frame`, but if you want to use the row names you will need to convert it into a column first.\n\n## Duplicate matches\n\nTheory. Coming soon ...\n\n**1. Duplicate matches**\n\nThe last set of join problems you will commonly encounter arise from duplicate matches in the join key values.\n\n**2. Join key duplicates**\n\nSometimes you will want to join two data tables based on columns with duplicate entries. In the example shown on the slide, we are joining two data tables containing data we've measured on the microbial content of soil at two different farm sites. We've used multiple methods to try to quantify whether a bacterial genus is present, and if so, by how much? We then might want to join these two data tables to get a list of bacteria that could be found at both sites using any method, so we join the two data tables using the genus column as the join key.This leads to multiplicative matches. Each row in the site2_ecology data table will match two rows in the site1 ecology_data table, leading to 12 matches all up, six for each bacteria shown.\n\n**3. Error from multiplicative matches**\n\nIf you try to run this code, you will get a long error as shown here warning you that the result will have more rows than both data tables combined.This error is shown to protect you from making unexpectedly large data tables by accident because multiplicative matches are a common problem in misspecified joins, which you learnt about in the first lesson of this chapter.\n\n**4. Allowing multiplicative matches**\n\nWhen you do a join like this intentionally, you can set allow dot cartesian equals TRUE to let the join proceed.This argument is found in both the data table syntax and the merge() function.\n\n**5. Allowing multiplicative matches**\n\nWith data table syntax, you will get the following data table as a result\n\n**6. Missing values**\n\nIf you have missing values in your join key column, then these can also lead to multiplicative matches, because they will match all other missing values in the join.\n\n**7. Filtering missing values**\n\nTo remove these matches, which are likely meaningless, you can filter out rows with missing values in the join key columns using the is dot na function along with not operator.\n\n**8. Keeping only the first match**\n\nIn some cases, you may want to join two data tables where each value in the join key column has multiple matches, but you only want to keep the first match. For example, we might have multiple collections at site 1, but when matching to the site2_ecology data table we only want to match the most recent collection.To do this you can set mult equals first to keep only the first matching row in the main data table on the left side of the join.\n\n**9. Keeping only the last match**\n\nConversely, you can set mult equals last to keep only the last matching row.\n\n**10. Identifying and removing duplicates**\n\nYou can also use the duplicated() and unique() functions to identify and remove duplicates.\n\n**11. The duplicated() function**\n\nThe duplicated() function from the the data table package will tell you which rows are duplicates. It returns a vector of TRUE and FALSE values, where each entry corresponds to a row in the data table. A value of TRUE means that row has the same values as one of the previous rows in the data table.An additional argument, \"by\", can be used to restrict those checks to only a subset of columns, for example looking for duplicates in just the join key column.\n\n**12. The unique() function**\n\nThe unique() function takes the same arguments, but instead returns the data table without the rows that were determined to be duplicates.\n\n**13. Changing the search order**\n\nYou can also change the direction the duplicated() and unique() functions search for and remove duplicates by specifying fromLast equals TRUE.\n\n**14. Let's practice!**\n\nNow it's your turn to practice handling duplicate matches.\n\n## Joining with missing values\n\nTwo new `data.tables` have been loaded into your R session: `heart` and `cardio`. Each one contains a set of <a href=\"https://en.wikipedia.org/wiki/DNA_microarray\">microarray probes</a> you have found to be associated with heart disease in two separate studies*. Each probe measures the <a href=\"https://en.wikipedia.org/wiki/Gene_expression\">expression levels</a> of a gene. Each gene can be measured by one or more probes, and some probes do not have any known gene annotation in the <a href=\"https://www.ncbi.nlm.nih.gov/refseq/\">human genome reference sequence</a>. The two studies have used different microarray platforms that use different probes to measure each gene. Your goal is to find which genes had reproducible associations with heart disease in both studies.\n\n* Note: associations are randomly generated, not representative of any true biological finding or real dataset.\n\n**Steps**\n\n1. Using the `merge()` function, inner join `cardio` to `heart` with the appropriate argument to override any errors that you encounter. \n2. Remove the probes from both `data.tables` with no gene annotation (i.e., remove rows with missing values in the `gene` column). \n3. Repeat the inner join with the new `data.tables` to get a `data.table` of reproducible associations between genes and heart disease.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nheart  <- fread(\"data/heart_data/illumina_chd_genes.csv\",  na.strings  = \"\")\ncardio <- fread(\"data/heart_data/affymetrix_chd_genes.csv\", na.strings = \"\") \n\n# Try an inner join\nmerge(heart, cardio, by = \"gene\", allow.cartesian = TRUE)\n\n# Filter missing values\nheart_2  <- heart[!is.na(gene)]\ncardio_2 <- cardio[!is.na(gene)]\n\n# Inner join the filtered data.tables\nmerge(heart_2, cardio_2, by = \"gene\")\n```\n:::\n\n\nNice work! If the only columns that have the same name across two data.tables are the join keys, you can drop the `by` argument from `merge()` - it will find and use these columns as the join keys automatically!\n\n## Filtering duplicates\n\nThe `heart_2` and `cardio_2` data tables you filtered for missing values are available in your workspace. Your goal is to select one representative probe per gene in each `data.table` so that each gene has only a single entry in the join result. You want to select the probe with the weakest association to get a conservative estimate of reproducibility. The `\"change\"` column contains the fold change in expression levels for each probe between the healthy subjects and those with heart disease*. The `\"pvalue\"` column contains the p-value for the association strength. Rows are ordered by decreasing order of association strength (by increasing P-value).\n\n* Note: associations are randomly generated, not representative of any true biological finding or real dataset.\n\n**Steps**\n\n1. Use the `unique()` function to remove duplicate entries in the `\"gene\"` column in both `heart_2` and `cardio_2`. Keep only the *last* row for each gene.  \n2. Inner join `cardio_3` to `heart_3`  using the `merge()` function. Append `\".heart\"` and `\".cardio\"` as suffixes to the `\"change\"` and `\"pvalue\"` columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Keep only the last probe for each gene\nheart_3  <- unique(heart_2,  by = \"gene\", fromLast = TRUE)\ncardio_3 <- unique(cardio_2, by = \"gene\", fromLast = TRUE)\n\n# Inner join\nreproducible <- merge(heart_3, cardio_3, by = \"gene\", suffixes = c(\".heart\", \".cardio\"))\nreproducible\n```\n:::\n\n\nGreat job! You could also have filtered duplicates using the `duplicated()` function: `heart <- heart[!duplicated(heart, by=\\\\\"gene\\\\\", fromLast = TRUE)]`.\n\n## Joining and filtering duplicates\n\nAnother `data.table` has been loaded into your R session, `framingham`, containing a set of 35 genes and their associations with heart disease from an open access study <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3684247/\">by Joehanes R. *et al.* published in 2013</a>. Your goal is to compare the results of this study to the results from each of your studies. The `cardio_2` and `heart_2` `data.table`s filtered for missing values, but still containing multiple probes for each gene, have been loaded into your R session. The `data.table` of reproducible associations you created in the last exercise, `reproducible`, has also been loaded into your R session.\n\n**Steps**\n\n1. Using the `data.table` syntax, right join `framingham` to `heart_2`, taking the first probe for each gene in `heart_2`. \n2. Anti-join `framingham` to `reproducible` to see whether you found any genes that have not previously been seen to have an association with heart disease.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nframingham <- fread(\"data/heart_data/framingham_chd_genes.csv\", na.strings = \"\")\n\n# Right join taking the first match\nheart_2[framingham, on = .(gene), mult = \"first\"]\n\n# Anti-join\nreproducible[!framingham, on = .(gene)]\n```\n:::\n\n\nExcellent work! You could also select the last probe per gene by setting `mult = \\\\\"last\\\\\"`.\n\n# 4. Concatenating and Reshaping data.tables\n\nIn the last chapter of this course you'll learn how to concatenate observations from multiple tables together, how to identify observations present in one table but not another, and how to reshape tables between long and wide formats.\n\n## Concatenating two or more data.tables\n\nTheory. Coming soon ...\n\n**1. Concatenating data.tables**\n\nWelcome back! In this lesson you will learn how to work with datasets whose rows are spread across multiple data tables by concatenating them into a single data table.\n\n**2. Same columns, different data.tables**\n\nSometimes datasets you want to work with are split across multiple data tables, usually because they've been read in from multiple files. You may want to concatenate these rows into a single data table.\n\n**3. Concatenation functions**\n\nThere are two functions you can use to concatenate data tables. The rbind() function, and the rbindlist() function.\n\n**4. The rbind() function**\n\nThe rbind() function takes any number of data tables as inputs, and concatenates their rows into a single data table.\n\n**5. Adding an identifier column**\n\nEach of these variables can be given names using the equals operator, and an extra argument \"idcol\" will tell rbind() to use these names to create an extra column in the result that indicates each row's data table of origin.\n\n**6. Adding an identifier column**\n\nIf you use the idcol argument without naming the variables the data tables will be numbered instead.\n\n**7. Adding an identifier column**\n\nAnd if you don't supply a column name to idcol and just set it to true, the column will be named \"dot id\".\n\n**8. Handling missing columns**\n\nWhen the input data tables each have a different number of columns, you will need to set the fill argument to TRUE. This will fill the missing columns with NAs in the result.\n\n**9. Handling missing columns**\n\nIf you don't do this, the code will result in an error that looks like this, telling you that the column numbers are inconsistent.\n\n**10. The rbindlist() function**\n\nYou can use the rbindlist() function if your data tables are stored as elements of a single list.An example of where you might find this useful is when you have several files you want to import into a single data table. Rather than reading each file into separate variables, you could load these into a list by lapply()-ing the fread() function over a vector of file names, and then use the rbindlist() function to concatenate their rows into a single data table.\n\n**11. Adding an identifier column**\n\nWhen using the rbindlist() function, the idcol argument uses the names of the list elements when creating the additional identifier column.\n\n**12. Handling different column orders**\n\nFinally, the use dot names argument in both rbind() and rbindlist() functions matches columns by their names when concatenating data tables.\n\n**13. `data.tables` with different column names**\n\nSetting use dot names to false allows you to concatenate data tables whose columns have different names.\n\n**14. Pitfalls of `use.names = FALSE`**\n\nBut, you need to be careful because it will mean columns are always concatenated in the order they are found.\n\n**15. Differing defaults**\n\nThe use dot names argument has different defaults in the rbind() and rbindlist() functions.By default it is true in the rbind() function, but in the rbindlist() function its default is FALSE, and changes to TRUE if you set fill equal to TRUE.\n\n**16. Let's practice!**\n\nNow it's your turn to see how these functions work in practice.\n\n## Concatenating data.table variables\n\nThree `data.table`s containing Ebola case numbers <a href=\"http://apps.who.int/gho/data/node.ebola-sitrep\">reported in Guinea to the World Health Organisation</a> for three weeks at the height of the 2014 Ebola outbreak have been loaded into your R session: `ebola_W50`, `ebola_W51`, and `ebola_W52`. Your goal is to create a single `data.table` containing the case numbers in each region of Guinea across all three weeks.\n\n**Steps**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nebola_W50 <- fread(\"data/ebola_cases/ebola_2014_W50.csv\")\nebola_W51 <- fread(\"data/ebola_cases/ebola_2014_W51.csv\")\nebola_W52 <- fread(\"data/ebola_cases/ebola_2014_W52.csv\")\n```\n:::\n\n\n1. Concatenate `ebola_W50` and `ebola_W51` (in that order) using the <a href=\"https://www.rdocumentation.org/packages/data.table/topics/rbindlist\">`rbind()`</a> function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenate case numbers from weeks 50 and 51\nrbind(ebola_W50, ebola_W51)\n```\n:::\n\n\n2. Modify your call to `rbind()` to also concatenate `ebola_W52`. You should get an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenate case numbers from all three weeks\nrbind(ebola_W50, ebola_W51, ebola_W52)\n```\n:::\n\n\n3. Fix your call to `rbind()` so that the three `data.tables` are successfully concatenated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modify the code\nrbind(ebola_W50, ebola_W51, ebola_W52, fill = TRUE)\n```\n:::\n\n\nGood job! Datasets with regular updates may come in separate files. The `rbind()` function enables you to reliably and efficiently concatenate these into a single `data.table` once they have been loaded into your R session with `fread()`.\n\n## Concatenating a list of data.tables\n\nA list of `data.table`s has been loaded into your R session: `gdp`. Its elements contain a `data.table` for each continent, each `data.table` containing the gross domestic product (gdp) in the year 2000 for the countries in each continent (data sourced from the <a href=\"https://www.gapminder.org\">Gapminder foundation</a>). Your goal is to build a new `data.table` containing the observations from all `data.table`s in the `gdp` `list`\n\n**Steps**\n\n1. Concatenate all `data.table`s in the `gdp` `list`, saving the result to `gdp_all_1`.\n\n*Column 2 ['country'] of item 3 appears in position 1 in item 2. Set use.names=TRUE to match by column name, or use.names=FALSE to ignore column names. use.names='check' (default from v1.12.2) emits this message and proceeds as if use.names=FALSE for  backwards compatibility. See news item 5 in v1.12.2 for options to control this message.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(stringr)\nlibrary(purrr)\n\n# Load data\ngdp <- list.files(\"data/gdp/\", full.names = T, pattern = \".*_2000.csv\") %>%\n            .[!(. |> str_detect(\"middle_east\"))] %>%\n            map(fread) |> \n            set_names(c(\"africa\",\"asia\",\"europe\",\"north_america\",\"oceania\",\"south_america\"))\n\n# Concatenate its data.tables\ngdp_all_1 <- rbindlist(gdp, use.names = FALSE)\n```\n:::\n\n\n2. Modify the code so that a new column, `\"continent\"` is created in the result stored in `gdp_all_2`, which contains the continent(s) each country is located in.\n3. Inspect the result in your console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenate its data.tables\ngdp_all_2 <- rbindlist(gdp, idcol = \"continent\", use.names = FALSE)\n```\n:::\n\n\n4. In your console run the code to check the result of your previous call to `rbindlist()`. Can you see any problems?\n5. Modify your call to `rbindlist()` to fix any problems you have found, saving the result in `gdp_all_3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run this code to inspect gdp_all_2\ngdp_all_2 <- rbindlist(gdp, idcol = \"continent\")\nstr(gdp_all_2)\ngdp_all_2[95:105]\n\n# Fix the problem\ngdp_all_3 <- rbindlist(gdp, idcol = \"continent\", use.names = TRUE)\ngdp_all_3\n```\n:::\n\n\nFantastic! Remember to check the data tables created by `rbind()` or `rbindlist()` for correctness: these functions do not throw an error if the wrong columns are concatenated!\n\n## Set operations\n\nTheory. Coming soon ...\n\n**1. Set operations**\n\nIn this lesson, you will learn how to use set operations to compare and combine the rows of two data tables that have the same columns.\n\n**2. Set operation functions**\n\nThis group of three functions will enable you to identify rows that are duplicated across two data tables, those unique to either data table, and concatenate two data tables keeping only the unique rows in both.\n\n**3. Set operations: `fintersect()`**\n\nThe fintersect() function takes two data tables that have the same columns as its inputs and returns a new data table containing the set of rows that can be found in both data tables. You can see in the example running fintersect() on these two data tables will return just the highlighted rows.\n\n**4. `fintersect()` and duplicate rows**\n\nBy default only one copy of each row is returned, even if there are multiple copies in each data table.\n\n**5. `fintersect()` and duplicate rows**\n\nYou can set all equals TRUE to keep all pairs of matching duplicates. In the example, two copies of the yellow lion row can be found in both dt1 and dt2, so there are two copies in the result. The extra copy in dt1 is ignored, because it doesn't have another copy it can match to in dt2.\n\n**6. Set operations: `fsetdiff()`**\n\nThe fsetdiff() function takes two data tables that have the same columns as its inputs, and returns a new data table containing the set of rows that are only found in the data table supplied as its first argument.In the example here, you can see fsetdiff() returns the rows from dt1 highlighted in blue. These are the rows that are unique to dt1.\n\n**7. `fsetdiff()` and duplicates**\n\nWhen there are duplicate rows, only one copy of each row is returned in the result by default.\n\n**8. `fsetdiff()` and duplicates**\n\nWhen you set all equals TRUE, any copies unique to the first data table are also returned.Here, not only do we keep both copies of the \"antelope\" row highlighted in purple, but one of the \"lion\" rows highlighted in yellow is also included in the result. This is because there are three copies of this row in dt1, and only two in dt2, so the extra copy in dt1 is returned because it does not have a matching pair in dt2.\n\n**9. Set operations: `funion()`**\n\nThe funion() function takes two data tables that have the same columns as its inputs and returns a new data table containing the set of all unique rows found in either data table.\n\n**10. `funion()` and duplicates**\n\nBy default, duplicate rows are ignored. The result will only contain one copy of each unique row.\n\n**11. `funion()` and duplicates**\n\nSetting all equals TRUE will keep all copies of each row. The result is equivalent to using the rbind function to concatenate the two data tables.\n\n**12. Removing duplicates when combining many `data.tables`**\n\nThe funion() function is a useful way to concatenate two data tables while removing duplicate rows.When working with more than two data tables, you can concatenate them all using the rbind() or rbindlist() functions, and then use the duplicated() and unique() functions to identify or remove the duplicate rows.\n\n**13. Let's practice!**\n\nNow, its your turn to practice set operations.\n\n## Identifying observations shared by multiple tables\n\nThe list of data tables, `gdp`, is available in your workspace. Your goal is to find the countries that are located in more than one continent, *i.e.*, rows that are present in more than one `data.table` in `gdp`.\n\n**Steps**\n\n1. Use the `fintersect()` function to build a new `data.table` containing countries located in both Europe and Asia.\n2. Concatenate all `data.table`s in `gdp` and assign it to `gdp_all`.   \n3. Use the `duplicated()` function to filter `gdp_all` to rows that are duplicates to find all countries located in more than one continent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load proper data\n# Load data\ngdp <- list.files(\"data/gdp/\", full.names = T, pattern = \".*_2000.csv\") %>%\n            .[!(. |> str_detect(\"middle_east\"))] %>%\n            str_replace(\"gdp_europe_2000\", \"gdp_europe_2000_original\") %>%\n            purrr::map(fread) |> \n            set_names(c(\"africa\",\"asia\",\"europe\",\"north_america\",\"oceania\",\"south_america\"))\n\n# Obtain countries in both Asia and Europe\nfintersect(gdp$asia, gdp$europe)\n\n# Concatenate all data tables\ngdp_all <- rbindlist(gdp)\n\n# Find all countries that span multiple continents\ngdp_all[duplicated(gdp_all)]\n```\n:::\n\n\nNicely done! Did you know base R provides set operation functions that work on vectors? For example the `intersect()` function will find the common elements of two vectors.\n\n## Removing duplicates while combining tables\n\nThe same list of data tables as the last exercise, `gdp`, is available in your workspace. Your goal this time is to build a `data.table` in which each country appears only once, even if it is located in more than one continent.\n\n**Steps**\n\n1. Use the `funion()` function to build a new `data.table` containing all countries in either Europe or Asia, with each country appearing only once in the result. \n2. Concatenate all `data.table`s in `gdp` and assign it to `gdp_all`.   \n3. Use the `unique()` function to remove duplicate rows from`gdp_all` so that each country occurs only once in the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all countries in either Asia or Europe\nfunion(gdp$asia, gdp$europe)\n\n# Concatenate all data tables\ngdp_all <- rbindlist(gdp)\n\n# Print all unique countries\nunique(gdp_all)\n```\n:::\n\n\nGreat job! Functions in R can be chained together in the same statement, for example `gdp_all <- unique(rbindlist(gdp))`.\n\n## Identifying observations unique to a table\n\nAn additional `data.table` has been loaded into your R session, `middle_east`, along with the `gdp` list of data tables from the previous exercise. The `middle_east` data table contains the set of countries in the <a href=\"https://en.wikipedia.org/wiki/Middle_East\">Middle East</a>, a geopolitical region which spans parts of Europe, Africa, and Asia. All countries in the `middle_east` data table appear in one or more data tables in the `gdp` list. Your goal is to print data tables containing all countries in Africa, Europe, and Asia, that are not found in the `middle_east`.\n\n**Steps**\n\n1. Print a new `data.table` containing rows from `gdp$africa` that are not present in `middle_east`. \n2. Print a new `data.table` containing rows from `gdp$asia` that are not present in `middle_east`. \n3. Print a new `data.table` containing rows from `gdp$europe` that are not present in `middle_east`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nmiddle_east <- fread(\"data/gdp/gdp_middle_east_2000.csv\")\n\n# Which countries are in Africa but not considered part of the middle east?\nfsetdiff(gdp$africa, middle_east)\n\n# Which countries are in Asia but not considered part of the middle east?\nfsetdiff(gdp$asia, middle_east)\n\n# Which countries are in Europe but not considered part of the middle east?\nfsetdiff(gdp$europe, middle_east)\n```\n:::\n\n\nNice work! You can do this in one line of code: `lapply(gdp, fsetdiff, middle_east)`.\n\n## Melting data.tables\n\nTheory. Coming soon ...\n\n**1. Melting data.tables**\n\nIn this lesson, you will learn how to melt data tables from wide to long formats.\n\n**2. Melting a wide data.table**\n\nA wide format data table is one where a single variable is spread across multiple columns corresponding to some grouping, such as in the example data table on the left.This type of layout is common when working with excel spreadsheets because it is a human friendly way of organising data with regular groupings. However, when working with datasets in R, you will often want to reshape this data into a long format, shown on the right. In the long format these values occupy a single column, with another column indicating group membership. This format allows you to take full advantage of the functionality in the data table syntax like grouping of calculations.\n\n**3. The `melt()` function**\n\nYou can use the melt() function to reshape a wide data table to a long data table.There are a few different ways you can use this function.First, you can provide a vector of column names to the measure dot vars argument. The melt() function will take these columns and stack them on top of each other to create two new columns: \"variable\" and \"value\". The \"value\" column will contain the values of these stacked columns while the \"variable\" column labels each row with the column name from the original wide data table.\n\n**4. The `melt()` function**\n\nYou can give these new columns any name you like using the variable dot name and value dot name arguments.\n\n**5. The `melt()` function**\n\nYou can also use the id dot vars argument instead of the measure dot vars argument to tell the melt() function which columns you want to keep aside as row identifiers in the new data table.The melt() function will then stack all other columns into the new \"value\" column.\n\n**6. The `melt()` function**\n\nYou can use both the id dot vars and measure dot vars arguments at the same time. If you use both arguments, any columns you don't provide to either argument will be dropped in the result.\n\n**7. Let's practice!**\n\nNow it's your turn to see how melt() works in practice.\n\n## Melting a wide table\n\nA data table named `gdp_per_capita` containing the gross domestic product (GDP) per capita for countries in Oceania every five years from 1990 to 2010 sourced from the <a href=\"https://www.gapminder.org\">Gapminder foundation</a> is available in your workspace. Your goal is to reshape this data table to the long format so that there is a single column containing all GDP per capita values for each country and year.\n\n**Steps**\n\n1. Print `gdp_per_capita` to learn about its contents. \n2. Use the `melt()` function to create a long format `data.table` stacking the values for each country's column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load & prepare data\ngdp_per_capita <- fread(\"data/gdp/gdp_per_capita_oceania.csv\", header = T)\ngdp_per_capita <- data.table::transpose(gdp_per_capita, keep.names = \"year\", make.names = \"country\")\n\n# Print gdp_per_capita\ngdp_per_capita\n\n# Reshape gdp_per_capita to the long format\nmelt(gdp_per_capita, id.vars = \"year\")\n```\n:::\n\n\n3. Within your call to `melt()`, name the new `\"variable\"` column as `\"country\"` and the new `\"value\"` column as `\"gdp_pc\"`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rename the new columns\nmelt(gdp_per_capita, id.vars = \"year\", \n     variable.name = \"country\", value.name = \"gdp_pc\")\n```\n:::\n\n\nExcellent! By default the `\\\\\"variable\\\\\"` column in the result will be a `factor`. You can change this by setting `variable.factor = FALSE`.\n\n## More melts\n\nA data table containing confirmed Ebola case numbers from Guinea in weeks 50 and 51 of the outbreak has been loaded into your R session. Your goal is to melt `ebola_wide` into a long format data table containing a single column for the case numbers variable.\n\n**Steps**\n\n1. Use the `measure.vars` argument to stack the columns `\"Week_50\"` and `\"Week_51\"`. The new column containing its values should be called `\"cases\"`, and the new column of variable labels should be called `\"period\"`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(dplyr)\n\n# Prepare data\nebola_wide <- \n\nebola_W50 |> \n  select(-c(period_code, Probable)) |> \n  rename(\"Week_50\" = \"Confirmed\") |> \n  mutate(Week_51 = NA) |> \n  \n  bind_rows(\n\nebola_W51 |> \n  select(-c(period_code, Probable)) |> \n  rename(\"Week_51\" = \"Confirmed\") |> \n  mutate(Week_50 = NA)\n\n  ) |> \n  arrange(Location)\n\n# Print ebola_wide\nebola_wide\n\n# Stack Week_50 and Week_51\nmelt(ebola_wide, measure.vars = c(\"Week_50\", \"Week_51\"), \n     variable.name = \"period\", value.name = \"cases\")\n```\n:::\n\n\n2. Modify the call to `melt()` to also ask to keep only the `\"Location\"` column as row identifiers, dropping the `\"period_start\"` and `\"period_end\"` columns from the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modify the code\nmelt(ebola_wide, measure.vars = c(\"Week_50\", \"Week_51\"), \n     variable.name = \"period\", value.name = \"cases\", \n     id.vars = \"Location\")\n```\n:::\n\n\nGreat job! Using `id.vars` together with `measure.vars` keeps only those columns in the result.\n\n## Casting data.tables\n\nTheory. Coming soon ...\n\n## Casting a long table\n\n`gdp_oceania` contains the population and GDP for every country in Oceania for every five years from 1990 to 2010 and is available in your workspace. Your goal is to create wide format `data.table`s containing the population and total GDP for each country with each year having its own column.\n\n**Steps**\n\n1. Use <a href=\"https://www.rdocumentation.org/packages/data.table/topics/dcast.data.table\">`dcast()`</a> to build a wide `data.table` containing the population of each country, with each country as a row and each year as a column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\ngdp_oceania <- fread(\"data/gdp/gdp_and_pop_oceania.csv\")\n\n# Split the population column by year\ndcast(gdp_oceania, formula = country ~ year, value.var = \"population\")\n```\n:::\n\n\n2. Create another wide format `data.table` containing the GDP of each country with each year as a row and each country as a column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the gdp column by country\ndcast(gdp_oceania, formula = year ~ country, value.var = \"gdp\")\n```\n:::\n\n\nNice work! One way to remember the dcast formula is that the column you give to the left hand side will always be the left most column of row identifiers in the result.\n\n## Casting multiple columns\n\nThe data table from the previous exercise, `gdp_oceania`, is available in your workspace. Your goal is to create a wide format data table, splitting both the `\"gdp\"` and `\"population\"` columns by the `\"year\"` column.\n\n**Steps**\n\n1. Convert `gdp_oceania` to wide format with each country as a row, and splitting both the `\"gdp\"` and `\"population\"` columns into columns for each `\"year\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modify data\ngdp_oceania[,continent := \"Oceania\"]\n\n# Split the gdp and population columns by year\ndcast(gdp_oceania, formula = country ~ year, value.var = c(\"gdp\", \"population\"))\n```\n:::\n\n\n2. Convert `wide` to a matrix using the `\"country\"` column as the matrix rownames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reshape from wide to long format\nwide <- dcast(gdp_oceania, formula = country ~ year, value.var = c(\"gdp\", \"population\"))\n\n# convert to a matrix\nas.matrix(wide, rownames = \"country\")\n```\n:::\n\n\n3. Modify the call to `dcast()` so that the `\"continent\"` column is also kept aside as row identifiers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modify your previous code\ndcast(gdp_oceania, formula = country + continent ~ year, value.var = c(\"gdp\", \"population\"))\n```\n:::\n\n\nNicely done! If you don't want to keep any columns as row identifiers in the result, you can use the special symbol `.` in the formula.\n\n## Splitting by multiple groups\n\n`gdp_by_industry_oceania` contains the GDP generated by the agriculture and tourism industries in both 1995 and 2010. Your goal is to create a wide format `data.table` containing columns of GDP for each year and industry.\n\n**Steps**\n\n1. Print `gdp_by_industry_oceania`. \n2. Convert `gdp_by_industry_oceania` to a wide format with each country as a row, splitting the `\"gdp\"` column so that the result has columns containing the gdp for each industry and each year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\ngdp_by_industry_oceania <- fread(\"data/gdp/gdp_by_industry_oceania.tsv\")\n\n# Split gdp by industry and year\ndcast(gdp_by_industry_oceania, country ~ industry + year, value.var = \"gdp\")\n```\n:::\n\n\nAwesome job! For advanced use cases take a look at the `fill` argument which controls how `dcast` handles group combinations that do not occur, and the `fun.aggregate` argument which controls how dcast handles cases where there are multiple values for different group combinations.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "ebd6c77502f40c42225205c05b67ee9b",
  "result": {
    "markdown": "---\ntitle: \"Topic Modeling in R\"\nauthor: \"Joschka Schwarz\"\ntoc-depth: 2\n---\n\n\n\n\n\n## INFO FOR RSTAN / RSTANARM\n\nhttps://github.com/stan-dev/rstan/wiki/RStan-Getting-Started\nSys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers\ninstall.packages(\"rstan\", repos = \"https://cloud.r-project.org/\", dependencies = TRUE)\n\nMac - Configuring C++ Toolchain\n\n---\n\nThis course introduces students to the areas involved in topic modeling: preparation of corpus, fitting of topic models using Latent Dirichlet Allocation algorithm (in package topicmodels), and visualizing the results using ggplot2 and wordclouds.\n\n# 1. Quick introduction to the workflow\n\nThis chapter introduces the workflow used in topic modeling: preparation of a document-term matrix, model fitting, and visualization of results with ggplot2.\n\n## Why learn topic modeling\n\nTheory. Coming soon ...\n\n**1. Why learn topic modeling**\n\nWelcome to the Topic Modeling with R. In this video you will learn about topic models: what inputs they take, what output they produce, and how they can be useful to your work.\n\n**2. What are topic models**\n\nIn common language, we understand a topic as a very short (one or two words) summary of a conversation or a text.For example, if someone says that the topic of a conversation was weather, we expect that the words used were rain, storm, snow, winds, ice.The idea is, then, that a topic is a label for a collection of words that often occur together.Topic modeling is a process of finding collections of words that best represent a set of unknown topics.\n\n**3. Rise of popularity**\n\nTopic models give a way to quickly make a judgment about contents of a collection of documents. The joke is that topic models are a tool for those who do not like to read.Because topics are quantified, topic modeling opened the door for new applications, like tracking the prevalence of a topic through time, tracking similarity of documents, or fitting regression models to estimate causal effects.Topic models are used as a foundation for more technical applications like text segmentation, or classification.\n\n**4. Topic models - descriptive side**\n\nThere are many algorithms that produce topic models. Our course will focus on Latent Dirichlet Allocation.For its input, LDA takes a document-term matrix. A document-term matrix is a bag-of-words representation of a collection of documents: it records frequencies of word occurrence, but ignores word order.LDA returns two matrices: one contains prevalence of topics in the documents, the other - probability of words belonging to topics.Let's take a look at a quick example.\n\n**5. Illustration**\n\nWe have a tiny collection of documents. (The technical term for such collection is __corpus__.)Each document consists of a single sentence.These sentences are related to two topics: restaurants and loans.\n\n**6. Illustration**\n\nThe corpus is converted into a document-term matrix. We use only a subset of words: bank, loans, pay, new, opened, restaurant.Notice that the words \"loans\" and \"pay\" occur in document 5 that has both topics present in it.\n\n**7. Illustration**\n\nFunction LDA() will fit a topic model to a collection of documents represented by document-term matrix.LDA is a supervised clustering algorithm: we need to specify the number of clusters we seek from the start.The result is two tables. The first table shows probabilities of words belonging to topics. For instance, probability of word 'opened' belonging to topic 2 is 36%.The second table shows probabilities of documents belonging to topics. Document 3 has 20% probability of belonging to topic 1, and 80% - of belonging to topic 2.\n\n**8. Topic modeling - the other parts**\n\nThere are quite a few technical decisions involved in a project that uses topic modeling.First, matrices as output are fine only for small sets of data. For larger projects, we will have to use charts.Second, there are choices related to which words to keep for analysis. The earlier example used only 7 words out of the vocabulary of 34. Some approaches emphasize the use of nouns, others - the use of verbs.Then, a document can be constructed in multiple ways. Some scholars work with a single novel, like Moby Dick, and use 500 or 1000 words as a single document. In analysis of Twitter data, a single tweet is often treated as a document.Finally, there are several control parameters that strongly affect the results. To be fully competent with topic modeling, you must have an idea what these parameters control.\n\n**9. Let's practice!**\n\nNow let's start doing things.\n\n## Topics as word contexts\n\nWe have a topic defined by the following terms: **site, settlement, evidence, inhabit, region, period, earliest, ancient, reconstruct**.\n\n> *Question*\n> ---\n> Which concept is reflected in this topic? Pick one.<br>\n> <br>\n> ✅ Archeology<br>\n> ⬜ Physics<br>\n> ⬜ Chemistry<br>\n\nThe answer is *archeology*. You probably relied on the associations in your mind; these associations are just non-quantified word co-occurrences.\n\n## Topic prevalence\n\nMatrix `document_topics` contains results of a topic model fitted on the same corpus, but this time the document-term matrix included all words. \n\n> *Question*\n> ---\n> Print out the matrix and answer the question, which topic, 1 or 2, does the document 5 is more likely to belong?<br>\n> <br>\n> ⬜ Topic 1 has a higher proportion than topic 2.<br>\n> ✅ Topic 2 has a higher proportion than topic 1.<br>\n> ⬜ Both topics have the same proportion.<br>\n\n## Probabilities of words belonging to topics\n\nYour session has a matrix `word_topics` which contains the probabilities of words belonging to the topics. The matrix has two rows (for two topics) and 34 columns (for each term). The columns are named, with terms serving as column name.\n\n**Steps**\n\n1. Display the column names of the `word_topics` matrix.\n2. Display the probability of word *street* belonging to topic 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_topics <- readRDS(\"data/word_topics.rds\")\n\n# Display the column names\ncolnames(word_topics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"agreed\"     \"bad\"        \"bank\"       \"due\"        \"fines\"     \n#>  [6] \"loans\"      \"pay\"        \"the\"        \"to\"         \"are\"       \n#> [11] \"face\"       \"if\"         \"late\"       \"off\"        \"will\"      \n#> [16] \"you\"        \"your\"       \"a\"          \"downtown\"   \"in\"        \n#> [21] \"new\"        \"opened\"     \"restaurant\" \"is\"         \"just\"      \n#> [26] \"on\"         \"street\"     \"that\"       \"there\"      \"warwick\"   \n#> [31] \"for\"        \"how\"        \"need\"       \"want\"\n```\n:::\n\n```{.r .cell-code}\n# Display the probability\nword_topics[1, \"street\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.03741497\n```\n:::\n:::\n\n\n## Counting words\n\nTheory. Coming soon ...\n\n**1. Counting words**\n\nIn order to fit a topic model, we must prepare a document-term matrix that will contain counts of word occurrences in documents. In this lesson we will cover how to do it using packages tidytext and dplyr.\n\n**2. Splitting text**\n\nIn text processing, the process of splitting a text is referred to as tokenization. In our case, we will be splitting text into words, but in general tokens can be a sequence of characters, or a sequence of words.Package tidytext has a function unnest_tokens() that performs tokenization.The function takes a column from a table, splits it into words and, by default, it will drop the column with text. It will also convert the output to lower case.\n\n**3. Example of using unnest_tokens**\n\nWe have a data frame named \"book\". It has two columns: chapter and text.We call unnest_tokens(), instructing that the column with tokens should be named \"word\" and that column \"text\" should be dropped.We get back a table in which each word is in its own row.\n\n**4. Counting words**\n\nWe will use function count() from package dplyr to obtain frequencies of words within chapters.This function, essentially, groups the rows by chapter and word, and returns the number of rows in each group. This correspond to the number of times a specific word occurs in a specific chapter.The result is a table with one row per each combination of chapter and word. For example, the word \"is\" occurs twice in chapter 1.\n\n**5. Getting the top words 1**\n\nOnce we have the counts, we often will want to examine the top words, for example, the top 10.This can be done by grouping the rows by chapter, sorting the rows within each group in order of descending counts, and then realizing that the rank of a word is equal to its row number.Most frequent word will be in row 1, second most frequent - in row 2, and so on. dplyr has a function row_number() that returns the row number. All we need to do is filter on the condition that row number is less than a threshold value.\n\n**6. Getting the top words 2**\n\nThis is an example of getting top two words from each chapter. We use arrange() to sort the rows within each group, and wrap the count values n into a call to desc() to sort in descending order.Then we filter, inside each group, to keep only rows whose number is less than 3.Note that for chapter 2, the second word we got is \"comes\". Its count is 1 and we know there were other words with that count. What we got, then, is also determined by the alphabetical order.\n\n**7. Casting counts into a document-term matrix**\n\nYou may be familiar with function cast() that is used to transform a table from one format into another.We need to transform the table with counts into a document-term matrix, dtm for short. In dtm, rows correspond to documents, and columns to words, terms. In our case, each sentence will be a document.Package tidytext has function cast_dtm() that transforms a table in tidy format into a document-term matrix.It accepts a table with counts, and needs to know which column corresponds to a document ID, which - to the word, and which - to the value of the count.\n\n**8. Example of using cast_dtm()**\n\nHere is an example.You should recognize most of this script. Everything until cast_dtm() is the code that creates a tidy table with word counts.We add the call to cast_dtm() and get back a document-term matrix. It is stored in a special format, as a so-called sparse matrix.We can examine its contents by converting it to a regular matrix using function as.matrix().\n\n**9. Let's practice!**\n\nIt's time to practice!\n\n## Removal of punctuation marks\n\nSometimes you have to work with hyphenated words like 'ill-fated'. The documentation for `unnest_tokens` says that the tokenizer function will remove all punctuation marks. Your job is to verify this.\n\n> *Question*\n> ---\n> You are given a data frame `d` with a single column `text` and two rows. Apply the `unnest_tokens` to table `d` and pick the answer that best describes its behavior.<br>\n> <br>\n> ⬜ `unnest_tokens` removes all punctuation marks.<br>\n> ⬜ `unnest_tokens` keeps the punctuation marks.<br>\n> ✅ It depends on where the punctuation mark is.<br>\n\nYes. If a punctuation mark is followed by a space, it is removed.\n\n## Word frequencies\n\nYou are given a table `chapters` with two columns: `chapter` and `text` and two rows. They contain chapters 1 and 2 from the book, *The Byzantine Empire*, by Charles Oman, published in 1902. Find the frequency of the word 'after' for each chapter.\n\n**Steps**\n\n1. Specify the input column for the `unnest_tokens()`.\n2. Use `count` with arguments `chapter` and `word` to obtain word frequencies.\n3. Use `filter` with a condition testing equality of values in column `word` to \"after\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare data\nlibrary(\"gutenbergr\")\nlibrary(\"stringr\")\nlibrary(\"dplyr\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> \n#> Attache Paket: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Die folgenden Objekte sind maskiert von 'package:stats':\n#> \n#>     filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Die folgenden Objekte sind maskiert von 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"tidyr\")\n\n# tbe_book <- gutenberg_download(37756)\ntbe_book_lines <- gutenberg_works(title |> str_detect(\"The Byzantine Empire\")) %>%\n  \n  # Add title\n  gutenberg_download(meta_fields = \"title\") |> \n  # Remove unnecessary whitespaces\n  mutate(text = text |> str_trim()) |> \n  # Remove empty lines and \"Illustrations\"\n  filter(!(text %in% c(\"\", \"[Illustration]\"))) |> \n  # Add indicator for chapter titles\n  mutate(is_chapter_title = text |> str_detect(\"^(I|V|X)+\\\\. \\\\b[A-Z]+\\\\b\")) |> \n  \n  # Add chapter number\n  mutate(chapter = cumsum(is_chapter_title)) |> \n  mutate(chapter = ifelse(cumany(text == \"Finis.\"),0,chapter)) |> # Set Chapter == 0 After Finis\n  \n  # Add chapter titles\n  mutate(chapter_title = ifelse(is_chapter_title, text, NA_character_)) |> \n  fill(chapter_title) |> # impute\n  filter(!is_chapter_title, chapter > 0) |> \n  select(-is_chapter_title)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Determining mirror for Project Gutenberg from http://www.gutenberg.org/robot/harvest\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Using mirror http://aleph.gutenberg.org\n```\n:::\n\n```{.r .cell-code}\ntbe_book_chapters <- tbe_book_lines |> \n\n              # Collapse lines\n              group_by(gutenberg_id, title, chapter, chapter_title) |> \n              summarise(text = text |> str_c(collapse= \" \"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> `summarise()` has grouped output by 'gutenberg_id', 'title', 'chapter'. You can\n#> override using the `.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nchapters <- tbe_book_chapters |> filter(chapter %in% c(1:2))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(tidytext)\n\n# Specify the input column\nword_freq <- chapters %>% \n  unnest_tokens(output=word, \n                input=text, \n                token=\"words\", \n                format=\"text\") %>% \n  # Obtain word frequencies\n  count(chapter, word) \n\n# Test equality\nword_freq %>% filter(word == \"after\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gutenberg_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"title\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"chapter\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"word\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"n\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"37756\",\"2\":\"The Byzantine Empire\\\\r\\\\nThird Edition\",\"3\":\"1\",\"4\":\"after\",\"5\":\"11\"},{\"1\":\"37756\",\"2\":\"The Byzantine Empire\\\\r\\\\nThird Edition\",\"3\":\"2\",\"4\":\"after\",\"5\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Our first LDA model\n\nIn order to fit a topic model to a corpus of text, we need to provide a document-term matrix (dtm) as an input to function `LDA`. Now that you've seen how to do that, you can fit your very first topic model.\n\nYou are given access to a table `corpus` that you have seen in lesson 1. Column `text` contains the sentences, column `id` - document id.\n\nFill in the blanks to run the code that will display proportion of topics in each document.\n\n**Steps**\n\n1. In the call to `unnest_tokens` specify that the input column is `text` and the output column is `word`.\n2. In the call to `cast_dtm`, specify that the token is in column `word`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tm package is necessary\n# Load packages\nlibrary(topicmodels)\n\n# Read data\ncorpus1 <- readRDS(\"data/corpus1.rds\")\n\ndtm1 <- corpus1 %>% \n    # Specify the input column\n    unnest_tokens(input=text, output=word, drop=TRUE) %>% \n    count(id, word) %>% \n    # Specify the token\n    tidytext::cast_dtm(document=id, term=word, value=n)\n\nmod1_1 = LDA(x=dtm1, k=2, method=\"Gibbs\", control=list(alpha=1, delta=0.1, seed=10005))\n\nposterior(mod1_1)$topics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>             1         2\n#> d_1 0.2307692 0.7692308\n#> d_2 0.1666667 0.8333333\n#> d_3 0.8750000 0.1250000\n#> d_4 0.8461538 0.1538462\n#> d_5 0.2777778 0.7222222\n```\n:::\n:::\n\n\nWell done. The call to `posterior(mod)$topics` returns the probabilities of topics.\n\n## Displaying frequencies with ggplot\n\nTheory. Coming soon ...\n\n\n**1. Displaying results with ggplot**\n\nIn this chapter we will review how to display results of topic modeling using ggplot.\n\n**2. Frequencies and probabilities**\n\nAs we work with LDA topic modeling, we will be interested in displaying two kinds of data.First, there are word counts in documents - we obtain them before we fit a topic model.Then, there are probabilities of topics in documents and words in topics. These are obtained after fitting a topic model.Fortunately, ggplot can do it all.ggplot requires the data to be in tidy format. Fortunately, word counts are already in tidy format, and LDA results can be converted into a tidy format using function tidy() from package tidytext.\n\n**3. From LDA model to tidy table**\n\nWhen we fit a topic model, we call function LDA() and it returns an object. Among many things, this object contains two matrices: beta and gamma. beta contains logarithms of probabilities of words belonging to topics, and gamma - probabilities of documents belonging to topics.Notice how in the output, the dimension of beta is 2 by 34: two topics and 34 words. The dimension of gamma is 5 by 2: five documents and two topics.\n\n**4. Using function tidy**\n\nFunction tidy() takes an LDA model object and returns a tidy table with a specified matrix.\n\n**5. Stacked columns chart**\n\nThe geometry column layer in ggplot will produce a column chart.By default, the columns will be stacked.In the call to ggplot(), the aesthetics specifies that values for axis x will come from column \"document\", for axis y - from column \"gamma\".\n\n**6. Dodged columns**\n\nDodged, or side-by-side, columns are better for telling which column is taller.  To make a chart with dodged columns, we need to add position_dodge() argument to the call of geom_col()The example shows probabilities of words. The data comes from matrix \"beta\" contained in LDA model. The word is contained in column \"term\".\n\n**7. Rotated labels**\n\nWhen the number of labels on x axis gets large, the labels will overlap and obscure each other.The overlap can be reduced if we rotate the labels, for instance, by 90 degrees.This can be achieved using the specification for axis.text.x element in the call to theme().Notice that in the script in the slide, we first convert topic into a factor variable, and then use it to guide the color fill.\n\n**8. Let's practice!**\n\nLet's do a few examples.\n\n## Simple LDA model\n\nIn this exercise you will work through all steps involved in making a topic model analysis. For simplicity, we will use the tiny corpus of five sentences/documents that you have seen earlier.\n\n**Steps**\n\n1. With the model object in hand, you can extract matrices `beta` and `gamma` for word and document probabilities, respectively. Retrieve the probabilities of word `will` belonging to topics 1 and 2. The column containing words will be named `term`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Retrieve the probabilities of word `will` belonging to topics 1 and 2\ntidy(mod1_1, matrix=\"beta\") %>%\n  filter(term == \"will\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"topic\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"term\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"beta\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"will\",\"3\":\"0.003649635\"},{\"1\":\"2\",\"2\":\"will\",\"3\":\"0.078680203\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n2. Make a stacked column chart showing the probabilities of documents belonging to topics. \n\n    * `tidy` will return a table with columns `document` for document id, `topic` for topic number, and `gamma` for the value of probability. \n    * Retrieve matrix `gamma`, use `document` for `x`, `gamma` for `y` in the aesthetics, and `topic` as `fill` in the `geom_col` verb.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(ggplot2)\n\n# Make a stacked column chart showing the probabilities of documents belonging to topics\ntidy(mod1_1, matrix=\"gamma\") %>% \n  mutate(topic = as.factor(topic)) %>% \n  ggplot(aes(x=document, y=gamma)) + \n  geom_col(aes(fill=topic))\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nGreat job. You have covered all steps, from a text dataframe to a chart with results.\n\n# 2. Wordclouds, stopwords, and control arguments\n\nThis chapter explains how to use join functions to remove or keep words in the document-term matrix, how to make wordcloud charts, and how to use some of the many control arguments.\n\n## Random nature of LDA algorithm\n\nTheory. Coming soon ...\n\n**1. Linking words to topics**\n\nIn this lesson you will get a glimpse into the way LDA algorithm searches for a topic model.\n\n**2. LDA and random numbers**\n\nWhen we call LDA() function we specify the document-term matrix \"dtm\", number of clusters \"k\", and some control and initialization parameters. Let's talk about what they do.LDA uses random search through the space of parameters to find the best match between probabilities and data.This match is measured by log-likelihood, which is a measure of how plausible the model's parameters are given the data. We want the model with the highest log-likelihood.\n\n**3. Random search**\n\nIt uses \"Gibbs sampling\" - a randomized search algorithm, which is a type of Monte Carlo Markov Chain algorithms. This is why we specify \"method\" equals \"Gibbs\" in the input.The algorithm searches among possible combinations of probabilities. For example, 0.5 and 0.5 vs 0.8 and 0.2, for two topics in documents.These combinations are influenced by the values of control arguments \"alpha\" and \"delta\".\n\n**4. Random search - controlling the iterations**\n\nEven though we say \"randomized\", in reality the numbers in R are pseudo-random. They are generated by a special function that takes a seed value and produces new values by iterating over the seed.The seed can be specified to ensure reproducibility of results between runs of LDA().The number of steps in the search process is controlled by the \"iter\" argument. Increasing the number of iterations increases the chances of finding the best model, but it also makes the model fitting take longer.By default, the algorithm will perform 2000 iterations.\n\n**5. Effect of seed value**\n\nHere is an illustration of the effect of \"seed\" value.We have the same corpus of five sentencesWe run the same code, but the seed value is different.Topic proportions are roughly similar, but the numbering of topics has flipped.Documents that had high prevalence of topic 1 now have high prevalence of topic 2.Without special precautions, topic numbering is arbitrary.\n\n**6. Handling intermediate results**\n\nPackage \"topicmodels\" uses a piece of C code that was originally written by the group of David Blei, the scholar who pioneered the use of LDA for topic modeling. Because of this, some control arguments perform in non-intuitive way.One argument like that is \"thin\". It specifies the frequency with which an LDA model is saved.Specifying \"thin\" equals 1 makes the code return the topic model after every iteration, and return the one with the best log-likelihood. This is a trade-off: the code will run slower, but we will get to keep the best value.\n\n**7. Most probable words in topics**\n\nHow can we find out the most probable words?Word probabilities are returned in matrix \"beta\".One approach is to use function tidy() that you have seen before. tidy() would retrieve the matrix in tidy format and then we could use the power of dplyrFor example, to get the top five wordswe'd call tidy, then group by topic, arrange by probabilities \"beta\", filter by row number.\n\n**8. Using tidy() to get most probable words**\n\nHere is what the script could look like.Filtering condition \"row_number() &lt;= 3\" is used to keep only the top 3 words.In the end, we get a tidy table that contains topics, terms, and probabilities.\n\n**9. Using function terms()**\n\nPackage `topicmodels` has function terms() that returns the most probable words. It can return the top \"k\" words, or we can provide a probability threshold.For example, here we request top 5 words for every topic.The result is a table with a column per topicBecause this function does not return values of probabilities, the top k result can be confusing. The function will simply go down the list of words, even though their probabilities may be very small.The \"threshold\" option is useful when we are interested in knowing words that have high probability of belonging to a topic.Here we request words whose probability in a topic is above 0.05. Notice how topic 2 has fewer words whose probability is above the threshold than topic 1.\n\n**10. Let's practice!**\n\nYou've seen the demos, and now it's time to practice.\n\n## Probabilities of words in topics\n\nYou will now practice retrieving information about probabilities of words in topics.\n\n**Steps**\n\n1. You are given a document-term matrix `dtm` constructed from the same corpus of five sentences, but using only seven words. Using your knowledge that a document-term matrix has the terms as its column names, display the terms of the `dtm`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read data\n# dtm <- readRDS(\"data/dtm1.rds\")\n\ncols <- c(\"bank\",\"fines\",\"loans\",\"pay\",\"new\",\"opened\",\"restaurant\")\n\ndtm1_mat <- as.matrix(dtm1)[,cols]\n\n# Display column names\ncolnames(dtm1_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"bank\"       \"fines\"      \"loans\"      \"pay\"        \"new\"       \n#> [6] \"opened\"     \"restaurant\"\n```\n:::\n:::\n\n\n2. Fit an LDA topic model for two topics. Argument `x` should be the document-term matrix, number of clusters `k` should be 2, `method` should be `Gibbs`. Keep the control argument unchanged.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit an LDA model for 2 topics using Gibbs sampling\nmod1_2 <- LDA(x=dtm1_mat, k=2, method=\"Gibbs\", \n           control=list(alpha=1, seed=10005, thin=1))\n```\n:::\n\n\n3. Use `dplyr` to display the probability of term \"opened\" in topic 2. You will be retrieving matrix `beta` from LDA object `mod`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert matrix beta into tidy format and filter on topic number and term\ntidy(mod1_2, matrix=\"beta\") %>%\n  filter(topic==2, term==\"opened\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"topic\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"term\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"beta\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2\",\"2\":\"opened\",\"3\":\"0.01030928\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nVery good.\n\n## Effect of argument alpha\n\nIn this exercise you will compare how the quality of model's fit to data varies with argument `alpha`\n\n**Steps**\n\n1. You have a document-term matrix `dtm` containing word frequencies for the corpus of 5 sentences with the vocabulary of 7(???) words.\n2. Fit LDA topic model for 2 topics. Keep the arguments `seed` and `alpha` unchanged.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit LDA topic model using Gibbs sampling for 2 topics\nmod1_3 <- LDA(x=dtm1, k=2, method=\"Gibbs\",\n           control=list(alpha=1, seed=10005, thin=1))\n```\n:::\n\n\n3. Display the probabilities of topics in documents. Use function `tidy` to retrieve matrix `gamma` from the LDA model object. \n4. `pivot_wider` / `spread` will cast it into a table with two columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display the probabilities of topics in documents side by side\n# tidy(mod1, \"gamma\") %>% spread(topic, gamma)\ntidy(mod1_3, \"gamma\") %>% pivot_wider(names_from = topic, values_from = gamma)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"document\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"1\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"2\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"d_1\",\"2\":\"0.1538462\",\"3\":\"0.84615385\"},{\"1\":\"d_2\",\"2\":\"0.2777778\",\"3\":\"0.72222222\"},{\"1\":\"d_3\",\"2\":\"0.8750000\",\"3\":\"0.12500000\"},{\"1\":\"d_4\",\"2\":\"0.9230769\",\"3\":\"0.07692308\"},{\"1\":\"d_5\",\"2\":\"0.5000000\",\"3\":\"0.50000000\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n5. Rerun the code, but this time set `alpha` equal to 25. Display the probabilities of topics in documents.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit LDA topic model with a different alpha\nmod1_4 <- LDA(x=dtm1, k=2, method=\"Gibbs\",\n           control=list(alpha=25, seed=10005, thin=1))\n\n# Display the probabilities of topics in documents side by side\ntidy(mod1_4, \"gamma\") %>% pivot_wider(names_from = topic, values_from = gamma)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"document\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"1\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"2\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"d_1\",\"2\":\"0.4754098\",\"3\":\"0.5245902\"},{\"1\":\"d_2\",\"2\":\"0.5303030\",\"3\":\"0.4696970\"},{\"1\":\"d_3\",\"2\":\"0.4821429\",\"3\":\"0.5178571\"},{\"1\":\"d_4\",\"2\":\"0.5081967\",\"3\":\"0.4918033\"},{\"1\":\"d_5\",\"2\":\"0.5000000\",\"3\":\"0.5000000\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n> *Question*\n> ---\n> Knowing that our corpus contained documents related to two topics, which model, `mod1` or `mod2` returned more realistic results?<br>\n> <br>\n> ✅ Model `mod1` returned more realistic values of topic proportions.<br>\n> ⬜ Model `mod2` returned more realistic values of topic proportions.<br>\n> ⬜ Topic proportions in `mod1` and `mod2` are similar.<br>\n\nYes. We knew that the documents were dominated by one topic, and `mod1` captured that. This is an illustration of why argument `alpha` is important.\n\n## Manipulating the vocabulary\n\nTheory. Coming soon ...\n\n\n**1. Manipulating the vocabulary**\n\nIn this lesson you will learn how to control what words will be included into the document-term matrix, dtm for short.\n\n**2. Possible operations**\n\nAs we transform a corpus of documents into a document-term matrix, we will find ourselves in two types of situations.In one, we know what words we don't want to see in the dtm.In the other, we know which words we do want to include.These situations are similar, and the choice depends on which set of words is smaller and is easier to specify: the stop words or the needed words.\n\n**3. Removing stopwords**\n\nStopwords are words that are considered as noise in text and are removed. A good example of this are indefinite and definite articles __a__ and __the__.Stopwords often obscure word associations in topics: they are the most frequent words and show up at the top of the frequency tables, pushing the important words out of sight.The previous lesson had an example showing five most probable words in two topics. Words \"the\", \"you\", and \"to\" were in the output and they did not contribute to understanding what the topics were about.\n\n**4. Using anti_join()**\n\nAn inner join of two tables merges the tables using a key: a column that is present in both tables and which indicates which rows are a match. Only the rows with matching key values make it into the output.Opposite to that, anti_join() drops the rows that have matching key values. This is perfect for situations when we remove some rows based on a criterion.Here you are seeing an example where we have a very simple table with word counts. Words \"we\" and \"went\" are stopwords. As inner_join(), anti_join() would use columns with the same name as the key. When the names do not match, we need to specify the association using the \"by\" argument.After we perform anti_join(), the stop words are removed.\n\n**5. Keeping the needed words in**\n\nThere are also situations when it's easier to specify which words we'd like to keep, rather than having a list of words we'd like to drop.In such situations we can use inner_join()Some scholars who use topic models to analyze novels prefer to keep only nouns.As you will see in the big exercise in this chapter, we will focus our attention on verbs in a history text.Application of inner_join() should be familiar to anybody who worked with dplyr. We only need to specify the correspondence between columns that are used as keys. This is done with argument \"by\".In the example, we chose to keep two words: \"fishing\" and \"slept\" - and remove everything else.\n\n**6. Let's practice!**\n\nNow that you've seen the examples, let's practice.\n\n## Removing stopwords\n\nIt takes only one new line of code to remove the stopwords. Fill in the function names to make the code work.\n\n**Steps**\n\n1. The `anti_join` must come in after `unnest_tokens` but before `count`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the document-term matrix with stop words removed\ndtm2 <- corpus1 %>%\n  unnest_tokens(output=word, input=text) %>%\n  anti_join(stop_words) %>% \n  count(id, word) %>%\n  cast_dtm(document=id, term=word, value=n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"word\"\n```\n:::\n\n```{.r .cell-code}\n# Display the matrix\nas.matrix(dtm2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>      Terms\n#> Docs  agreed bad bank due fines loans pay late downtown restaurant street\n#>   d_1      1   1    1   1     1     1   1    0        0          0      0\n#>   d_2      0   0    1   0     1     1   1    1        0          0      0\n#>   d_3      0   0    0   0     0     0   0    0        1          1      0\n#>   d_4      0   0    0   0     0     0   0    0        0          1      1\n#>   d_5      0   0    0   0     0     1   1    0        0          1      0\n#>      Terms\n#> Docs  warwick\n#>   d_1       0\n#>   d_2       0\n#>   d_3       0\n#>   d_4       1\n#>   d_5       0\n```\n:::\n:::\n\n\nVery good. dplyr makes things so easy, right?\n\n## Keeping the needed words\n\nYou are given the table with documents `corpus` and the table `dictionary` with one column - `word`, - containing the words we want to keep in the document-term matrix. Use `inner_join` to create a document-term matrix with the needed words.\n\n**Steps**\n\n1. Perform inner join on the table `dictionary`. The column names match, so you do not need to use the `by` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign dictionary (from above)\ndictionary <- tibble(word = cols)\n\n# Perform inner_join with the dictionary table\ndtm3 <- corpus1 %>%\n  unnest_tokens(output=word, input=text) %>%\n  inner_join(dictionary) %>% \n  count(id, word) %>%\n  cast_dtm(document=id, term=word, value=n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"word\"\n```\n:::\n\n```{.r .cell-code}\n# Display the contents of dtm\nas.matrix(dtm3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>      Terms\n#> Docs  bank fines loans pay new opened restaurant\n#>   d_1    1     1     1   1   0      0          0\n#>   d_2    1     1     1   1   0      0          0\n#>   d_3    0     0     0   0   1      1          1\n#>   d_4    0     0     0   0   1      1          1\n#>   d_5    0     0     1   1   0      1          1\n```\n:::\n:::\n\n\nWell done. An interesting detail: notice how the dtm contains two square blocks, suggesting two topics.\n\n## Word clouds\n\nTheory. Coming soon ...\n\n**1. Word clouds**\n\nIn this lesson you will examine wordclouds. They are less precise than barplots, but offer a quick impressionistic look at the topics.\n\n**2. Word clouds**\n\nEarlier we used ggplot to make stacked bar charts showing probabilities of words in topics. Bar plots are nice, but when the number of words increases, the plots become hard to read.Instead, we can use wordcloud charts that are less precise but give a good impressionistic feeling for word frequencies and importance.Function wordcloud() requires only a vector of words and a vector of word frequencies.There is no need to sort words by frequency in order to keep only a few - wordcloud() will do that on its own.We will use package \"wordcloud\" to draw the charts\n\n**3. Top 20 words**\n\nHere is an example of making a wordcloud that will show the top 20 words.We start by counting the frequencies of words in the whole corpusThen we make a call to function wordcloud().The number of words is controlled by the argument \"max.words\". We set it to 20.It is also possible to specify the range of frequencies, minimum and maximum, to be displayed. The default minimum frequency is 3 and we need to override this value.We get a very concise code.\n\n**4. Top 20 words**\n\nHere is the plot. Words with higher frequencies are displayed in larger font. We are using the default settings for the minimum and maximum font sizes.\n\n**5. Adding color and rotations**\n\nBlack and white wordclouds are okay, but we can do more.To make the chart visually pleasing, we can provide a vector of colors. wordcloud() will cycle through it. There is no specific rule on how the colors will be applied.We can also specify the percentage of words that should be rotated. The default is 0.1 (ten percent).All it takes is to add two more arguments to a call to wordcloud(). I chose \"DarkOrange\", \"CornflowerBlue\" and \"DarkRed\" as the colors.\n\n**6. Word cloud with color**\n\nAnd here is the output.\n\n**7. Wordclouds with results of LDA**\n\nWith a little adjustment, we can use wordclouds to display results of LDA(). The challenge here is that wordcloud() expects integer numbers as frequencies.LDA(), however, returns probabilities, which are floating point numbers less than 1.Because wordcloud() rescales the word size, the solution is to multiply the probabilities by some large number and then truncate the fractional parts.Here we fit a topic model with 2 topics.Now, we extract the matrix with word probabilities using function tidy() and then use mutate() to create a new column \"n\": we multiply values of beta by ten thousand and discard the fractional part. Finally, we use filter() to keep only rows with data on word probabilities in topic 1.After this, we are back on familiar ground and can call wordcloud().\n\n**8. Top 20 words of topic 1**\n\nHere is the result: top twenty words of the first topic, with size proportionate to probability of word in topic.\n\n**9. Let's practice!**\n\nLet's practice our new skills.\n\n## Wordcloud of term frequency\n\nYou are given table `corpus` containing the \"toy\" corpus with five sentences/documents. You will practice modifying the word cloud to make it more interesting.\n\n**Steps**\n\n1. Using table `corpus`, generate the table with counts of words in the whole corpus. Save the result to variable `word_frequencies`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate the counts of words in the corpus\nword_frequencies <- corpus1 %>% \n  unnest_tokens(input=text, output=word) %>%\n  count(word)\n```\n:::\n\n\n2. Create a wordcloud showing top 10 words, with the threshold of minimal word frequency set to 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(wordcloud)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Lade nötiges Paket: RColorBrewer\n```\n:::\n\n```{.r .cell-code}\n# Create a wordcloud\nwordcloud(words=word_frequencies$word, \n          freq=word_frequencies$n,\n          min.freq=1,\n          max.words=10)\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n3. Let's add colors to the wordcloud. Modify the code by setting the argument `colors` equal to a vector with two values: `DarkOrange` and `Blue`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a wordcloud\nwordcloud(words=word_frequencies$word, \n          freq=word_frequencies$n,\n          min.freq=1,\n          max.words=10,\n          colors=c(\"DarkOrange\", \"Blue\"))\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n4. By default, words are drawn in random order and color assignment is also random. This can be modified by specifying two arguments: `random.order` and `random.color`.\n5. Add these arguments to the call of `wordcloud` and set both of them to `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a wordcloud\nwordcloud(words=word_frequencies$word, \n          freq=word_frequencies$n,\n          min.freq=1,\n          max.words=10,\n          colors=c(\"DarkOrange\", \"Blue\"),\n          random.order=FALSE,\n          random.color=FALSE)\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nGreat! If you wanted to take it further, you can use package `rcolorBrewer` to obtain nice looking color palettes to pass as an argument in `wordcloud`\n\n## History of the Byzantine Empire\n\nTheory. Coming soon ...\n\n## LDA model fitting - first iteration\n\nThis exercise covers the steps from making a document-term matrix to fitting a topic model and examining the terms in topics.\n\nYou are given a table `history` with two columns: `chapter` for chapter number, and `text` for chapter text.\n\n**Steps**\n\n1. Create a document-term matrix containing counts of words in chapters. Use `anti_join` to exclude stopwords. Save the result into variable `dtm`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign history\n# load(\"data/history_2.RData\")\n# history <- byzantium_clean\nhistory <- tbe_book_chapters\n\n# Construct a document-term matrix\ndtm4 <- history %>% \n\t  unnest_tokens(input=text, output=word) %>% \n    anti_join(stop_words) %>% \n    count(chapter, word) %>% \n    cast_dtm(document=chapter, term=word, value=n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"word\"\n```\n:::\n:::\n\n\n2. Using the document-term matrix you just built, fit an LDA topic model for four topics. (We will cover how to find the best number of topics in chapter 4.) Use Gibbs method. Do not modify the control list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Insert the missing arguments\nmod4 <- LDA(x=dtm4, k=4, method=\"Gibbs\", \n           control=list(alpha=1, seed=10005))\n```\n:::\n\n\n3. Display the top 15 words of each topic using function `terms`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display top 15 words of each topic\nterms(mod4, k=15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>       Topic 1          Topic 2          Topic 3       Topic 4      \n#>  [1,] \"roman\"          \"empire\"         \"empire\"      \"greek\"      \n#>  [2,] \"war\"            \"constantinople\" \"emperor\"     \"city\"       \n#>  [3,] \"army\"           \"alexius\"        \"east\"        \"letter\"     \n#>  [4,] \"italy\"          \"emperor\"        \"throne\"      \"constantine\"\n#>  [5,] \"king\"           \"asia\"           \"reign\"       \"world\"      \n#>  [6,] \"empire\"         \"john\"           \"leo\"         \"byzantium\"  \n#>  [7,] \"justinian\"      \"brother\"        \"byzantine\"   \"century\"    \n#>  [8,] \"goths\"          \"son\"            \"constantine\" \"church\"     \n#>  [9,] \"heraclius\"      \"land\"           \"death\"       \"palace\"     \n#> [10,] \"danube\"         \"turks\"          \"army\"        \"rome\"       \n#> [11,] \"capital\"        \"byzantine\"      \"died\"        \"single\"     \n#> [12,] \"day\"            \"city\"           \"michael\"     \"empire\"     \n#> [13,] \"constantinople\" \"war\"            \"age\"         \"history\"    \n#> [14,] \"west\"           \"thrace\"         \"son\"         \"military\"   \n#> [15,] \"belisarius\"     \"arms\"           \"time\"        \"roman\"\n```\n:::\n:::\n\n\nWell done. The words were converted into lowercase, but we can pick out some names and action verbs.\n\n## Capturing the actions - dtm with verbs\n\nIn this exercise you will construct the dtm that will consist entirely of verbs, and then re-run the LDA algorithm.\n\nYou are given the dataframe `verbs` containing present and past tense forms of English verbs.\n\n**Steps**\n\n1. Modify the old code so that instead of removing stopwords it will return a dtm that contains only the past tense verbs. You will need to join on columns `word` and `past`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nverbs <- readRDS(\"data/verbs.rds\")\n\n# Display the structure of the verbs dataframe\nstr(verbs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> tibble [7,522 × 2] (S3: tbl_df/tbl/data.frame)\n#>  $ present: chr [1:7522] \"abandon\" \"abase\" \"abash\" \"abate\" ...\n#>  $ past   : chr [1:7522] \"abandoned\" \"abased\" \"abashed\" \"abated\" ...\n```\n:::\n\n```{.r .cell-code}\n# Construct a document-term matrix\ndtm5 <- history %>% \n    unnest_tokens(input=text, output=word) %>% \n    inner_join(verbs, by=c(\"word\"=\"past\")) %>% \n    count(chapter, word) %>% \n    cast_dtm(document=chapter, term=word, value=n)\n```\n:::\n\n\n2. Fit the Gibbs-sampling LDA topic model with four topics. Do not modify the `control` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit LDA for four topics\nmod5 <- LDA(x=dtm5, k=4, method=\"Gibbs\",\n          control=list(alpha=1, seed=10005))\n```\n:::\n\n\n3. Use function `terms` to display top 25 words from each topic\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display top 25 words from each topic\nterms(mod5, k=25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>       Topic 1     Topic 2        Topic 3       Topic 4     \n#>  [1,] \"was\"       \"began\"        \"kept\"        \"came\"      \n#>  [2,] \"had\"       \"cut\"          \"raised\"      \"fell\"      \n#>  [3,] \"made\"      \"dwelt\"        \"stood\"       \"sent\"      \n#>  [4,] \"took\"      \"covered\"      \"placed\"      \"appeared\"  \n#>  [5,] \"found\"     \"knew\"         \"marked\"      \"laid\"      \n#>  [6,] \"did\"       \"continued\"    \"built\"       \"reigned\"   \n#>  [7,] \"died\"      \"did\"          \"devoted\"     \"marched\"   \n#>  [8,] \"left\"      \"displayed\"    \"turned\"      \"said\"      \n#>  [9,] \"destined\"  \"proved\"       \"headed\"      \"received\"  \n#> [10,] \"won\"       \"chose\"        \"survived\"    \"refused\"   \n#> [11,] \"lost\"      \"granted\"      \"celebrated\"  \"fled\"      \n#> [12,] \"led\"       \"burst\"        \"gave\"        \"slew\"      \n#> [13,] \"brought\"   \"strove\"       \"provoked\"    \"began\"     \n#> [14,] \"called\"    \"troubled\"     \"described\"   \"routed\"    \n#> [15,] \"formed\"    \"lasted\"       \"lived\"       \"threw\"     \n#> [16,] \"succeeded\" \"protracted\"   \"wrote\"       \"met\"       \n#> [17,] \"conquered\" \"checked\"      \"educated\"    \"cut\"       \n#> [18,] \"followed\"  \"kept\"         \"established\" \"served\"    \n#> [19,] \"forced\"    \"stormed\"      \"ground\"      \"married\"   \n#> [20,] \"held\"      \"fell\"         \"bound\"       \"got\"       \n#> [21,] \"seized\"    \"loved\"        \"supported\"   \"proclaimed\"\n#> [22,] \"broke\"     \"spoke\"        \"developed\"   \"recovered\" \n#> [23,] \"became\"    \"accomplished\" \"reorganized\" \"ruled\"     \n#> [24,] \"put\"       \"contrived\"    \"converted\"   \"scattered\" \n#> [25,] \"named\"     \"preserved\"    \"produced\"    \"defeated\"\n```\n:::\n:::\n\n\nWell done. Verbs may be better at capturing multi-century topics rather than names of individuals who did not live that long.\n\n## Making a chart\n\nVariable `mod5` contains the LDA model that you fitted in the previous exercise. All necessary libraries have already been loaded for you.\n\n**Steps**\n\n1. Make a stacked column chart showing proportions of topics in documents/chapters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract matrix gamma and plot it\ntidy(mod5, \"gamma\") %>% \n    mutate(document=as.numeric(document)) %>% \n    ggplot(aes(x=document, y=gamma)) + \n    geom_col(aes(fill=factor(topic)))\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n2. To remind yourself what the topics were about, display the words with probability above 0.0075 in each topic. \n\n    * Use function `terms` with argument `threshold`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display the words whose probability is above the threshold\nterms(mod5, threshold=0.0075)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $`Topic 1`\n#>  [1] \"destined\" \"did\"      \"found\"    \"had\"      \"left\"     \"made\"    \n#>  [7] \"took\"     \"was\"      \"won\"      \"died\"    \n#> \n#> $`Topic 2`\n#>  [1] \"began\"        \"continued\"    \"cut\"          \"did\"          \"dwelt\"       \n#>  [6] \"fell\"         \"loved\"        \"protracted\"   \"proved\"       \"chose\"       \n#> [11] \"covered\"      \"burst\"        \"checked\"      \"granted\"      \"kept\"        \n#> [16] \"lasted\"       \"strove\"       \"troubled\"     \"spoke\"        \"accomplished\"\n#> [21] \"contrived\"    \"displayed\"    \"knew\"         \"preserved\"    \"endeavoured\" \n#> [26] \"caused\"       \"stormed\"     \n#> \n#> $`Topic 3`\n#>  [1] \"built\"       \"devoted\"     \"established\" \"gave\"        \"ground\"     \n#>  [6] \"marked\"      \"placed\"      \"stood\"       \"turned\"      \"bound\"      \n#> [11] \"celebrated\"  \"described\"   \"headed\"      \"lived\"       \"raised\"     \n#> [16] \"supported\"   \"survived\"    \"developed\"   \"kept\"        \"reorganized\"\n#> [21] \"converted\"   \"provoked\"    \"wrote\"       \"produced\"    \"wounded\"    \n#> [26] \"educated\"    \"immured\"    \n#> \n#> $`Topic 4`\n#>  [1] \"appeared\" \"began\"    \"came\"     \"cut\"      \"fell\"     \"laid\"    \n#>  [7] \"received\" \"refused\"  \"reigned\"  \"said\"     \"served\"   \"threw\"   \n#> [13] \"marched\"  \"sent\"     \"fled\"     \"married\"  \"slew\"     \"met\"     \n#> [19] \"routed\"   \"got\"\n```\n:::\n:::\n\n\nStacked bars make comparison of topic proportions difficult. It is easier to compare values when they are shown in line plots.\n\n3. You are given a code that will generate a line plot. Specify new axes labels: set x label to `Chapter` and y label to `Topic probability`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract matrix gamma and plot it\ntidy(mod5, \"gamma\") %>% \n    mutate(document=as.numeric(document)) %>% \n    ggplot(aes(x=document, y=gamma)) + \n    geom_line(aes(color=factor(topic))) + \n    labs(x=\"Chapter\", y=\"Topic probability\") +\n    scale_color_manual(values=brewer.pal(n=4, \"Set1\"), name=\"Topic\")\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nGreat job. You can trace the history of the Byzantine Empire through action-oriented topics.\n\n## Use wordclouds\n\nThe flaw of function `terms()` is that it does not display the absolute value of the word probability. By comparison, wordclouds can convey that information through font size. In this exercise you will make wordclouds for topics found in the text on Byzantine Empire.\n\nYou are given the object with LDA model `mod`. You're going to complete the script to draw four wordlcouds, one for each topic. You will be able to cycle through them in the output window.\n\n**Steps**\n\n1. Generate a table of word frequencies for each topic.\n2. Display the word cloud. You need to pass the terms to the `word`argument and the frequencies to the `freq` argument. The for-loop will do one chart per topic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display wordclouds one at a time\nfor (j in 1:4) {\n  # Generate a table with word frequences for topic j\n  word_frequencies <- tidy(mod5, matrix=\"beta\") %>% \n    mutate(n = trunc(beta * 10000)) %>% \n    filter(topic == j)\n\n  # Display word cloud\n  wordcloud(words = word_frequencies$term, \n            freq = word_frequencies$n,\n            max.words = 20,\n            scale = c(3, 0.5),\n            colors = c(\"DarkOrange\", \"CornflowerBlue\", \"DarkRed\"), \n            rot.per = 0.3)\n}\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-28-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-28-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-28-4.png){width=672}\n:::\n:::\n\n\nWonderful. You can navigate across topics by clicking the 'Previous Plot' and 'Next Plot' buttons to see other charts.\n\n# 3. Named entity recognition as unsupervised classification\n\nThis chapter goes into detail on how LDA topic models can be used as classifiers. It covers the importance of the Dirichlet shape parameter alpha, construction of word contexts for named entities using regex, and technical issues like corpus alignment and held-out data.\n\n## Using topic models as classifiers\n\nTheory. Coming soon ...\n\n**1. Using topic models as classifiers**\n\nIn this lesson you will learn how LDA can be used as a classifier, and what role control parameters alpha and delta play.\n\n**2. Topic models as soft classifiers**\n\nAlthough many applications of topic models involve topic discovery - finding out what topics are present in a body of documents - we can also apply topic modeling for document classification. In that case, we do not need to worry about finding the best number of topics. Instead, we need to tune the model so it works best as a classifier.In this chapter we will examine Named Entity Recognition - a task arising in processing text. An entity is a word, or several words, referring to a proper noun - a person, a place, or a corporation, if you are working with business documents.For example, in the sentence \"Washington crossed the Delaware\", the reference is to George Washington, a person. In the phrase, \"They did a road trip across Washington\", the reference is to a place, Washington state.The context in which the entity appears gives us clues on the entity's meaning. We can perform topic modeling of the entity context words and use the result as the classification.\n\n**3. Effect of control parameter alpha**\n\nWith the number of topics k known, the control parameters alpha and delta begin to matter.Back in chapter 2 we had a small corpus consisting of five sentences. We knew that there were only two topics: restaurants and loans. First two sentences were about loans, sentences 3 and 4 were about restaurants, and sentence 5 had words related to both topics.Back then you did a short exercise which illustrated the effect of alpha - when alpha was set to 25, each document was equally likely to belong to topic 1 and topic 2 - the split was 50/50.Now we can examine in more detail why this has happened.\n\n**4. How LDA fits a model**\n\nIn order to understand where alpha matters, we need to talk a little bit about how the LDA algorithm fits a model.The key analogy here is with a bag of M&amp;M candy. The candy come in a small number of preset colors. Frequency of colors is fixed at the factory that filled the bag.Imagine that you reach in and grab ten pieces of candy. The probability that you got 5 yellow, 2 brown, 2 blue, and 1 black pieces is modeled by something called multinomial distribution. For comparison, binomial distribution describes the flips of a coin where there are only two outcomes. Multinomial distribution has more than two outcomes.In LDA algorithm, topics correspond to colors, and there are actually two \"bags\" from which items are drawn. One bag corresponds to documents, another to words.\n\n**5. The Dirichlet in LDA**\n\nIf the topics are color, and documents are candy, how does the LDA algorithm find the probabilities of topics that give the best fit?One approach is to search for each combination, but it becomes very difficult when the number of topics, documents and words goes up.Instead, the LDA algorithm relies on the Dirichlet distribution to produce these values.The Dirichlet distribution returns a set of positive numbers that are less than 1, and sum up to 1 - the properties we want in a probability distribution.Here is an example of five draws from a 3-dimensional Dirichlet distribution. Note how each row adds up to 1. Each row could serve as a guess for the probability of topics in documents.\n\n**6. Dirichlet distribution**\n\nHere is a chart with the density profile of a 3-dimensional Dirichlet distribution.The dimensions correspond to the corners of a triangle: (1,0,0), (0,1,0), and (0,0,1)Combinations of dimensions will serve as the multinomial distribution modeling probabilities of topics.The peaks in the corners indicate that the most likely outcomes will be where one topic heavily dominates over others in a document.\n\n**7. alpha and the shape of Dirichlet distribution**\n\nNow we can finally see the effect of alpha on the probabilities of topics in documents.When alpha  is greater than 1, the distribution has  most of its mass in the center. This means that the more likely combinations of probabilities will be equal fractions of 1. For instance, (0.33, 0.33, 0.33) if we are dealing with 3 topics.When alpha is less than 1, the mass will be concentrated in the corners, and the more likely combinations will be something like (0.8, 0.1, 0.1), heavily favoring one topic.Parameter delta has a similar role, but for the distribution that models probabilities of words belonging to topics.As you will see in the exercises, it matters a lot when we want to use LDA topic modeling as a classifier.\n\n**8. Let's practice!**\n\nBy now you have seen a lot of slides talking about effect of alpha. Let's explore this with numbers.\n\n## Same k, different alpha\n\nYou are given a document-term matrix `dtm` describing the five-sentence corpus of two topics. You will re-run the LDA algorithm, changing the value of `alpha`, and compare the outcomes.\n\n**Steps**\n\n1. Experiment with fitting a topic model and clicking Run Code for the following values of `alpha`: 0.5, 1, 2, and NULL.\n2. When you are done, click Submit Answer with `alpha` equal to `NULL`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load data\ndtm6 <- readRDS(\"data/dtm6.rds\")\n\n# Fit a topic model using LDA with Gibbs sampling\nmod6_1 = LDA(x=dtm6, k=2, method=\"Gibbs\", \n          control=list(iter=500, thin=1,\n                      seed = 12345,\n                      alpha=NULL))\n\n# Display topic prevalance in documents as a table\ntidy(mod6_1, \"gamma\") %>% spread(topic, gamma)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"document\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"1\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"2\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1047736\",\"2\":\"0.5370370\",\"3\":\"0.4629630\"},{\"1\":\"109738\",\"2\":\"0.6625767\",\"3\":\"0.3374233\"},{\"1\":\"1107465\",\"2\":\"0.4638554\",\"3\":\"0.5361446\"},{\"1\":\"1125897\",\"2\":\"0.2251656\",\"3\":\"0.7748344\"},{\"1\":\"1131046\",\"2\":\"0.5375494\",\"3\":\"0.4624506\"},{\"1\":\"1151252\",\"2\":\"0.4285714\",\"3\":\"0.5714286\"},{\"1\":\"1220615\",\"2\":\"0.6276596\",\"3\":\"0.3723404\"},{\"1\":\"1244489\",\"2\":\"0.3513514\",\"3\":\"0.6486486\"},{\"1\":\"1311540\",\"2\":\"0.6524823\",\"3\":\"0.3475177\"},{\"1\":\"1321339\",\"2\":\"0.2362637\",\"3\":\"0.7637363\"},{\"1\":\"139715\",\"2\":\"0.5079365\",\"3\":\"0.4920635\"},{\"1\":\"1409434\",\"2\":\"0.4184397\",\"3\":\"0.5815603\"},{\"1\":\"1433541\",\"2\":\"0.6440678\",\"3\":\"0.3559322\"},{\"1\":\"1456314\",\"2\":\"0.3299492\",\"3\":\"0.6700508\"},{\"1\":\"1459536\",\"2\":\"0.7410359\",\"3\":\"0.2589641\"},{\"1\":\"1500850\",\"2\":\"0.7512438\",\"3\":\"0.2487562\"},{\"1\":\"1502170\",\"2\":\"0.6776316\",\"3\":\"0.3223684\"},{\"1\":\"1506130\",\"2\":\"0.5279188\",\"3\":\"0.4720812\"},{\"1\":\"1515738\",\"2\":\"0.6586826\",\"3\":\"0.3413174\"},{\"1\":\"1535764\",\"2\":\"0.6347305\",\"3\":\"0.3652695\"},{\"1\":\"1544254\",\"2\":\"0.3333333\",\"3\":\"0.6666667\"},{\"1\":\"1545793\",\"2\":\"0.6284153\",\"3\":\"0.3715847\"},{\"1\":\"1553861\",\"2\":\"0.5870968\",\"3\":\"0.4129032\"},{\"1\":\"1565708\",\"2\":\"0.7900763\",\"3\":\"0.2099237\"},{\"1\":\"1605060\",\"2\":\"0.7245179\",\"3\":\"0.2754821\"},{\"1\":\"1608501\",\"2\":\"0.6029963\",\"3\":\"0.3970037\"},{\"1\":\"1608709\",\"2\":\"0.7299270\",\"3\":\"0.2700730\"},{\"1\":\"1611839\",\"2\":\"0.6647059\",\"3\":\"0.3352941\"},{\"1\":\"1613951\",\"2\":\"0.6666667\",\"3\":\"0.3333333\"},{\"1\":\"1615050\",\"2\":\"0.7211896\",\"3\":\"0.2788104\"},{\"1\":\"1620222\",\"2\":\"0.5074074\",\"3\":\"0.4925926\"},{\"1\":\"1620526\",\"2\":\"0.5875706\",\"3\":\"0.4124294\"},{\"1\":\"1623479\",\"2\":\"0.4121212\",\"3\":\"0.5878788\"},{\"1\":\"1642391\",\"2\":\"0.5673759\",\"3\":\"0.4326241\"},{\"1\":\"1660700\",\"2\":\"0.2489796\",\"3\":\"0.7510204\"},{\"1\":\"1719690\",\"2\":\"0.5291480\",\"3\":\"0.4708520\"},{\"1\":\"1725544\",\"2\":\"0.3645320\",\"3\":\"0.6354680\"},{\"1\":\"1738598\",\"2\":\"0.2488688\",\"3\":\"0.7511312\"},{\"1\":\"1744828\",\"2\":\"0.5036496\",\"3\":\"0.4963504\"},{\"1\":\"1757872\",\"2\":\"0.4274809\",\"3\":\"0.5725191\"},{\"1\":\"1806630\",\"2\":\"0.5607477\",\"3\":\"0.4392523\"},{\"1\":\"1806915\",\"2\":\"0.6456693\",\"3\":\"0.3543307\"},{\"1\":\"1808606\",\"2\":\"0.3000000\",\"3\":\"0.7000000\"},{\"1\":\"1809769\",\"2\":\"0.3705179\",\"3\":\"0.6294821\"},{\"1\":\"1812472\",\"2\":\"0.3177570\",\"3\":\"0.6822430\"},{\"1\":\"1827457\",\"2\":\"0.3607306\",\"3\":\"0.6392694\"},{\"1\":\"1827906\",\"2\":\"0.4784173\",\"3\":\"0.5215827\"},{\"1\":\"1829905\",\"2\":\"0.5904255\",\"3\":\"0.4095745\"},{\"1\":\"1834539\",\"2\":\"0.2118644\",\"3\":\"0.7881356\"},{\"1\":\"1838456\",\"2\":\"0.5377778\",\"3\":\"0.4622222\"},{\"1\":\"1854440\",\"2\":\"0.5833333\",\"3\":\"0.4166667\"},{\"1\":\"213502\",\"2\":\"0.3837209\",\"3\":\"0.6162791\"},{\"1\":\"221062\",\"2\":\"0.7828054\",\"3\":\"0.2171946\"},{\"1\":\"231834\",\"2\":\"0.2408163\",\"3\":\"0.7591837\"},{\"1\":\"301476\",\"2\":\"0.6140351\",\"3\":\"0.3859649\"},{\"1\":\"310542\",\"2\":\"0.6410256\",\"3\":\"0.3589744\"},{\"1\":\"324966\",\"2\":\"0.6129032\",\"3\":\"0.3870968\"},{\"1\":\"327546\",\"2\":\"0.5142857\",\"3\":\"0.4857143\"},{\"1\":\"346906\",\"2\":\"0.3148936\",\"3\":\"0.6851064\"},{\"1\":\"443128\",\"2\":\"0.2874251\",\"3\":\"0.7125749\"},{\"1\":\"456118\",\"2\":\"0.4081633\",\"3\":\"0.5918367\"},{\"1\":\"456683\",\"2\":\"0.3602941\",\"3\":\"0.6397059\"},{\"1\":\"538663\",\"2\":\"0.3825137\",\"3\":\"0.6174863\"},{\"1\":\"550234\",\"2\":\"0.5270270\",\"3\":\"0.4729730\"},{\"1\":\"603248\",\"2\":\"0.3296089\",\"3\":\"0.6703911\"},{\"1\":\"607372\",\"2\":\"0.4574468\",\"3\":\"0.5425532\"},{\"1\":\"607532\",\"2\":\"0.5759494\",\"3\":\"0.4240506\"},{\"1\":\"635449\",\"2\":\"0.4230769\",\"3\":\"0.5769231\"},{\"1\":\"732448\",\"2\":\"0.6692308\",\"3\":\"0.3307692\"},{\"1\":\"743835\",\"2\":\"0.3455882\",\"3\":\"0.6544118\"},{\"1\":\"814391\",\"2\":\"0.6045198\",\"3\":\"0.3954802\"},{\"1\":\"8711615\",\"2\":\"0.4489796\",\"3\":\"0.5510204\"},{\"1\":\"8715892\",\"2\":\"0.6106870\",\"3\":\"0.3893130\"},{\"1\":\"8750598\",\"2\":\"0.3780488\",\"3\":\"0.6219512\"},{\"1\":\"8807291\",\"2\":\"0.3636364\",\"3\":\"0.6363636\"},{\"1\":\"8918276\",\"2\":\"0.6830986\",\"3\":\"0.3169014\"},{\"1\":\"8951927\",\"2\":\"0.4747475\",\"3\":\"0.5252525\"},{\"1\":\"9109765\",\"2\":\"0.6642857\",\"3\":\"0.3357143\"},{\"1\":\"9115706\",\"2\":\"0.7272727\",\"3\":\"0.2727273\"},{\"1\":\"9123212\",\"2\":\"0.4347826\",\"3\":\"0.5652174\"},{\"1\":\"9202352\",\"2\":\"0.5888889\",\"3\":\"0.4111111\"},{\"1\":\"9252957\",\"2\":\"0.5106383\",\"3\":\"0.4893617\"},{\"1\":\"93292\",\"2\":\"0.3036649\",\"3\":\"0.6963351\"},{\"1\":\"9424053\",\"2\":\"0.5520833\",\"3\":\"0.4479167\"},{\"1\":\"9452350\",\"2\":\"0.4600000\",\"3\":\"0.5400000\"},{\"1\":\"9600080\",\"2\":\"0.6941176\",\"3\":\"0.3058824\"},{\"1\":\"961860\",\"2\":\"0.4625000\",\"3\":\"0.5375000\"},{\"1\":\"9619021\",\"2\":\"0.1949153\",\"3\":\"0.8050847\"},{\"1\":\"9876565\",\"2\":\"0.7596154\",\"3\":\"0.2403846\"},{\"1\":\"9911295\",\"2\":\"0.8093220\",\"3\":\"0.1906780\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n> *Question*\n> ---\n> Which value of alpha leads to the 50/50 (plus minus 2 percent) split in topic prevalence in all documents?<br>\n> <br>\n> ✅ alpha=NULL<br>\n> ⬜ alpha = 2<br>\n> ⬜ alpha = 1<br>\n> ⬜ alpha = 0.5<br>\n\nYes. When alpha is NULL, the package sets alpha = 50/k which in our case is 25. This favors topic proportions that are nearly equal to each other.\n\n## Probabilities of words in topics\n\nParameter alpha determines the values of probabilities that a document belongs to a topic. Parameter delta does the same for probability distribution of words over topics. By default, delta is set to 0.1. You will fit a model with a different delta and make a plot of results.\n\n**Steps**\n\n1. Fit the model for delta set to 0.1, create a tidy table containing probabilities `beta` for words from the `my_terms` vector and make a stacked column chart from the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the model for delta = 0.1\nmod1_5 <- LDA(x=dtm1, k=2, method=\"Gibbs\",\n         control=list(iter=500, seed=12345, alpha=1, delta=0.1))\n\n# Define which words we want to examine\nmy_terms = c(\"loans\", \"bank\", \"opened\", \"pay\", \"restaurant\", \"you\")\n\n# Make a tidy table\nt <- tidy(mod1_5, \"beta\") %>% filter(term %in% my_terms)\n\n# Make a stacked column chart of word probabilities\nggplot(t, aes(x=term, y=beta)) + geom_col(aes(fill=factor(topic))) +\n  theme(axis.text.x=element_text(angle=90))\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n2. Fit the model for delta set to 0.5, create a tidy table containing probabilities `beta` for words from the `my_terms` vector and make a stacked column chart from the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the model for delta = 0.5\nmod1_6 <- LDA(x=dtm1, k=2, method=\"Gibbs\",\n         control=list(iter=500, seed=12345, alpha=1, delta=0.5))\n\n# Define which words we want to examine\nmy_terms = c(\"loans\", \"bank\", \"opened\", \"pay\", \"restaurant\", \"you\")\n\n# Make a tidy table\nt <- tidy(mod1_6, \"beta\") %>% filter(term %in% my_terms)\n\n# Make a stacked column chart\nggplot(t, aes(x=term, y=beta)) + geom_col(aes(fill=factor(topic))) +\n  theme(axis.text.x=element_text(angle=90))\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nGood. The probabilities of words are more even in the second chart, when delta was set to 0.5. Modifying delta lets you control how exclusive the topic should be.\n\n## From word windows to dtm\n\nTheory. Coming soon ...\n\n\n**1. From word windows to dtm**\n\nA context of an entity is represented by a word window. In this lesson you will learn how to extract them and transform them into a dtm.\n\n**2. Word window**\n\nAn entity is a word that refers to a personal noun. We usually can tell personal nouns because they are capitalized.A word window is a sequence of words with the entity word in the middle. It is similar to the context, because it shows the words that occur together with the entity.For example, a phrase \"attention of Megara was turned\" is a window for entity Megara, with two words on the left and two on the right.We can differentiate the words by adding a suffix to tell where the word was originally located: first on the left (L1), or second on the right (R2).\n\n**3. A document for every entity**\n\nOnce we have the word windows for entities, we can combine them, making one document per entity. We can use function paste() inside of summarise() for this purpose.Here is an example of the document for entity `Anastasius`. It consists of four words which came from two word windows.You can tell that the entity is a person: usually we do not say that a geographic entity \"has bequeathed\" anything.\n\n**4. Finding entities with regular expressions &amp; stringr**\n\nHow would we find entities? Because an entity is a capitalized word, we can detect it using regular expressions: we will look for a word that has one uppercase letter followed by one or more lowercase letters.We can do that with the basic regex functions: gregexpr() and regmatches().Let's look at the pattern used in the code example. In the simplest form, a regular expression pattern consists of declarations of character classes and quantifiers.The class can be specified as a range of characters. The range is based on the ASCII codes: \"a\" has smaller code than \"z\", and \"0\" has smaller code than \"9\".Quantifiers specify how many times a character (or a sequence of them) may occur. There is a lower bound \"n\", and upper bound \"m\".There are some shortcuts: the question mark stands for \"occurs zero or one time\", plus sign means \"occurs one or more times\", asterisk - \"occurs zero or more times\".Our pattern was one upper-case letter followed by one or more lower-case letters.\n\n**5. Regular expressions with groups**\n\nIn regular expressions, parentheses serve to group some patterns together. As a quick aside, parentheses can also serve to capture the groups - store their contents for later use.As an example, take a look at the new pattern for an entity. Compared to the previous one, it will match entities that have `St.` in them.It includes a group - characters S, t, dot, whitespace, followed by a quantifier.The quantifier is the question mark, meaning that the group can occur zero or one times. In other words, this group is optional. If it occurs, it will be included, and if it does not, the pattern will still match.\n\n**6. Using capture groups to add a suffix**\n\nAnd now we can talk about capture groups. Characters inside parentheses can be referenced later on in the pipeline of operations.The most widespread use is in substitution, as in this example. Function gsub() replaces a pattern throughout the whole text string.The pattern contains two capture groups, each one being a lowercase word.The caret symbol is an anchor that specifies position in the string - the start. Dollar sign is the anchor for end of string.The string with backslashes and a number is a reference to a capture group. The search pattern in gsub() says \"match two lower case words, one in each group\". The substitution pattern says \"insert contents of group 1 followed by underscore L1\", and \"insert contents of group 2 followed by underscore L2\"The result is that the words on the left now have suffixes and later on we will known which side of the entity they came from.\n\n**7. Let's practice**\n\nBy now you refreshed upon the basics of regular expressions. Let's practice and put them to use.\n\n## Regex patterns for entity matching\n\nVector `text` contains text of chapters of The Byzantine Empire by Charles Oman. You will experiment with the regex patterns for entity matching.\n\n**Steps**\n\n1. You are given a pattern that will match a capitalized word and two lowercase words before and after. Find how many times this pattern matched.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create text\ntext <- tbe_book_chapters$text\n\n# Regex pattern for an entity and word context\np1 <- \"( [a-z]+){2}( (St[.] )?[A-Z][a-z]+)+( [a-z]+){2}\"\n\n# Obtain the regex match object from gregexpr\nm <- gregexpr(p1, text)\n\n# Get the matches and flatten the list\nv <- unlist(regmatches(text, m))\n\n# Find the number of elements in the vector\nlength(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1505\n```\n:::\n:::\n\n\n2. The vertical bar `|` in regex means logical OR. You now have a modified pattern, `p2`, that has a nested group `( (of|the) [A-Z][a-z]+)?`. It matches entities like 'Alexander the Great' or 'Darius of Persia'.\n3. Find how many entities you match now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Regex pattern for an entity and word context\np2 <- \"( [a-z]+){2}( (St[.] )?[A-Z][a-z]+( (of|the) [A-Z][a-z]+)?)+( [a-z]+){2}\"\n\n# Obtain the regex match object from gregexpr\nm <- gregexpr(p2, text)\n\n# Get the matches and flatten the list\nv = unlist(regmatches(text, m))\n\n# Find the number of elenents in the vector\nlength(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1533\n```\n:::\n:::\n\n\n> *Question*\n> ---\n> Which pattern, `p1` or `p2`, returned more matches?<br>\n> <br>\n> ⬜ `p1` returned more matches.<br>\n> ✅ `p2` returned more matches.<br>\n> ⬜ They both returned the same number of matches.<br>\n\nYes! By making the pattern more general, we were able to match more entities: 1533 vs. 1505\n\n## Making a corpus\n\nYou are given the pattern `entity_pattern` for the named entity. Vector `v` contains strings with named entities and two words to the left and to the right of the entity. You are going to make a table containing entity and its context as two columns.\n\n**Steps**\n\n1. Print out the contents of the pattern string `entity_pattern`. \n2. Function `gsub()` can be used to cut out strings by replacing them with zero-length strings, e.g. `gsub('[0-9]', \"\", \"Year of 1203 CE\")` will return `Year of  CE`. Use this trick to remove the named entity from text. This will produce the entity's context. \n3. Save the result into variable `v2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print out contents of the `entity_pattern`\nentity_pattern <- \"( (St[.] )?[A-Z][a-z]+( (of|the) [A-Z][a-z]+)?)+\"\n\n# Remove the named entity from text\nv2 <- gsub(entity_pattern, \"\", v)\n\n# Display the head of v2\nhead(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \" into the shore of\"       \" settlers were of the\"   \n#> [3] \" cities of in the\"        \" to the to plant\"        \n#> [5] \" attention of was turned\" \" of the and the\"\n```\n:::\n:::\n\n\n4. Regex capture groups can be used to add suffixes to lowercase. You are given a pattern `p` that will add suffixes `L1` and `L2`. Modify `p` so that `gsub()` would also add suffixes `R1` and `R2` to words occurring on the right side of the context.\n5. Add backreferences to capture groups 3 and 4 and add suffixes 'R1' and 'R2' respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove the named entity\nv2 <- gsub(entity_pattern, \"\", v)\n\n# Pattern for inserting suffixes\np <- \"\\\\1_L1 \\\\2_L2 \\\\3_R1 \\\\4_R2\"\n\n# Add suffixes to words\ncontext <- gsub(\"([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)\", p, v2)\n```\n:::\n\n\n6. By now you have vector `v2` which contains the new \"documents\" - context words of named entities. You have figured out how to add suffixes to the context words using `gsub()`. Now, two last steps toward making a corpus: converting the context strings into a data frame, and assigning named entity string as document ids.\n\n    * Generate a regular expression match object by using `gregexpr()` First argument is the pattern, second argument is text. Store the result in variable `re_match`.\n    * Extract named entities and make a data frame named `corpus` with columns `doc_id` and `text` to make a document-term matrix. Function `regmatches()` will return a list with matched strings, which you can flatten by using `unlist()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract named entity and use it as document ID\nre_match <-  gregexpr(entity_pattern, v)\ndoc_id   <- unlist(regmatches(v, re_match))\n\n# Make a data frame with columns doc_id and text\ncorpus2 <- data.frame(doc_id = doc_id, text = context, stringsAsFactors = F)\n```\n:::\n\n\nVery good! Regex functions can be tricky but you figured it out.\n\n## From dtm to topic model\n\nYou are given data frame `corpus`. Each row corresponds to one occurrence of a named entity. Column `doc_id` contains the entity, `text` - the context words with suffixes. You will build a document-term matrix and will fit a topic model.\n\n**Steps**\n\n1. We need to combine text from multiple occurrences of the same entity into one document. Using `dplyr`, for each entity (`doc_id`) generate a summary variable `doc` that will contain combined `text` strings. Save the result into table `corpus3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summarize the text to produce a document for each doc_id\ncorpus3 <- corpus2 %>% \n            group_by(doc_id) %>% \n            summarize(doc = paste(text, collapse = \" \"))\n```\n:::\n\n\n2. Now that we have dataframe `corpus3`, we are on familiar grounds. Create a document-term matrix and save it into variable `dtm7`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make a document-term matrix\ndtm7 <- corpus3 %>% \n        unnest_tokens(input = doc, output = word) %>% \n        count(doc_id, word) %>% \n        cast_dtm(document = doc_id, term = word, value = n)\n```\n:::\n\n\n3. Fit a Latent Dirichlet allocation topic model with `k=3`. Keep the `control` argument as is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit an LDA model for 3 topics\nmod7 <- LDA(x = dtm7, k = 3, method = \"Gibbs\", \n          control=list(alpha = 1, seed = 12345, iter = 1000, thin = 1))\n```\n:::\n\n\n4. Using function `tidy`, extract matrix `gamma` with probabilities of topics in documents, and convert it to a wide format using `spread`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a table with probabilities of topics in documents\ntopics <- tidy(mod7, matrix=\"gamma\") %>% \n            spread(topic, gamma)\n```\n:::\n\n\nExcellent. Later on we will use this model in a classifier.\n\n## Corpus alignment and classification\n\nTheory. Coming soon ...\n\n**1. Corpus alignment and classification**\n\nIn this lesson you will learn how to use a pre-trained model as a classifier on new data, and how this step requires aligning the vocabularies of the new input and the model.\n\n**2. Unsupervised classification**\n\nIn the previous lesson, we fitted a topic model for k=3. It is useful for telling the meaning of a named entity.For example, the code below retrieves the probabilities of three topics for five documents. Three of them - Alboin, Amorium, and Cappadocian - are unknown to me.Probabilities of topics suggest that Alboin is similar to Alexander - it is a person, while Amorium and Cappadocian are related to geographic names.\n\n**3. Using pre-trained model**\n\nIdeally, we would like to use a pre-trained model to find probabilities of topics for entities that were not seen before.This can be done using function posterior() in package topicmodels.This function accepts a model and new data, and returns posterior probabilities of words in topics and topics in documents.There is a new problem we would face in this: corpus alignment.Internally, LDA algorithm iterates over items which are known by their index number. Thus, two dtm's with different terms but same number of columns would appear the same to the LDA. It is our responsibility to make sure that the document-term matrix of the new data is consistent with the vocabulary of the model.\n\n**4. Corpus alignment**\n\nCorpus alignment involves making sure that the document-term matrix for the new data includes only the words that were present in the corpus when the topic model was fitted.An easy way to extract model's vocabulary is to use tidy() with argument matrix=\"beta\" - it will return probabilities of words in topics. We really need only the column \"term\".We can accomplish corpus alignment by doing a right-join between the new document's table of counts and the table with model's vocabulary. Right-join drops the rows of the left-side table if they have no match, and keeps all rows of the right-side table.One side effect of doing the right-join is that we will have to deal with the NA values which will appear in the column with counts and document ids.\n\n**5. Handling NA values**\n\nRight-join will leave us with NA values in two columns: the word counts, and the doc ID. We could easily handle the word counts with an ifelse() function, changing them to 0.Handling document names is a bit trickier. If we do nothing, then, when we perform cast_dtm(), we will end up with a new document. Its name will be \"NA\".So, instead, we will take the first \"good\" document id and use it to replace NAs. It will not distort the prediction because the word counts in these rows are zeros, anyways.\n\n**6. Held-out data**\n\nIf you took any classes on machine learning, you are familiar with a discussion about over-fitting and that a classifier must be tested on a different set of records than the ones used for training.In topic models, there is a similar concept of held-out data. There are two variations of the approach, though.In one, we would remove whole documents from testing. This is similar to setting aside a dataset for testing in machine learning.In the other approach, a certain percentage of terms (for example, 50%) are removed from some documents, and these documents are used as the test set. The quality of the fit is estimated through \"held-out likelihood\".In this course, for the sake of simplicity, we will withhold a small set of full documents and examine how they got classified.\n\n**7. Let's practice!**\n\nLet's practice.\n\n## Train a topic model\n\nYou are given a table `corpus3`: column `doc_id` contains the named entity, column `doc` contains context words of entities. You will take a random sample of documents, construct a training dataset and use it to make a topic model.\n\n**Steps**\n\n1. Take a sample of 20 random integers in the range from 1 to `nrow(corpus2)` and assign it to variable `r`. These will be the testing rows.\n2. Pass a subset of the dtm, with the testing rows excluded, as an argument to `unnest_tokens`, to create a dtm with training data.\n3. Fit an LDA topic model for `k=3` on the training data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set random seed for reproducability\nset.seed(12345, sample.kind=\"Rounding\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning in set.seed(12345, sample.kind = \"Rounding\"): non-uniform 'Rounding'\n#> sampler used\n```\n:::\n\n```{.r .cell-code}\n# Take a sample of 20 random integers, without replacement\nr <- sample.int(n=nrow(corpus3), size=20, replace=FALSE)\n\n# Generate a document-term matrix\ntrain_dtm <- corpus3[-r, ] %>% \n                unnest_tokens(input=doc, output=word) %>% \n                count(doc_id, word) %>% \n                cast_dtm(document=doc_id, term=word, value=n)\n\n# Fit an LDA topic model for k=3\ntrain_mod <- LDA(x=train_dtm, k=3, method=\"Gibbs\",\n                control=list(alpha=1, seed=10001,\n                             iter=1000, thin=1))\n```\n:::\n\n\nVery good! We just trained our classifier.\n\n## Align corpus\n\nYou have LDA model object `train_mod` and table `corpus3` with initial data. You will need to align the corpus of the test records and make a document-term matrix for testing.\n\n**Steps**\n\n1. Rerun `sample.int` with `set.seed` to reproduce the row indices for testing rows.\n2. Extract vocabulary of the training model using `tidy`\n3. Create a table of counts, making sure that you keep only the rows with words that were present in the training data\n4. Generate a document-term matrix with the testing data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the test row indices\nset.seed(12345, sample.kind=\"Rounding\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning in set.seed(12345, sample.kind = \"Rounding\"): non-uniform 'Rounding'\n#> sampler used\n```\n:::\n\n```{.r .cell-code}\nr <- sample.int(n=nrow(corpus3), size=20, replace=FALSE)\n\n# Extract the vocabulary of the training model\nmodel_vocab <- tidy(train_mod, matrix=\"beta\") %>% \n  select(term) %>% distinct()\n\n# Create a table of counts with aligned vocabularies\ntest_table <- corpus3[r, ] %>% unnest_tokens(input=doc, output=word) %>% \n  count(doc_id, word) %>%\n  right_join(model_vocab, by=c(\"word\"=\"term\"))\n\n# Prepare a document-term matrix\ntest_dtm <- test_table %>% \n  arrange(desc(doc_id)) %>% \n  mutate(doc_id = ifelse(is.na(doc_id), first(doc_id), doc_id),\n         n = ifelse(is.na(n), 0, n)) %>% \n  cast_dtm(document=doc_id, term=word, value=n)\n```\n:::\n\n\nExcellent! This exercise packed a lot of steps, but you did them all.\n\n## Classify test data\n\nYou have a data object `train_mod` with an LDA model, and a document-term matrix `test_dtm` with data for the test cases. Now you can see how well (or how poorly) our classifier performs.\n\n**Steps**\n\n1. Obtain posterior probabilities for test documents using function `posterior()`.\n2. Probabilities of topics in documents are contained in the element `$topics` inside the `result` list. Display the matrix with topic probabilities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain posterior probabilities for test documents\nresults <- posterior(object=train_mod, newdata=test_dtm)\n\n# Display the matrix with topic probabilities\nresults$topics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>                                      1          2         3\n#>  Visigothic                  0.5714286 0.14285714 0.2857143\n#>  Theodorics                  0.2000000 0.50000000 0.3000000\n#>  Stephen Lecapenus           0.3333333 0.33333333 0.3333333\n#>  St. Louis                   0.4000000 0.20000000 0.4000000\n#>  Po                          0.1428571 0.28571429 0.5714286\n#>  Patriarch of Constantinople 0.2857143 0.14285714 0.5714286\n#>  Parthian                    0.1428571 0.57142857 0.2857143\n#>  Paris                       0.4000000 0.40000000 0.2000000\n#>  John Cantacuzenus           0.5000000 0.37500000 0.1250000\n#>  Hunnish                     0.1666667 0.66666667 0.1666667\n#>  Hun                         0.2857143 0.14285714 0.5714286\n#>  Germans                     0.2857143 0.42857143 0.2857143\n#>  Gaul                        0.4285714 0.14285714 0.4285714\n#>  Gainas                      0.7777778 0.03703704 0.1851852\n#>  Empress                     0.1428571 0.42857143 0.4285714\n#>  Central Italy               0.2857143 0.14285714 0.5714286\n#>  Cappadocian                 0.1666667 0.66666667 0.1666667\n#>  Caesar                      0.4000000 0.20000000 0.4000000\n#>  Amalphi                     0.2857143 0.14285714 0.5714286\n#>  Abu Obeida                  0.2000000 0.40000000 0.4000000\n```\n:::\n:::\n\n\nNice! The named entities are used as document IDs, which makes reading the table easy.\n\n## Explore the results\n\nPrint out the table `results$topics` and note the values for the rows where the document name is \" Amalphi\". (The space before the entity is the result of the pattern we used.) Look up the articles in Wikipedia for Amalphi. Choose the option below that describes the results:\n\n> *Question*\n> ---\n> ???<br>\n> <br>\n> ✅ Amalphi is a town and topic 1 corresponds to geographic names.<br>\n> ⬜ Amalphi was a king and topic 1 corresponds to personal names.<br>\n> ⬜ Amalphi is a town and topic 2 corresponds to geographic names.<br>\n\nYes! There are some exceptions, but topic 1 has the highest probability of being in document \" Amalphi\".\n\n# 4. How many topics is enough?\n\nThis chapter explains the basic methods used in the search for the optimal number of topics. It also covers how to use a single document as a source of data, and how topic numbering can be controlled using seed words.\n\n## Finding the best number of topics\n\nTheory. Coming soon ...\n\n**1. Finding the best number of topics**\n\nIn this chapter you will learn how to determine `k` - the number of topics that must be provided to the LDA algorithm\n\n**2. Approaches**\n\nIn the examples so far we did not explore what the value of k - the number of topics in a model - should be. In the case of restaurants and loans it was obvious that k should be 2, but in the case of Byzantine Empire it was far from clear. Now we can get a look into how we determine the value of k.In general, there are two approaches. One involves fitting a model, inspecting the words that were assigned to topics, and deciding if the topics make sense. This is known as topic coherence.&lt;/br&gt;If we see words that normally should not occur together, we conclude that coherence is low. For example, if we expect the topic to be about archeology and we see the top words to be site, settlement, excavation, and popsicle, then we know that something went wrong. A popsicle usually does not occur in texts on archeology. &lt;/br&gt;Another approach involves looking at quantitative measures of fit: log-likelihood and perplexity. &lt;/br&gt;Log likelihood is a measure of how plausible the model parameters are given the data&lt;/br&gt;and perplexity is a measure of \"surprise\" when the model is given new data&lt;/br&gt;\n\n**3. Log-likelihood**\n\nLikelihood is a measure of how plausible model parameters are given the data.&lt;/br&gt;Calculating the likelihood involves multiplying probabilities of individual outcomes. By taking a logarithm, multiplication is transformed into summation, which is easier to implement, and hence we work with log-likelihood.&lt;/br&gt;All probabilities are values that are less than 1. When x is less than 1, logarithm of x will be less than zero. Log-likelihood is a negative number.&lt;/br&gt;Gibbs sampling is used to find the parameters which would have the highest log-likelihood. Note that the comparison is not by absolute magnitudes, but by position on the numbers scale: a log-likelihood of minus one hundred is better than a log-likelihood value of minus one hundred and five.&lt;/br&gt;Function `logLik` in `topicmodels` returns the log-likelihood of an LDA model.&lt;/br&gt;\n\n**4. Log-likelihood**\n\nThis chart shows an example of how LDA searches for the model with the best log-likelihood. There is an initial period, called \"burn-in\", where the algorithm is producing suboptimal values, followed by the more or less steady exploration of parameter space.&lt;/br&gt;\n\n**5. Perplexity**\n\nPerplexity is a mesuare of model's surprise at the data&lt;/br&gt;It is a positive number&lt;/br&gt;and the less surprise the better. That is, we prefer a model whose perplexity is smaller &lt;/br&gt;Function `perplexity` in package `topicmodels` will return the surprise of the model when presented newdata.&lt;/br&gt;\n\n**6. Finding the best k**\n\nIn order to find the best value for k, we fit the model for the varying number of clusters and record the results.&lt;/br&gt;Then we plot the log-likelihood and perplexity &lt;/br&gt;and look for 'bends' in the curves which are either the optimum or after which the improvements are not as dramatic.&lt;/br&gt;If you have done k-means clustering, you are familiar with this approach. This is similar to making the \"elbow plot\" and looking for the value where the curve bends. &lt;/br&gt;In this code example we are using a for-loop to iterate over the values of k&lt;/br&gt;\n\n**7. Plot of perplexity**\n\nLike in k-means clustering, the trivial solution to the best fit is when the number of clusters is equal the number of documents.However, we are searching for a balance between the smaller number of clusters and the quality of the fit.\"k equal six\" is a local minimum, which suggests it could be a reasonable choice.\n\n**8. Time costs**\n\nSearching for the best `k` can take a lot of time. &lt;/br&gt;The running time is determined by several factors: the number of documents, number of terms, and number of iterations. &lt;/br.The good news is that model fitting can be resumed: we can the model, save it, and then use the result as the starting point later on.&lt;/br&gt;Function `LDA` accepts a topic model as an object for initialization.&lt;/br&gt;Here is a code example showing how we run the LDA for one thousand iterations, save the model, then use it as the starting point and run the model for two hundred iterations more.&lt;/br&gt;.\n\n**9. Practice dataset**\n\nIn this lesson we will use a simple dataset for practice. It is a corpus of 90 documents&lt;/br&gt;These documents are abstracts of projects approved for funding by the US National Science Foundation&lt;/br&gt;The 90 documents are a sample from the search for four keywords: mathematics, physics, chemistry, and marine biology.&lt;/br&gt;Here is a snippet from one of the documents&lt;/br&gt;\n\n**10. Let's practice**\n\nWe got the theory. Now it's time to practice.\n\n## Preparing the dtm\n\nYou are given a dataframe `df` containing 90 abstracts of NSF awards. Its three columns are `Abstract`, `AwardNumber`, and `field`. Your task is to construct a document-term matrix, with stop words being filtered out. Use `AwardNumber` as the document ID.\n\n**Steps**\n\n1. Split the Abstract column into tokens.\n2. Remove stopwords.\n3. Count the number of occurrences.\n4. Create a document term matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\ndf <- readRDS(\"data/df.rds\")\n\n# Split the Abstract column into tokens\ndtm8 <- df %>% \n  \n   # Fix missing spaces after dots and colons (except for decimal places in numbers)\n   mutate(Abstract = Abstract |> str_replace_all(\"(?<!\\\\d)[:\\\\.](?!\\\\d)\", \" \")) |> \n  \n   unnest_tokens(input=Abstract, output=word) %>% \n   # Remove stopwords\n   anti_join(stop_words) %>% \n   # Count the number of occurrences\n   count(AwardNumber, word) %>% \n   # Create a document term matrix\n   cast_dtm(document=AwardNumber, term=word, value=n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"word\"\n```\n:::\n:::\n\n\nWell done! Let's keep going.\n\n## Filtering by word frequency\n\nThe small size of our corpus poses a problem: some terms will occur only once and are not useful for inferring the topics. In this exercise your task is to remove the words whose corpus-wide frequency is less than 10. This will require grouping by words and then adding up per-document frequencies.\n\nUnnesting tokens and removing stopwords using `anti_join()` has already been done for you.\n\n**Steps**\n\n1. Count occurrences within documents/awards.\n2. Group the data using `word` as the grouping variable.\n3. Filter using a nested call to `sum(n)` for corpus-wide frequency that is 10 or higher.\n4. Ungroup the data and create a document-term matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SnowballC)\n# rems <- c( \"context\", \"dai\", \"ecologi\", \"ph\",\"qepa\", \"size\")\n\ndtm9 <- df %>% \n  \n  # Fix missing spaces after dots and colons (except for decimal places in numbers)\n   mutate(Abstract = Abstract |> str_replace_all(\"(?<!\\\\d)[:\\\\.](?!\\\\d)\", \" \")) |> \n  \n   unnest_tokens(input=Abstract, output=word) %>% \n   anti_join(stop_words) %>% \n  \n  mutate(word = wordStem(word)) %>%\n  \n   # Count occurences within documents\n   count(AwardNumber, word) %>%\n  \n  # filter(!(word %in% rems)) |> \n  \n   # Group the data\n   group_by(word) %>% \n   # Filter for corpus wide frequency\n   filter(sum(n) >= 10) %>% \n   # Ungroup the data andreate a document term matrix\n   ungroup() %>% \n   cast_dtm(document=AwardNumber, term=word, value=n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Joining, by = \"word\"\n```\n:::\n:::\n\n\nExcellent. Now we move on to model fitting.\n\n## Fitting one model\n\nWith the document-term matrix in hand(load), your task now is to fit a topic model and examine its log-likelihood and perplexity.\n\n**Steps**\n\n1. Create a LDA model. Set `k=3` and `method=\"Gibbs\"`. Do not modify the `control` argument.\n2. Retrieve the log-likelihood of the model.\n3. Find perplexity for the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtm10 <- readRDS(\"data/dtm10.rds\")\n\n# Create a LDA model\nmod10_1 <- LDA(x=dtm10, method=\"Gibbs\", k=3, \n          control=list(alpha=0.5, seed=1234, iter=500, thin=1))\n          \n# Retrieve log-likelihood\nlogLik(mod10_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> 'log Lik.' -64691.15 (df=1434)\n```\n:::\n\n```{.r .cell-code}\n# Find perplexity\nperplexity(object=mod10_1, newdata=dtm10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 291.3196\n```\n:::\n:::\n\n\nVery good. Just a reminder: log-likelihood is always a negative number, and perplexity - a positive.\n\n## Using perplexity to find the best k\n\nTo save you time, you are given a list 'models' that contains LDA models fitted for values of `k` from 2 to 10. You will examine the current quality of fit, let LDA do more iterations on the models, and compare the outcomes.\n\n**Steps**\n\n1. Generate a plot of perplexity vs. k similar to the one you've seen in the lesson. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load data\nmodels <- readRDS(\"data/models.rds\")\n\n# Display names of elements in the list\nnames(models[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"k\"              \"model\"          \"log_likelihood\" \"perplexity\"\n```\n:::\n\n```{.r .cell-code}\n# Retrieve the values of k and perplexity, and plot perplexity vs k\nx <- sapply(models, '[[', 'k')\ny <- sapply(models, '[[', 'perplexity')\nplot(x, y, xlab=\"number of clusters, k\", ylab=\"perplexity score\", type=\"o\")\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n2. Run each model from the `models` list for an additional 100 iterations. Record the new perplexity scores. An LDA model can be retrieved using `models[[i]]$model` reference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Record the new perplexity scores\nnew_perplexity_score <- numeric(length(models))\n\n# Run each model for 100 iterations\nfor (i in seq_along(models)) {\n  mod10_2 <- LDA(x=dtm10, model=models[[i]]$model,\n             control=list(iter=100, seed=12345, thin=1))\n  new_perplexity_score[i] <- perplexity(object=mod10_2, newdata=dtm10)\n}\n```\n:::\n\n\n3. Generate a plot of new perplexity scores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specify the possible values of k and build the plot\nk <- 2:10\nplot(x=k, y=new_perplexity_score, xlab=\"number of clusters, k\", \n     ylab=\"perplexity score\", type=\"o\")\n```\n\n::: {.cell-output-display}\n![](10_topic_modeling_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n> *Question*\n> ---\n> Did running the models for additional 100 iterations change the preferred number of topics?<br>\n> <br>\n> ⬜ Yes. The new preferred value of `k` is 4.<br>\n> ✅ No. The preferred value is the same, `k=6`.<br>\n\nYes. The local minimum did not move.\n\n## Topic models fitted to novels\n\nTheory. Coming soon ...\n\n\n**1. Topic model fitted on one document**\n\nIn this chapter you will learn how to prepare documents for topic modeling when your data is one long text.\n\n**2. Analyzing one (long) novel**\n\nSo far we had chapters of a book act as individual documents, and we also built documents from the word context of a named entity.Often, especially in digital humanities, you will see applications where a topic model is fitted to one very large textual work, for instance, Moby Dick by Herman Melville.You can see an example of such kind of analysis at the JSTOR Labs Text Analyzer.Chapters are too coarse for such kind of analysis. Instead, the text is split into chunks that are long enough to capture a scene in the plot, but short enough to generate a large number of documents.We will use the chunks of one thousand words, which corresponds to about three pages of text in a novel.\n\n**3. Text chunks as chapters**\n\nWhen we worked with chapters, we had a variable containing the chapter number. We used it to group the words and generate their counts. Each chapter would correspond to a row in the document-term matrix.With text chunks, we are on our own.A convenient way to generate the surrogate chapter numbers is to sequentially number the words and then use integer division.Here are two examples showing how integer division works.\n\n**4. Generating the document number**\n\nWe can generate the document numbers with minor modification to the code.After we unnest the tokens,we get a table that contains one word per row. We add new column `word_index` which contains the row number,and then do integer division.For convenience, we add 1, otherwise the first nine hundred ninety nine words will have chapter number zero.\n\n**5. Craft vs. science**\n\nThe choice of a chunk size is very much a matter of experience rather than exact mathematical formulas.The length of the chunk may depend on the writing style of an author whose work we are analyzing.There is more than one solution to this problem:One is to try different chunk sizes.Another is to incorporate additional information about chapter boundaries, to make sure that a text chunk does not span the boundary.\n\n**6. Let's practice!**\n\nFor practice, we are going back to the text of The Byzantine Empire. Let's see what we find.\n\n## Generating chunk numbers\n\nYou are given a table `history` with two columns: `chapter` for chapter number, and `text` for chapter text. Assuming a text chunk size of 1000 words, create a new column `document_number` containing the sequential number of a chunk.\n\n**Steps**\n\n1. Unnest the tokens.\n2. Assign table row number as the word index number.\n3. Do integer division by 1000 and assign the result to a new column `document_number`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt <- history %>% \n        # Unnest the tokens\n        unnest_tokens(input=text, output=word) %>% \n        # Create a word index column\n        mutate(word_index = 1:n()) %>% \n        # Create a document number column\n        mutate(document_number = word_index %/% 1000 + 1)\n```\n:::\n\n\nGreat. Everything is correct.\n\n## Inner join and cast dtm\n\nYou have the table `t` that you created in the previous exercise. It has columns `word` and `document_number`. You also have the table `verbs` with columns `present` and `past` containing present tense and past tense forms of verbs.\n\nLike you did in the second chapter of the course, join both tables to keep only the past tense verbs, and then generate the word counts and create the document-term matrix.\n\n**Steps**\n\n1. Perform `inner_join()` using columns `word` and `past` as the keys.\n2. Count `word` using `document_number` as a grouping variable.\n3. Cast the table into a document-term matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtm11 <- t %>% \n    # Join verbs on \"word\" and \"past\"\n    inner_join(verbs, by=c(\"word\"=\"past\")) %>% \n    # Count word\n    count(document_number, word) %>% \n    # Create a document-term matrix\n    cast_dtm(document=document_number, term=word, value=n)\n```\n:::\n\n\nVery good!\n\n## Finding the best value for k\n\nYou are given object `dtm` with the document-term matrix you generated in the previous exercise. You also have a user-defined function `p(dtm=___, k=___)` that will fit an LDA topic model on matrix `dtm` for the number of topics `k` and will return the perplexity score of the model. Here is an example of calling the function for k=3: `p(dtm=dtm, k=3)`.\n\nRun the function for values of k equal to 5, 6, 7, 8, 9, and 10. Take note of the perplexity values that you receive.\n\n> *Question*\n> ---\n> Based on perplexity scores, is `k=9` better than `k=5`?<br>\n> <br>\n> ⬜ The perplexity scores are equal so both choices are good.<br>\n> ⬜ `k=5` gives a better (lower) perplexity score than `k=9`.<br>\n> ✅ `k=9` has lower perplexity and is a better choice.<br>\n\nYes, model with `k=9` has lower perplexity and is better. In chapter 2 we used k=4 as a guess, and you can see that we were very off.\n\n## Locking topics by using seed words\n\nTheory. Coming soon ...\n\n\n**1. Using seed words for initialization**\n\n\n**2. Seed for random numbers**\n\nSo far, every time we called the LDA() function, we included a \"seed\"argument in the control list. For example, we would have \"seed=12345\".This is done to make sure that the result that you obtain is the same as the result that I got when I was preparing the code.As you heard before, LDA with Gibbs sampling is a type of a probabilistic algorithm. It fits the topics by finding the best values for probabilities of words in topics, and of topics in documents. It incorporates an element of randomness into the decisions which neighborhoods of values to explore.One downside of this randomness is that topic number may change between runs. What used to be topic 1 - persons, - in our NER classifier, may no longer be when we run the algorithm tomorrow. Specifying random seed ensures that we end up with the same topic numbering.\n\n**3. Seed words**\n\nWhen we specify a seed for random number generation, we essentially specify the full chain of random numbers that LDA will receive. This may mean that we exclude some solutions. Conveniently, the implementation of Gibbs method in the topicmodels package includes an option of initialization by seed words.The benefit of this option is that we get to \"lock\" topic numbers without specifying random seed.To use it, we need to provide the weights for seed words for topics.The \"seedwords\" argument requires a matrix as an input.Each row in the matrix corresponds to a topic, and each column - to a term.The algorithm will normalize the weight values, to make sure that they sum up to 1.\n\n**4. Example**\n\nHere is an example. Consider the tiny dataset that we used before. We had five sentences, which we treated as documents. The total vocabulary size was 34 words. Dimensions of the document-term matrix were 5 rows by 34 columns.A seedwords matrix would need to have two rows, because we want to fit the model for two topics, and the same number of columns as there are tokens - thirty four.In the code, we assign 1 to column \"restaurant\" in row 1, and to column \"loans\" in row 2.\n\n**5. Example, continued**\n\nTo see the effect of seedwords, we first fit the topic model only with the numeric seed.The algorithm converges on \"loans\" becoming topic 1, and \"restaurants\" - topic 2.When we provide the seedwords argument,the topics get flipped. This happened even though we specified the same numeric seed.\n\n**6. Uses**\n\nSeedwords are useful for two reasons.First, they make operations with pre-trained models more convenient.As you saw, when you extract the results using tidy() function, there are no symbolic names assigned to topics. Finding the best model involves multiple runs of the algorithm, even for the same value of k.Seedwords give us the ability to know in advance which topic number corresponds to what words.Second, seedwords help with the speed of convergence.The algorithm finds the probabilities of words through semi-random exploration. By providing the starting point, we reduce the number of iterations needed to locate the point in the space of parameters that matches our expectations.\n\n**7. Let's practice!**\n\nLet's try in practice what we just saw.\n\n## Topics without seedwords\n\nYou are given LDA model `mod` fitted on the corpus of named entities, for `k=3`. Each document corresponds to one named entity. Your task will be to determine which topic corresponds to names, and which - to geographic entities.\n\n**Steps**\n\n1. Using `tidy`, convert matrix `gamma` to tidy table.\n2. Convert the table from tidy to wide format.\n3. Display the rows in which column `document` matches entities \" Adrianople\", \" Emperor Heraclius\", \" Daniel\", \" Africa\", and \" African\".\n\n**create mod**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Store the names of documents in a vector\nrequired_documents <- c(\" Africa\", \" Emperor Heraclius\", \n                       \" Adrianople\", \" Daniel\", \" African\")\n\n# Convert table into wide format\ntidy(mod, matrix=\"gamma\") %>% \n   spread(key=topic, value=gamma) %>% \n   # Keep only the rows with document names matching the required documents\n   filter(document %in% required_documents)\n```\n:::\n\n\nGood. Notice that Daniel and Emperor Heraclius have higher values in column 1.\n\n## Topics with seedwords\n\nYou are given a document-term matrix `dtm` for the named entities. Your task is to create a seedwords matrix, initialize it so that topic 1 would correspond to persons, topic 2 - to places, fit the model, and examine the topic probabilities for documents. As a reminder, the terms in `dtm` are the context words with suffix indicating position, e.g. \"to_l2\".\n\nAn empty matrix `seedword` has been created for you, with number of rows equal to the number of topics `k` and number of columns equal to the number of terms in `dtm`.\n\n**Steps**\n\n1. Set the column names of the matrix equal to column names of `dtm`.\n2. Set the weight for \"defeated_l2\" in topic 1 equal to 1, same for \"across_l2\" in topic 2.\n3. Fit the topic model using seedwords for `k=3`.\n4. Display the topic probabilities for documents \" Daniel\", \" Adrianople\", and \" African\".\n\n**create dtm**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up the column names\ncolnames(seedwords) <- colnames(dtm)\n\n# Set the weights\nseedwords[1, \"defeated_l2\"] = 1\nseedwords[2, \"across_l2\"] = 1\n\n# Fit the topic model\nmod <- LDA(dtm, k=3, method=\"Gibbs\",\n         seedwords=seedwords,\n         control=list(alpha=1, iter=500, seed=1234))\n\n# Examine topic assignment in the fitted model\ntidy(mod, \"gamma\") %>% spread(topic, gamma) %>% \n\\tfilter(document %in% c(\" Daniel\", \" Adrianople\", \" African\"))\n```\n:::\n\n\nGreat! By setting up seed words, we forced the model to switch topics. Topic 1 is no longer the most probable for document ' Daniel'\n\n## Final words (and more things to learn)\n\nTheory. Coming soon ...\n\n\n**1. Final words (and more things to learn)**\n\nCongratulations! You made it to the end. In case you are wondering, here are a few final words and some ideas on what you could do next.\n\n**2. Not just words**\n\nEven though we used text as data in this course, topic models are not just about words. In its core, LDA topic modeling is a clustering algorithm.It produces \"soft clustering\" - in contrast to \"hard\" clustering where we get a firm assignment of an item to a cluster, LDA topic model returns a probability.An important restriction is that LDA uses counts data - its inputs must be integer numbers.This method can be used if, for instance, you are doing customer segmentation and have counts of how many events a customer attended, or what stores they visited.With minor transformations, topic modeling can be used on non-integer data, like representing shipping routes using coordinates from ship logs.\n\n**3. Structured topic models - STM**\n\nLatent Dirichlet Allocation is not the only method to fit a topic model. Another method is VEM - variational expectation-maximization.It can be applied in situations when topic proportions are correlated with each other.In such cases the proportions follow a multivariate normal distribution,A prominent package implementing these methods is \"stm\" - short for Structured Topic Models, created by Margaret Roberts, Brandon Stewart, Brandon Lingley, and Kenneth Benoit It can estimate a regression model with topic proportions as the dependent variables and some other attributes of documents as the independent variables.To name a few of its other features, \"stm\" automatically does corpus alignment, which we had to code by hand. It implements held-out data as omitted words within the document.It is compatible with the package topicmodels with respect to the input data, and it can also use the result of LDA topic modeling as the starting point for its own model fitting.\n\n**4. Deep learning and word embeddings**\n\nThere is one interesting connection between what we did in chapter 3 and word embeddings - a method that emerged within deep learning community. The word embeddings are also known as word-to-vector models.Word-to-vector models are generated by training a neural network to predict words that occur adjacent to the target word, within a small distance from it. Plus-minus n, with n typically equal to 2 or 4.The number of words can be up to a million, but in the end each word is represented by a numeric vector of much smaller dimensions: 25, 50, a hundred, or 300 depending on a model.If you feel that this resembles the word windows that we constructed in chapter 3, you are right.There are some distinctions, though.First, word-to-vector models use very large corpora for training. It is not uncommon to see models that used over a billion words, often scraped from web documents, as input.Second, word-to-vector models do not make accommodations for multi-word entities.These models take a long time to train.You can use package \"wordVectors\" created by Ben Schmidt to experiment.\n\n**5. Go out and play!**\n\nIf this was a video in the middle of a chapter, this slide would have said \"Let's go and practice\". But we are done! And so instead, the final message to you is \"Go out and play!\" Have fun with the new skills that you learned. Bye bye!\n\n",
    "supporting": [
      "10_topic_modeling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "900cd5d3832b5c3d4c05388589638fd5",
  "result": {
    "markdown": "---\ntitle: \"Hyperparameter Tuning in R\"\nauthor: \"Joschka Schwarz\"\ntoc-depth: 2\n---\n\n\n\n\n**Short Description**\n\nUse the caret, mlr and h2o packages to find optimal hyperparameters using grid search, random search, adaptive resampling and automatic machine learning.\n\n**Long Description**\n\nFor many machine learning problems, simply running a model out-of-the-box and getting a prediction is not enough; you want the best model with the most accurate prediction. One way to perfect your model is with hyperparameter tuning, which means optimizing the settings for that specific model. In this course, you will work with the caret, mlr and h2o packages to find the optimal combination of hyperparameters in an efficient manner using grid search, random search, adaptive resampling and automatic machine learning (AutoML). Furthermore, you will work with different datasets and tune different supervised learning models, such as random forests, gradient boosting machines, support vector machines, and even neural nets. Get ready to tune!\n\n# 1. Introduction to hyperparameters\n\nWhy do we use the strange word \"hyperparameter\"? What makes it hyper? Here, you will understand what model parameters are, and why they are different from hyperparameters in machine learning. You will then see why we would want to tune them and how the default setting of caret automatically includes hyperparameter tuning.\n\n## Parameters vs hyperparameters\n\nTheory. Coming soon ...\n\n\n**1. Parameters vs hyperparameters**\n\nWelcome to this course on hyperparameter tuning in R.In this course you will learn:- what hyperparameters are and what makes them different from regular parameters- why hyperparameter tuning is an important step towards optimizing your machine learning models- and how you can apply hyperparameter tuning with the packages caret, mlr and h2o.\n\n**2. About me**\n\nMy name is Shirin and I started out as a traditional biologist. I spent a lot of time in the lab. But eventually, it became clear that what I really enjoyed above all else was working with data. That's why I spent two years as a bioinformatics Postdoc at the University of Münster in Germany before I started working as a Data Scientist for codecentric. I also write a Data Science blog where I play around with different datasets, analyses, and visualization techniques.\n\n**3. \"Hyper\"parameters vs model parameters**\n\nSo, why do we use the strange word \"hyper-parameter\"? And how are hyperparameters different from model parameters?In this chapter, we will work with a dataset about breast cancer patient samples. 10 features describe the diagnosis of benign or malignant tissue masses. Here, we use them to build a classification model.Let's have a look at a simple linear model.\n\n**4. Let's start simple: Model parameters in a linear model**\n\nA linear model models the relationship between variables by fitting a linear function. Here, we will pick two features at random: perimeter_worst &amp; fractal_dimension_mean and look at their linear relationship. We could, of course, make our linear model much more complex by adding additional features and more complex interactions, but for this purpose, we will keep it simple.The summary function will give us an overview of the fitted linear model and its results, like residuals, coefficients, and statistics.\n\n**5. Let's start simple: Model parameters in a linear model**\n\nThe results of our fitted linear model give the model parameters.Thus, model **parameters** are the **result** of model fitting.In machine learning, we use the word training instead of model fitting, so we can say that the model parameters are being fit (or found) during training.Let's look again at our linear model: here we want to find the coefficients, which we can think of as the slope and intercept of our model.\n\n**6. Coefficients in a linear model**\n\nSlope and intercept are best understood when visualized; they describe the best line through our data points.slope describes the steepness of this line, whileintercept describes the point where our line crosses the y-axis.\n\n**7. Model parameters vs hyperparameters in a linear model**\n\nOkay, you now know what model parameters are. But what about hyperparameters?Hyperparameters are defined before training, they specify HOW the training is supposed to happen, this means they define options in function calls:We can find out which options to define by looking at the arguments or formals of a function or by going to its help page.In our linear model, `method` is a hyperparameter.\n\n**8. Parameters vs hyperparameters in machine learning**\n\nSo, to recap:Model parameters were found during training, like coefficients. In machine learning these could be the weights of a neural network.Hyperparameters were defined before training; these could be the learning rate in a neural net or the number of trees in a random forest.\n\n**9. Why tune hyperparameters?**\n\nBut why would we want to tune hyperparameters?Imagine we are creating a fantasy football team: we want to find the best combination of players to maximize our chances of winning.In machine learning, we have hyperparameters - which we could think of like fantasy football players; each hyperparameter can take a range of values - just as players can be assigned different positions on the field. Just like with our fantasy football team, we want to find the best combination of hyperparameters, so that our model performs as well as possible.\n\n**10. Let's practice!**\n\nTime to put this into practice.\n\n## Model parameters vs. hyperparameters\n\n<!--\nLO: The student knows how to build a linear model and how to extract coefficients\n-->\nIn order to perform hyperparameter tuning, it is important to really understand what hyperparameters are (and what they are not). So let's look at **model parameters versus hyperparameters** in detail.\n\nNote: The Breast Cancer Wisconsin (Diagnostic) dataset has been loaded as `breast_cancer_data` for you.\n\n**Steps**\n\n1. Use this dataset to fit a **linear model** with `concavity_mean` as response and `symmetry_mean` as predictor variable.\n2. Look at the `summary()` of this linear model.\n3. Extract the **coefficients**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nlibrary(readr)\nbreast_cancer_data <- read_csv(\"data/breast_cancer_data.csv\")\n\n# Fit a linear model on the breast_cancer_data.\nlinear_model <- lm(concavity_mean ~ symmetry_mean,\n                    data = breast_cancer_data)\n\n# Look at the summary of the linear_model.\nsummary(linear_model)\n\n# Extract the coefficients.\nlinear_model$coefficients\n```\n:::\n\n\nGood job! You know how to build a linear model and how to extract coefficients.\n\n## Hyperparameters in linear models\n\n<!--\nLO: The student knows the difference between model parameters and hyperparameters\n-->\n\nNote that hyperparameters can be found in the **help section** for a function, while model parameters are part of the output of a function.\n\n> *Question*\n> ---\n> Which of the following is a **hyperparameter** in the linear model from your last exercise?<br>\n> <br>\n> ✅ Weights<br>\n> ⬜ Coefficients<br>\n> ⬜ Residuals<br>\n> ⬜ Intercept<br>\n\nCorrect! In the 'Arguments' section of the help function for `lm` we learn that weights are an optional vector to be used in the fitting process.\n\n## What are the coefficients?\n\n<!--\nLO: The student knows the difference between model parameters and hyperparameters\n-->\nTo get a good feel for the difference between fitted model parameters and hyperparameters, we are going to take a closer look at those fitted parameters: in our simple linear model, the **coefficients**.\nThe dataset `breast_cancer_data` has already been loaded for you and the linear model call was run as in the previous lesson, so you can directly access the object `linear_model`.\n\nIn our linear model, we can extract the coefficients in the following way: `linear_model$coefficients`. \nAnd we can **visualize the relationship** we modeled with a plot. \n\n**Remember**, that a linear model has the basic formula: `y = x * slope + intercept`\n\n**Steps**\n\n1. Explore the coefficients of the `linear_model` in the console.\n2. Plot the regression line with `ggplot2`.\n3. Assign the correct coefficients to `slope` and `intercept`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\n# Plot linear relationship.\nggplot(data = breast_cancer_data, \n        aes(x = symmetry_mean, y = concavity_mean)) +\n  geom_point(color = \"grey\") +\n  geom_abline(slope = linear_model$coefficients[2], \n              intercept = linear_model$coefficients[1])\n```\n:::\n\n\nPerfect! You understand that coefficients represent the slope and intercept of the fitted model formula.\n\n## Recap of machine learning basics\n\nTheory. Coming soon ...\n\n\n**1. Recap of machine learning basics**\n\nGood job, you now have a solid understanding of the differences between model parameters and hyperparameters. But before we jump into actively tuning the hyperparameters, we will briefly recap the basics of machine learning in R.We will use the caret package first, because it automatically performs a basic hyperparameter tuning for you with every training run.\n\n**2. Machine learning with caret - splitting data**\n\nBut before we look into this automatic hyperparameter tuning in caret, we need to prepare our data for training.First, we will divide our data into training and test sets.Caret makes this step easy with the `createDataPartition` function. It lets us give a class label vector as input for stratified partitioning of the data; this is important because we want to have a roughly equal ratio of classes in our training and test set. With the argument `p` we tell the function what proportion of the data should go into the training set, here 70%. The index that will be created can then be used for subsetting the original dataset.How much of the data you want to keep for training can be part of the optimization process. There are really no strict rules on how to split the data but you want to make sure that you have enough training powerand that you have a representative test set. With a small dataset such as this, 70% is a common number, but you will also often see 80 or 90% training data.\n\n**3. Train a machine learning model with caret**\n\nHere, I will not go into additional steps of the machine learning workflow, like feature engineering, preprocessing, normalization, balancing classes, etc. Just keep in mind that in a real-world scenario, you would at least want to think about incorporating these steps into your workflow.Our validation scheme is defined in the `trainControl()` function: we will do 5 times 3 repeated cross-validation, which means repeating 3-fold cross-validation 5 times. This scheme is then given as an argument in the `train()` function.In `caret` we can train machine learning models with a large number of different algorithms; we define this with the argument `method` in the `train()` function. Here, we will train a Random Forest model, which is abbreviated `rf`.`train()` also wants to know which data and which features to use. Our dataset is the training set that we created before. The features are given with a formula: the class or response variable (here **diagnosis**) is written before and features after the tilde. For features, we write a dot here, which indicates that we want to use all remaining columns as features in our model.In addition, I want to know how long my model took to train. For this, I am using the tictoc package, which will return the runtime between tic and toc.As we can see, our model took about 1.4 seconds to train.\n\n**4. Automatic hyperparameter tuning in caret**\n\nHere is the random forest model we just trained. In the output we can already see hyperparameter tuning in action as caret performs it automatically with different options for the hyperparameter mtry --&gt; you will learn more about that in the next lesson!What's important to note here is that caret compares different hyperparameters on the training and validation data only.Do NOT be tempted to measure your model performance on the test data during hyperparameter tuning as that would give you an overly optimistic and biased performance evaluation!\n\n**5. Let's start modeling!**\n\nNow, it's your turn to start modeling!\n\n## Machine learning with caret\n\n<!--\nLO: The student knows how to split data into training and test sets for modeling\n-->\n<!--\nLO: The student knows how to use cross-validation in caret\n-->\n<!--\nLO: The student knows how to train a machine learning model with caret\n-->\nBefore we can train machine learning models and tune hyperparameters, we need to **prepare the data**.\n\n**Steps**\n\n1. Use the `caret` package to create an index with 70% of the `breast_cancer_data` to create a **training set** and **stratify the partitions** by the response variable `diagnosis`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(caret)\n\n# Create partition index\nindex <- createDataPartition(breast_cancer_data$diagnosis, p = 0.7, list = FALSE)\n```\n:::\n\n\n2. Use the index you created in the previous step to **partition** the `breast_cancer_data` in training and test sets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset `breast_cancer_data` with index\nbc_train_data <- breast_cancer_data[index, ]\nbc_test_data  <- breast_cancer_data[-index, ]\n```\n:::\n\n\n\n\n3. Define a **repeated cross-validation** scheme for `caret` with 5 folds and 3 repeats.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define 3x5 folds repeated cross-validation\nfitControl <- trainControl(method = \"repeatedcv\", number = 5, repeats = 3)\n```\n:::\n\n\n4. Use the `caret` package to **train a Stochastic Gradient Boosting model** and add the **repeated cross-validation** scheme that you defined in the last step to the `train` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required package: gbm\n\n# Run the train() function\ngbm_model <- train(diagnosis ~ ., \n                   data      = bc_train_data, \n                   method    = \"gbm\", \n                   trControl = fitControl,\n                   verbose   = FALSE)\n\n# Look at the model\ngbm_model\n```\n:::\n\n\nVery good! You know the basics of building models with caret.\n\n## Resampling schemes\n\nIn the previous exercise, you defined a 3x5 folds repeated cross-validation resampling scheme with the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitControl <- trainControl(method = \"repeatedcv\", number = 5, repeats = 3)\n```\n:::\n\n\n> *Question*\n> ---\n> Which of the following is **NOT** a valid resampling method in `caret`?<br>\n> <br>\n> ⬜ `boot`<br>\n> ✅ `adaboost`<br>\n> ⬜ `cv`<br>\n> ⬜ `LGOCV`<br>\n\nCorrect! `adaboost` is an implementation of the AdaBoost optimization algorithm from Freund and Shapire (1997) and not a resampling scheme.\n\n## Hyperparameter tuning in caret\n\nTheory. Coming soon ...\n\n\n**1. Hyperparameter tuning with caret**\n\nCaret makes hyperparameter tuning very easy. By default, it performs automatic tuning for you with every training run. But you can also manually define how you want to tune your models.\n\n**2. Automatic hyperparameter tuning in caret**\n\nHere you see the random forest model with the `rf` method from before. In the output we see that we only have one hyperparameter to tune:`mtry` defines the number of variables that are randomly sampled as candidates at each split. caret automatically tried three different `mtry` values and includes the performance of each with the output. The best model is chosen with the metric `accuracy`, which in this case was for mtry = 6.\n\n**3. Hyperparameters are specific to model algorithms**\n\nDifferent algorithms have different hyperparameters. You might be wondering how you would know which hyperparameters you can tune with these different `method` in caret.If you know the model abbreviation, you can use the modellookup function.But the easiest way is to use the online documentation for caret. Click this link on the slides to go to the page.There, you will find an overview of the different algorithms you can set as `method` in the train function. This table includes the name of the model, the string you need to put into the train function, whether it can be used for classification or regression and what the original R package of the implementation is.But most importantly, you will find which hyperparameters can be tuned. Here, I will not discuss the mathematics behind hyperparameters, instead, I will focus on HOW to perform the hyperparameter tuning.\n\n**4. Hyperparameters in Support Vector Machines (SVM)**\n\nLet's change things up a bit and build a Support Vector Machine with Polynomial Kernel similar to the Random Forest model from before: this time I am using the `svmPoly` model. And I am again calculating the training time.\n\n**5. Hyperparameters in Support Vector Machines (SVM)**\n\nWhen we examine the model object again, we see that this time `caret` performed a more complex hyperparameter tuning. If we have more than one hyperparameter to tune, `train` automatically creates a grid of tuning parameters.By default, caret tries all possible combinations of three hyperparameters, in our model:- degree being 1, 2, or 3- scale being 0.001, 0.01 or 0.1- and c being 0.25, 0.5 or 1Because the output shows the performance for every possible combination of hyperparameters, the output is too long to fit on this slide and I am only showing the best model with degree of 1, scale of 0.1 and c equal to 1.\n\n**6. Defining hyperparameters for automatic tuning**\n\nWe can also set the option `tuneLength` to specify the number of different values to try for each hyperparameter, for example 5. Now, caret tries all possible combinations of five hyperparameters:- degree being 1, 2, 3, 4 or 5- scale being 1e-03, 1e-02, 1e-01, 1e+00 and 1e+01- and c being 0.25, 0.5, 1, 2 or 4The best model now has degree, scale and c of 1.\n\n**7. Manual hyperparameter tuning in caret**\n\nOf course, you could also manually try out different hyperparameters. This, we can do with the option `tuneGrid()`, to which we can feed a grid of hyperparameters. This grid is defined with the `expand.grid()` function.If we use that function, we need to define all hyperparameters. Let's see what happens if we set the degree to 4 and keep scale and c at 1 and retrain the model.\n\n**8. Manual hyperparameter tuning in caret**\n\nThis time, we only trained with one combination of hyperparameters, so our output gives the performance for these hyperparameters only!\n\n**9. It's your turn!**\n\nNow it's your turn to apply simple hyperparameter tuning in caret.\n\n## Hyperparameters in Stochastic Gradient Boosting\n\n<!--\nLO: The student knows how to find out which hyperparameters can be tuned in a given caret method\n-->\nIn the previous lesson, you built a Stochastic Gradient Boosting model in caret. \nA similar model as the one from before has been preloaded as `gbm_model`. \n\n> *Question*\n> ---\n> In order to optimize this model, you want to **tune its hyperparameters**. Which of the following is NOT a hyperparameter of the `gbm` method?<br>\n> <br>\n> ⬜ n.trees<br>\n> ⬜ n.minobsinnode<br>\n> ✅ na.action<br>\n> ⬜ interaction.depth<br>\n\nCorrect! `na.action` is not a hyperparameter; it is a function to specify the action to be taken if NAs are found.\n\n## Changing the number of hyperparameters to tune\n\n<!--\nLO: The student knows how to change the number of hyperparameters that are tuned automatically by `caret`\n-->\nWhen we examine the model object closely, we can see that `caret` already did some **automatic hyperparameter** tuning for us: `train` automatically creates a **grid of tuning parameters**. By default, if `p` is the number of tuning parameters, the grid size is 3^p. But we can also **specify the number** of different values to try for each hyperparameter.\n\n**Steps**\n\n1. Test **four** different values for each hyperparameter with automatic tuning in `caret`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(tictoc)\n\n# Set seed.\nset.seed(42)\n# Start timer.\ntic()\n# Train model.\ngbm_model <- train(diagnosis ~ ., \n                   data       = bc_train_data, \n                   method     = \"gbm\", \n                   trControl  = trainControl(method = \"repeatedcv\", number = 5, repeats = 3),\n                   verbose    = FALSE,\n                   tuneLength = 4)\n# Stop timer.\ntoc()\n```\n:::\n\n\nGreat! You can now perform a simple hyperparameter-tuning with caret.\n\n## Tune hyperparameters manually\n\n<!--\nLO: The student knows how to manually define hyperparameters in caret\n-->\nIf you already know which hyperparameter values you want to set, you can also **manually define** hyperparameters as a **grid**. Go to `modelLookup(\"gbm\")` or search for `gbm` in the <a href=\"https://topepo.github.io/caret/available-models.html\">list of available models in caret</a> and check under **Tuning Parameters**.\n\n**Steps**\n\n1. Define the following **hyperparameter grid** for a Gradient Boosting Model: the number of trees as 200; the tree complexity as 1; the learning rate as 0.1 and the minimum number of training set samples in a node to commence splitting as 10.\n2. Apply the grid to the `train()` function of `caret`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define hyperparameter grid.\nhyperparams <- expand.grid(n.trees           = 200, \n                           interaction.depth = 1, \n                           shrinkage         = 0.1, \n                           n.minobsinnode    = 10)\n\nset.seed(42)\n# Apply hyperparameter grid to train().\ngbm_model <- train(diagnosis ~ ., \n                   data      = bc_train_data, \n                   method    = \"gbm\", \n                   trControl = trainControl(method = \"repeatedcv\", number = 5, repeats = 3),\n                   verbose   = FALSE,\n                   tuneGrid  = hyperparams)\n```\n:::\n\n\nGreat job! You have made it through the first chapter. Now, you will learn how to use more advanced methods to optimize hyperparameters.\n\n# 2. Hyperparameter tuning with caret\n\nIn this chapter, you will learn how to tune hyperparameters with a Cartesian grid. Then, you will implement faster and more efficient approaches. You will use Random Search and adaptive resampling to tune the parameter grid, in a way that concentrates on values in the neighborhood of the optimal settings. \n\n## Hyperparameter tuning in caret\n\nTheory. Coming soon ...\n\n**1. Hyperparameter tuning in caret**\n\nWelcome back to Chapter 2. Let's dive deeper into how to perform hyperparameter tuning with caret.\n\n**2. Voter dataset from US 2016 election**\n\nThe dataset we'll be working with is from a survey about the 2016 US presidential election. We will use the attribute \"turnout16_2016\" to predict whether or not a person voted in that election.\n\n**3. Let's train another model with caret**\n\nLet's train another machine learning model with caret using gradient boosting with repeated cross-validation. Keep in mind that in reality, you would want to address the problem of having unbalanced classes but let's focus on hyperparameter tuning for now. Our model takes about 33 seconds to run.\n\n**4. Let's train another model with caret**\n\nWhen we explore our model, we see that caret tuned interaction depth and the number of trees based on default values. For a quick base-line model, this is fine but what if we wanted to manually define hyperparameters?\n\n**5. Cartesian grid search with caret**\n\nIn the previous chapter, you used the `expand.grid()` function to manually define single values for every hyperparameter. The same function can be used to define a grid of hyper-parameters because it creates a grid of all possible combinations of hyperparameters given!For the number of trees and tree complexity, we'll compare different values. Shrinkage and the minimum number of observations per node is kept constant.We can now train our model just as before. But this time, we will use the tuneGrid parameter and feed our grid to it.If we perform Cartesian grid search, every combination of hyperparameters in our grid will be evaluated.You see that this model took much longer to train. You will see in the following examples that hyperparameter tuning takes some time and computational power - so be prepared to exercise some patience!\n\n**6. Cartesian grid search with caret**\n\nThe output will look similar to before with automatic hyperparameter tuning. We again get a table with accuracy and kappa values for all tested combinations of hyperparameters and a final result written below this table.Our model performance did not improve compared to before but we only tested a small range of hyperparameter values. In your real-world projects, you would test a much larger range of values but here, we will focus on learning the concepts behind hyperparameter tuning techniques.\n\n**7. Plot hyperparameter models**\n\nWe can also plot our hyperparameters with the plot function and define the metric and plot type we want to visualize. Per default, we will see accuracy and line plots. Every line represents a different hyperparameter for the maximum tree depth. The colors of the lines correspond to this as well. On the x-axis, we see the number of boosting iterations, which comes from the hyperparameter n.trees that we defined to be either 100, 200 or 250. And the y-axis shows the accuracy of the model given these hyperparameter combinations. Alternatively, we can plot the Kappa metrics and show them as a heatmap. Kappa is another metric used to evaluate the performance of classification models. It compares an Observed Accuracy with an Expected Accuracy. Kappa values need to be considered in the context of the problem but generally, we want to achieve high Kappa values. The Kappa values are shown on the color scale, while the x-axis shows the number of trees and the y-axis the max tree depth.Here, our Kappa values don't look very good - the reason is that our data was strongly unbalanced, so the accuracy for always assigning the majority class will already be very high. So, we can conclude that while having pretty good accuracy, our model did not in fact perform much better than random.\n\n**8. Test it out for yourself!**\n\nAlright, enough theory - go test it out yourself!\n\n## Finding hyperparameters\n\nFinding out **which** hyperparameters you can tune with a given algorithm or function is the most important prerequisite for actually tuning your models!\n\n> *Question*\n> ---\n> Which **hyperparameters** can you tune with a simple **Generalized Linear Model** that uses the `glm` method?<br>\n> <br>\n> ⬜ tau<br>\n> ⬜ alpha, lambda<br>\n> ✅ None<br>\n> ⬜ cost, Loss<br>\n\nCorrect! A simple glm has no hyperparameters that can be tuned.\n\n## Cartesian grid search in caret\n\n<!--\nLO: The student knows how to define a Cartesian grid of hyperparameters in caret\n-->\nIn chapter 1, you learned how to use the `expand.grid()` function to manually define hyperparameters. The same function can also be used to **define a grid of hyperparameters**. \n\nThe `voters_train_data` dataset has already been preprocessed to make it a bit smaller so training will run faster; it has now 80 observations and balanced classes and has been loaded for you. And the `trainControl` object has been defined with repeated cross-validation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nvoters_train_data <- read_csv(\"data/voters_train_data.csv\")\n\nfitControl <- trainControl(method = \"repeatedcv\",\n                           number = 3,\n                           repeats = 5)\n```\n:::\n\n\n**Steps**\n\n1. Define a **Cartesian grid** of Support Vector Machine hyperparameters with the following combinations: `degree` should be 1, 2, or 3, `scale` should be 0.1, 0.01 or 0.001 and `C` should be held constant at 0.5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define Cartesian grid\nman_grid <- expand.grid(degree = c(1, 2, 3), \n                        scale  = c(0.1, 0.01, 0.001), \n                        C      = 0.5)\n```\n:::\n\n\n2. Use the Cartesian grid you defined in the previous step to train a **Support Vector Machines with Polynomial Kernel** in `caret`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required package: kernlab\n\n# Start timer, set seed & train model\ntic()\nset.seed(42)\nsvm_model_voters_grid <- train(turnout16_2016 ~ ., \n                   data      = voters_train_data, \n                   method    = \"svmPoly\", \n                   trControl = fitControl,\n                   verbose   = FALSE,\n                   tuneGrid  = man_grid)\ntoc()\n```\n:::\n\n\n> *Question*\n> ---\n> Explore the `svm_model_voters_grid` model object: **Which hyperparameter combination was best?**<br>\n> <br>\n> ⬜ degree 3 & scale 0.010<br>\n> ✅ degree 1 & scale 0.100]<br>\n> ⬜ degree 1 & scale 0.001<br>\n> ⬜ degree 2 & scale 0.100<br>\n\nCorrect. This was the best hyperparameter combination in our model.\n\n## Plot hyperparameter model output\n\n<!--\nLO: The student knows how to plot the hyperparameter tuning results\n-->\nIn the previous exercise, you defined a **Cartesian grid of hyperparameters** and used it to train a Support Vector Machine model.\nThe same code as before has been run in the background, so you can directly work with the `svm_model_voters_grid` model object. The `caret` package has also been loaded.\n\n**Steps**\n\n1. **Plot** the model object with **default arguments**: Accuracy and line-plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot default\nplot(svm_model_voters_grid)\n```\n:::\n\n\n2. Add another plot where you **plot Kappa values** and use a **level-plot**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot Kappa level-plot\nplot(svm_model_voters_grid, metric = \"Kappa\", plotType = \"level\")\n```\n:::\n\n\nVery good! Plotting is generally a good way to explore your model output and hyperparameter tuning results.\n\n## Grid vs. Random Search\n\nTheory. Coming soon ...\n\n\n**1. Grid vs. Random Search**\n\nDefining a hyperparameter grid is easy, right? So let's learn even more about it.\n\n**2. Grid search continued**\n\nWhat we did in the previous lesson was **fixing** the learning rate and the minimum number of training set samples in a node to commence splitting. For the number of trees and for tree complexity, we compared different options.Then we trained a model with repeated cross-validationand gradient boosting.\n\n**3. Grid search with hyperparameter ranges**\n\nBut what if we don't want to define a set of distinct values for each hyperparameter but instead want to define a range of values?This is easy as well, just use the seq() function and define at which value you want to start, at which value to stop and by what increments you want to go between start and stop.Here you see that you can now end up with non-integer values in your grid and that the grid will quickly grow much bigger.\n\n**4. Grid search with many hyperparameter options**\n\nLet's see what happens if we use this grid in a gradient boosting model the same way we used the Cartesian grid before - as input to the tunegrid argument in train. 240 seconds to train! I'm sure you can see how quickly you would end up with a training that takes forever to run if you keep increasing the hyperparameters you want to tune!\n\n**5. Cartesian grid vs random search**\n\nSo far, we have always compared all possible combinations of hyperparameters in our predefined grid. This method was called Cartesian grid search.Here, you see a different way to plot the hyperparameter tuning results: instead of using the base R plot function, you can also feed the model object to the ggplot function and see a similar line plot of hyperparameter combinations and their corresponding accuracies.Even though we want to compare as many hyperparameters as possible in order to find the most optimal combination for our model, using Cartesian grid search will become slow and computationally expensive very quickly.So let's look at a faster alternative - random search.With random search we no longer test all possible combinations of different hyperparameters; instead we will randomly pick a specified number of hyperparameter combinations by chance and only evaluate those regarding model performance.\n\n**6. Random search in caret**\n\nTo use random search, another option is available in caret's trainControl function called search. Possible inputs to this argument are \"grid\" and \"random\". The built-in models contained in caret contain code to generate random tuning parameter combinations. The total number of unique combinations is specified by the tuneLength option in train. We already got to know tuneLength in the first chapter, where we used to to define the number of tuning parameters to compare in caret's automatic tuning function. There, all possible combinations of these hyperparameters were compared. Here we use it to define how many randomly picked hyperparameter combinations to evaluate. 5 is of course too few and in reality, you would want to test at least 100. But again, for demonstration purposes we go with the time-saving version, here,which still takes almost 1 minute to train.\n\n**7. Random search in caret**\n\nThis is how the model output looks like now: 5 randomly picked hyperparameter combinations and their corresponding accuracy and kappa values are shown.And - as always - the final values are given in the text at the bottom of the printed output.One important thing to note is this: in caret, random search can NOT be combined with grid search! This means that the tunelength argument cannot be used to sample from a customized grid.\n\n**8. Let's get coding!**\n\nAlright, now it's your turn to try out what you've learned!\n\n## Grid search with range of hyperparameters\n\n<!--\nLO: The student knows how to define a Cartesian grid with a range of hyperparameters in caret\n-->\nIn chapter 1, you learned how to use the `expand.grid()` function to manually define a set of hyperparameters. The same function can also be used to define a **grid with ranges** of hyperparameters. \n\n**Steps**\n\n1. Define a **grid** with the neural network hyperparameter **size ranging from 1 to 5** with a **step-size of 1**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the grid with hyperparameter ranges\nbig_grid <- expand.grid(size = seq(from = 1, to = 5, by = 1),\n                        decay = c(0, 1))\nbig_grid\n```\n:::\n\n\n2. Specifically define the `trainControl` function to perform **grid search**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train control with grid search\nfitControl <- trainControl(method  = \"repeatedcv\",\n                           number  = 3,\n                           repeats = 5,\n                           search  = \"grid\")\n```\n:::\n\n\n3. Train a **regular Neural Network** in caret.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required package: nnet\n\n# Train neural net\ntic()\nset.seed(42)\nnn_model_voters_big_grid <- train(turnout16_2016 ~ ., \n                   data      = voters_train_data, \n                   method    = \"nnet\", \n                   trControl = fitControl,\n                   # verbose   = FALSE,\n                   trace = FALSE)\ntoc()\n```\n:::\n\n\n4. And finally: feed the `big_grid` to this Neural Network for tuning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the grid with hyperparameter ranges\nbig_grid <- expand.grid(size = seq(from = 1, to = 5, by = 1), decay = c(0, 1))\n\n# Train control with grid search\nfitControl <- trainControl(method = \"repeatedcv\", number = 3, repeats = 5, search = \"grid\")\n\n# Train neural net\ntic()\nset.seed(42)\nnn_model_voters_big_grid <- train(turnout16_2016 ~ ., \n                   data      = voters_train_data, \n                   method    = \"nnet\", \n                   trControl = fitControl,\n                   # verbose   = FALSE,\n                   trace     = FALSE,\n                   tuneGrid  = big_grid)\ntoc()\n```\n:::\n\n\nGreat! You understood the complete workflow of defining a hyperparameter grid and using it in the caret `train()` function.\n\n## Find train() option for random search\n\nIn the video for this chapter, I showed you how to perform a grid search or random search with `caret`.\n\n> *Question*\n> ---\n> Which **argument** do you need to set in combination with `trainControl(search = \"random\")` in order to perform **random search**?<br>\n> <br>\n> ⬜ method<br>\n> ✅ tuneLength<br>\n> ⬜ preProcess<br>\n> ⬜ tuneGrid<br>\n\nCorrect! Tune length defines the number of (randomly sampled) tuning parameter combinations to compare.\n\n## Random search with caret\n\n<!--\nLO: The student knows how to perform random hyperparameter search in caret\n-->\nNow you are going to perform a **random search** instead of grid search!\n\nAs before, the small `voters_train_data` dataset has been loaded for you, as have the `caret` and `tictoc` packages.\n\n**Steps**\n\n1. Define a training control object with **random search**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train control with random search\nfitControl <- trainControl(method  = \"repeatedcv\",\n                           number  = 3,\n                           repeats = 5,\n                           search  = \"random\")\n```\n:::\n\n\n2. Compare **six random hyperparameter combinations** in the neural network below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test 6 random hyperparameter combinations\ntic()\nnn_model_voters_big_grid <- train(turnout16_2016 ~ ., \n                   data       = voters_train_data, \n                   method     = \"nnet\", \n                   trControl  = fitControl,\n                   # verbose    = FALSE,\n                   trace      = FALSE,\n                   tuneLength = 6)\ntoc()\n```\n:::\n\n\nYou just performed random search with hyperparameter values that were picked by `caret`.\n\n> *Question*\n> ---\n> How could you **define your own grid** of hyperparameter values from which to sample randomly?<br>\n> <br>\n> ⬜ By setting both arguments `tuneGrid` and `tuneLength` in `caret::train`.<br>\n> ⬜ By changing the `method` argument in `trainControl`.<br>\n> ✅ In `caret`, it is not possible to perform a random search on a defined grid.<br>\n> ⬜ By setting the `randomGrid` argument in `caret::train`.<br>\n\nCorrect! In `caret`, it is not possible to perform a random search on a defined grid. You will learn how to do this with other packages in the next two chapters.\n\n## Adaptive resampling\n\nTheory. Coming soon ...\n\n**1. Adaptive resampling**\nGood job completing the exercises! You have now seen how hyperparameter grids work when tuning your models. However, both grid and random search are not very efficient - nor fast! Adaptive Resampling is a technique that can be used instead.\n\n**2. What is Adaptive Resampling?**\nWith grid search and random search the performance of different hyperparameter combinations is evaluated. Which combination wins, e.g. which has the highest accuracy, is determined at the very end. That way, many of the tested combinations will perform badly. And testing hyperparameter combinations will continue, even if the best combination has already been found. With adaptive resampling, hyperparameter combinations are resampled with values that are close to combinations that performed well and combinations that are sub-optimal will not be tested at all. This way, each round of tested hyperparameters will zero in on the optimal combination of hyperparameters. This makes adaptive resampling faster and more efficient. A detailed explanation of adaptive resampling and how it is implemented in caret can be found in this paper by Max Kuhn. You can again click on this link to get to the paper.\n\n**3. Adaptive resampling in caret**\nAdaptive resampling is implemented in caret, so it is very easy for us to use. We simply need to modify our trainControl function with the following settings: As method we define adaptive_cv to use adaptive resampling with cross-validation. By default, a \"grid\" search would be performed but here, we define search as random. Then we define the adaptive resampling process with - min, which determines the minimum number of resamples used for each hyperparameter. Per default, caret uses a min value of 5. The larger we set min, the slower the resampling process will be but we increase our likelihood of finding the optimal hyperparameter combination. - alpha defines the confidence level that we want to use to remove hyperparameters. Usually, changing alpha does not influence the result that much. - with method, we set the resampling method. It can be either a simple linear model, as we use here with gls. Or we could use a Bradley-Terry model, which would be advised if we have a large number of hyperparameters to test or if we expect our model accuracy to be close to one and not vary much between hyperparameter combinations. It is therefore useful for fine-tuning models that are already pretty good. - and finally, complete let's us specify whether we want to generate a full resampling set if an optimal solution is found before resampling is completed. Setting complete as FALSE would save time and we would still get the optimal combination of hyperparameters - but we won't know the final estimated performance measure for our model. This is how the final traincontrol function will look like for adaptive resampling.\n\n**4. Adaptive resampling in caret**\nWe can now use our as such defined trainControl with carets train function - just as we did before. What we additionally need to define in train is again the setting tuneLength, which will define the maximum number of hyperparameter combinations we want to compare. Here I'll be using 7, which is, of course, again a rather low number. In your real-world experiments, you will most likely want to compare at least 100 combinations. But you see that even an efficient method like adaptive resampling still takes time to perform its magic.\n\n**5. Adaptive resampling**\nHere you see the lower part of the output of our model trained with adaptive resampling. It has again the same structure as our caret models from before. And we also get the final values used, which give an accuracy of 96% but a low Kappa value.\n\n**6. Let's get coding!**\nNow it's your turn!\n\n## Advantages of Adaptive Resampling\n\nYou have heard a lot about advanced tuning with **Adaptive Resampling** in `caret` in the video you just saw.\n\n> *Question*\n> ---\n> Which of the following statements about the Adaptive Resampling technique is **NOT true**?<br>\n> <br>\n> ✅ Adaptive Resampling will find better hyperparameter combinations than grid or random search.<br>\n> ⬜ Adaptive Resampling is faster than cartesian grid search.<br>\n> ⬜ With Adaptive Resampling hyperparameter combinations are resampled near values that perform well.<br>\n> ⬜ Adaptive Resampling is more efficient than grid and random search.<br>\n\nCorrect! Adaptive Resampling does not necessarily find better hyperparameter combinations, it is just more efficient at searching.\n\n## Adaptive Resampling with caret\n\n<!--\nLO: The student knows how to perform Adaptive Resampling in caret\n-->\nNow you are going to train a model on the voter's dataset using **Adaptive Resampling**!\n\nAs before, the small `voters_train_data` dataset has been loaded for you, as have the `caret` and `tictoc` packages.\n\n**Steps**\n\n1. Define a `trainControl()` function for **performing Adaptive Resampling** with 3x3 repeated cross-validation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define trainControl function\nfitControl <- trainControl(method  = \"adaptive_cv\",\n                           number  = 3, \n                           repeats = 3)\n```\n:::\n\n\n2. Change the **resampling scheme** from the default grid method to random search for Adaptive Resampling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define trainControl function\nfitControl <- trainControl(method  = \"adaptive_cv\",\n                           number  = 3, \n                           repeats = 3,\n                           search  = \"random\")\n```\n:::\n\n\n3. Define the **Adaptive Resampling options** *minimum number of resamples* as 3 and use the *Bradley Terry* method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define trainControl function\nfitControl <- trainControl(method   = \"adaptive_cv\",\n                           number   = 3, \n                           repeats  = 3,\n                           adaptive = list(min = 3, alpha = 0.05, method = \"BT\", complete = FALSE),\n                           search   = \"random\")\n```\n:::\n\n\n4. Change the **maximum number of tuning parameter combinations** that will be generated by random search from its default of 3 to 6 and train the **Neural Network**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required package: BradleyTerry2\n\n# Start timer & train model\ntic()\nsvm_model_voters_ar <- train(turnout16_2016 ~ ., \n                   data       = voters_train_data, \n                   method     = \"nnet\", \n                   trControl  = fitControl,\n                   # verbose  = FALSE,\n                   trace      = FALSE,\n                   tuneLength = 6)\ntoc()\n```\n:::\n\n\nGood job! You have mastered the final hyperparameter tuning method in caret: Adaptive Resampling!\n\n# 3. Hyperparameter tuning with mlr\n\nHere, you will use another package for machine learning that has very convenient hyperparameter tuning functions. You will define a Cartesian grid or perform Random Search, as well as advanced techniques. You will also learn different ways to plot and evaluate models with different hyperparameters.\n\n## Machine learning with mlr\n\nTheory. Coming soon ...\n\n\n**1. Machine learning with mlr**\n\nIn order to fully understand the concepts of hyperparameter tuning, we will look at implementations in different contexts and packages. Here, I will introduce the package mlr.\n\n**2. The mlr package**\n\nmlr is another very popular framework for machine learning in R. It provides methods for a number of algorithms and machine learning tasks, including supervised classification and regression.mlr also allows you to easily perform hyperparameter tuning.However, mlr has a slightly different way of defining machine learning tasks. Therefore, we will use this lesson to go over the basics of machine learning with mlr before we dive into hyperparameter tuning.The workflow for training models with mlr follows three steps:First, you need to define the task, then you define the learner and only then can you fit the model. We will go over each step in detail.You can follow this link to find out more about mlr and how it works.\n\n**3. New dataset: User Knowledge Data**\n\nThe dataset we'll be working with in this chapter is a real-world dataset on students' knowledge status about the subject of Electrical DC Machines.It consists of 150 observations and 6 variables. The five features are - STG (The degree of study time for goal object materials)- SCG (The degree of repetition for goal object materials) - STR (The degree of study time for related objects with goal object) - LPR (The exam performance for related objects with goal object)- and PEG (The exam performance for goal objects)The response variable UNS (The knowledge level of the student) can be one of three classes: Low, Middle or high.\n\n**4. Tasks in mlr for supervised learning**\n\nTasks define the data and - in case of supervised learning - the response variable or target. mlr has a number of different tasks you can choose from:regressionclassificationmulti-label classificationand cost-sensitive classificationHere, we'll focus on tasks for supervised learning.To create a classification task, we are using the makeClassifTask function. If you want to know which task functions you can define, either check the mlr manual or - if you are using RStudio - start typing make in your console and autocomplete will suggest different functions.\n\n**5. Learners in mlr**\n\nNext, we'll need to define our learner. You can find out which learners you can choose from by calling the listlearners function. This will return a table of available learners and the name you will need to use as class if you want to create a learner object for it.By convention, all classification learners start with “classif.”, all regression learners with “regr.” and all multilabel classification learners start with “multilabel.”.Here, we want to create a learner for a deep neural network from the h2o package.We create a new object with the makelearner function and \"classif.h2o.deeplearning\". In this function, we could also define whether we wanted labels or predictions as output, set hyperparameters, and more. Check the help function for makelearner to find out more.Sometimes, you might have classification models where your target column contains more or fewer factor levels than the target column in your test or validation data. This can lead to problems but if you set fix.factors.prediction to TRUE a factor level for missing data is added.And you can also define whether to return predicted labels or probabilities.\n\n**6. Model fitting in mlr**\n\nFinally, we can take our task and our learner and use them with the train function of mlr to fit our model.We are again using the tictoc package to calculate how long the runtimes are for our models: Here, the training took about 4 seconds.\n\n**7. Let's practice!**\n\nAlright, now it's your turn to try out mlr!\n\n## Machine Learning with mlr\n\nNote: The `mlr` package is already loaded.\n\n> *Question*\n> ---\n> Which of the following is **NOT** a step in the `mlr` modelling workflow? <br>\n> <br>\n> ⬜ Defining a learner.<br>\n> ⬜ Defining a task.<br>\n> ⬜ Fitting a model.<br>\n> ✅ Converting the response variable to a factor.<br>\n\nCorrect! Converting the response variable to a factor is not a necessary step of the `mlr` workflow.\n\n## Modeling with mlr\n\n<!--\nLO: The student knows how to train a machine learning model with mlr\n-->\nAs you have seen in the video just now, `mlr` is yet another popular machine learning package in R that comes with many functions to do hyperparameter tuning. Here, you are going to go over the **basic workflow** for training models with `mlr`.\n\nThe `knowledge_train_data` dataset has already been loaded for you, as have the packages `mlr`, `tidyverse` and `tictoc`.\n**Remember** that starting to type in the console will suggest autocompleting options for functions and packages.\n\n**Steps**\n\n1. Create a **regular classification task** with the `knowledge_train_data` and target `UNS`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load package\nlibrary(mlr)\n\n# Load data\nknowledge_train_data <- read_csv(\"data/knowledge_train_data.csv\")\n\n# Create classification task\ntask <- makeClassifTask(data   = knowledge_train_data, \n                        target = \"UNS\")\n```\n:::\n\n\n2. Ask for a **list of all learners** you can use with mlr. Note that you are converting the output to a data frame and selecting only the columns `class`, `short.name` and `package` so that the output fits the page.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load package\nlibrary(dplyr)\n\n# Call the list of learners\nlistLearners() %>%\n as.data.frame() %>%\n select(class, short.name, package) %>%\n filter(grepl(\"classif.\", class))\n```\n:::\n\n\n3. Find the correct classifier for **Random Forest** in the previous output and **build a learner** with this `randomForest` classifier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create learner\nlrn <- makeLearner(\"classif.randomForest\")\n```\n:::\n\n\n4. In your learner, change the following settings from the default: have **class probabilities** as output and add a **factor for missing data**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create learner\nlrn <- makeLearner(\"classif.randomForest\", \n                   predict.type = \"prob\", \n                   fix.factors.prediction = TRUE)\n```\n:::\n\n\nGood job! You successfully trained a Random Forest with mlr. Now, let's look into hyperparameter tuning.\n\n## Grid and random search with mlr\n\nTheory. Coming soon ...\n\n\n**1. Grid and random search with mlr**\n\nNow that you have the basics of machine learning with the mlr package fresh on your mind, let's look into hyperparameter tuning with grid and random search in mlr.\n\n**2. Hyperparameter tuning with mlr**\n\nFor hyperparameter tuning in mlr you have to define three things:- the search space, this means the hyperparameter values you want to compare and tune- the tuning method, which could be grid or random search- the resampling schemeLet's look at each step in turn.\n\n**3. Defining the search space**\n\nFirst, we will define the hyperparameter search space for our learner.To do this, we use the makeParamSet function. Within this main function, we have several support functions for defining different types of parameter spaces:- makeNumericParam let's us define numeric ranges between specified values- makeIntegerParam does the same just with integers- makeDiscreteParam is for defining discrete lists of values to search- makeLogicalParam let's us define TRUE/FALSE values- and makeDiscreteVectorParam for vectors of discrete parametersNow, let's look at what hyperparameters we have in a deep learning model.If we enter the learner class into the getParamSet function, it will return a table with hyperparameters for this function and tell us what type they are, what default values will be set, their lower and upper boundaries, if they are tunable, plus some additional information.\n\n**4. Defining the search space**\n\nSo, let's take the makeParamSet function and create entries for the hyperparameters hidden, activation and l1 and l2.\n\n**5. Defining the tuning method**\n\nNext, we define the tuning method. The two basic versions you can choose from are grid search, where every combination of hyperparameters will be compared, and random search, where a subset of our specified values will be tested randomly.The two respective functions are makeTuneControlGrid and makeTuneControlRandom. When we look at the objects we created with these two functions, it will print a summary to the console that tells us what settings were chosen (in our case, the default values).The maxit argument of the makeTuneControlRandom function determines the number of iterations for random search - per default 100.One thing is important to note: Grid search can only deal with discrete parameter sets, defined with the makeDiscreteParam function, while random search can deal with all types of parameter sets.\n\n**6. Define resampling strategy**\n\nThe final step is to define the resampling strategy. With the makeResampleDesc function you can create a description object for a resampling strategy, like cross-validation, repeated cross-validation, leave-one-out, bootstraping or holdout. Alternatively, you can store a set of integer vectors for training and test sets with the makeResampleInstance function.Here, we will use 3 x 5-fold repeated cross-validation to measure the performance of a specific parameter combination. If we want to predict training AND validation data (in mlr called test) during resampling to detect overfitting, we choose predict = both.We now have these three objects in R:- cross_val- param_set- and ctrl_gridSo, now we take our task and learner object and combine all in the tuneParams function, which will perform the hyperparameter tuning and model fitting.\n\n**7. Tuning hyperparameters**\n\nWe could additionally define performance evaluation metrics but if we don't, mlr will use the Mean misclassification error rate (mmce) by default for classification tasks. See getDefaultMeasure to find the default measure for a task. Here, you see the output that is printed to the console during training. We will get feedback for every hyperparameter that was tested, as well as the time it took to run.The last row returns the best hyperparameter result. In this case 2 hidden layers, Tanh activation and l1=0.11 and l2=0.1.The entire training process took about 30 seconds.\n\n**8. Let's practice!**\n\nNow, it's your turn again!\n\n## Random search with mlr\n\n<!--\nLO: The student knows how to prepare hyperparameter tuning with random search in mlr\n-->\nNow, you are going to perform **hyperparameter tuning with random search**. You will prepare the different functions and objects you need to tune your model in the next exercise.\n\nThe `knowledge_train_data` dataset has already been loaded for you, as have the packages `mlr`, `tidyverse` and `tictoc`.\nRemember to look into the function that lists all learners if you are unsure about the name of a learner.\n\n**Steps**\n\n1. Get the **parameter set** for neural networks of the `nnet` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the parameter set for neural networks of the nnet package\ngetParamSet(\"classif.nnet\")\n```\n:::\n\n\n2. Define a **set of discrete parameters:** start with defining `size` to be either 2, 3 or 5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define set of parameters\nparam_set <- makeParamSet(\n  makeDiscreteParam(\"size\", values = c(2,3,5))\n)\n```\n:::\n\n\n3. Define a set of **numeric parameters**: add ranges for `decay` from 0.0001 to 0.1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define set of parameters\nparam_set <- makeParamSet(\n  makeDiscreteParam(\"size\", values = c(2,3,5)),\n  makeNumericParam(\"decay\", lower = 0.0001, upper = 0.1)\n)\n\n# Print parameter set\nprint(param_set)\n```\n:::\n\n\n4. Define a **random search tuning method** with default values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a random search tuning method.\nctrl_random <- makeTuneControlRandom()\n```\n:::\n\n\nVery good! You know how to prepare hyperparameter tuning with random search in mlr.\n\n## Perform hyperparameter tuning with mlr\n\n<!--\nLO: The student knows how to do hyperparameter tuning with random search in mlr\n-->\nNow, you can combine the prepared functions and objects from the previous exercise to actually perform **hyperparameter tuning with random search**.\nThe `knowledge_train_data` dataset has already been loaded for you, as have the packages `mlr`, `tidyverse` and `tictoc`. And the following code has also been run already:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define task\ntask <- makeClassifTask(data = knowledge_train_data, \n                        target = \"UNS\")\n\n# Define learner\nlrn <- makeLearner(\"classif.nnet\", predict.type = \"prob\", fix.factors.prediction = TRUE)\n\n# Define set of parameters\nparam_set <- makeParamSet(\n  makeDiscreteParam(\"size\", values = c(2,3,5)),\n  makeNumericParam(\"decay\", lower = 0.0001, upper = 0.1)\n)\n```\n:::\n\n\n**Steps**\n\n1. Change the **maximum number of iterations** for random search to 6. Note, that 6 is a very low number; we use it so that calculation won't take forever to complete here; usually, you would set the number much higher (the default is 100).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a random search tuning method.\nctrl_random <- makeTuneControlRandom(maxit = 6)\n```\n:::\n\n\n2. Define a **3 x 3 repeated cross-validation** scheme. Note, that these are very low numbers that we only use to keep calculation time down, in reality you would want to use larger values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a 3 x 3 repeated cross-validation scheme\ncross_val <- makeResampleDesc(\"RepCV\", folds = 3 * 3)\n```\n:::\n\n\n3. Fill in the missing information with the **appropriate objects** you defined in this and the previous exercise in order to run the hyperparameter tuning. Don't be concerned if running the code will take a bit, hyperparameter tuning takes time!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tune hyperparameters\ntic()\nlrn_tune <- tuneParams(lrn,\n                       task,\n                       resampling = cross_val,\n                       control = ctrl_random,\n                       par.set = param_set,\n                       show.info = F) |> \n                       \n                       # Supress output\n                       capture.output()\ntoc()\n```\n:::\n\n\n> *Question*\n> ---\n> What's the **default performance metric** used by `tuneParams()` in the previous exercises?<br>\n> <br>\n> ✅ `mmce` (mean misclassification rate)<br>\n> ⬜ `acc` (accuracy)<br>\n> ⬜ `rmse` (root mean squared error)<br>\n> ⬜ `kappa` (Kappa)<br>\n\nGreat! You know how to perform hyperparameter tuning with random search in mlr.\n\n## Evaluating hyperparameters with mlr\n\nTheory. Coming soon ...\n\n\n**1. Evaluating hyperparameters with mlr**\n\nIn this lesson, I will show different ways to plot and evaluate models with different hyperparameters.\n\n**2. Evaluation of our results can tell us:**\n\nGenerally, we want to evaluate hyperparameter tuning to assess:- How different hyperparameters affect model performance.- Which hyperparameters have particularly strong or weak impact.- Whether our hyperparameter search converged, i.e. whether we can be reasonably confident that we found the most optimal combination (or close to it).\n\n**3. Recap**\n\nLet's look at our former example: hyperparameter tuning with deep learning from the h2o package.Let's set up the tuning just as before, before we discuss how to evaluate the results: create a grid of hyperparameters, define tune control, resampling strategy, task and the learner.A small variation is our resampling scheme: this time, I am using a holdout set, which is much faster to train than repeated cross validation. The default split is 2 / 3.\n\n**4. Evaluating the tuning results**\n\nHere, you see the tuning result, i.e. the best combination of hyperparameters from our random set: 1 hidden layer with 10 nodes, Rectifier activation and l1 and l2 regularization of 0.541 and 0.229.Mean misclassification error was 0.16, which is okay.With the generateHyperParsEffectData function, we generate the results object.Because we are tuning more than 2 hyperparameters, we need to set partial dependence to TRUE.The output of this function gives a summary of the settings: which hyperparameters were tuned, which measure was used to evaluate them, what optimizer was used and whether we used nested cross validation.And we get a table with different hyperparameters that were tested. In our case, we see five randomly picked hyperparameter combinations, what values were chosen for each, as well as the mmce and the execution time. The entire table can be called with generateHyperParsEffectData$data.\n\n**5. Plotting hyperparameter tuning results**\n\nThe hyperparameter effect data can also be plotted with the plotHyperParsEffect function. A plot can often make it easier to grasp the overall information and evaluate how well different hyperparameters performed in our model.The function takes a few inputs:- the generated hyperparameter effect data- a regression method to calculate partial dependence. Here, I am choosing random Forest but any regression method from the mlr repertoire can be used.- The x axis can show any of our hyperparameters. Here I chose l1. The y axis can show the remaining metrics, like mmce or iteration. Optionally, you can choose a z variable, in this case the number of hidden layers which is shown with different colors.- By default, plotHyperParsEffect will create a scatter plot, we can change that to a line plot, heatmap or contour plot, with the plot.type argument.\n\n**6. Now it's your turn!**\n\nAlright, now it's your turn to evaluate hyperparameters!\n\n## Why to evaluate tuning?\n\n> *Question*\n> ---\n> What can you learn from **evaluating hyperparameter tuning** results?<br>\n> <br>\n> ⬜ How different model parameters were learned.<br>\n> ✅ Which hyperparameters have a strong effect on model performance.<br>\n> ⬜ Whether your hyperparameters are the best possible combination for your task.<br>\n> ⬜ Whether the learning rate converged.<br>\n\nCorrect! Evaluating hyperparameter tuning results will tell you which hyperparameters have a strong effect on model performance.\n\n## Evaluating hyperparameter tuning results\n\n<!--\nLO: The student knows how to do evaluate hyperparameter tuning results in mlr\n-->\nHere, you will **evaluate the results of a hyperparameter tuning run** for a decision tree trained with the `rpart` package.\nAnd the following code has also been run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask <- makeClassifTask(data = knowledge_train_data, \n                        target = \"UNS\")\n\nlrn <- makeLearner(cl = \"classif.rpart\", fix.factors.prediction = TRUE)\n\nparam_set <- makeParamSet(\n  makeIntegerParam(\"minsplit\",  lower = 1, upper = 30),\n  makeIntegerParam(\"minbucket\", lower = 1, upper = 30),\n  makeIntegerParam(\"maxdepth\",  lower = 3, upper = 10)\n)\n\nctrl_random <- makeTuneControlRandom(maxit = 10)\n```\n:::\n\n\n**Steps**\n\n1. Create a **holdout validation resampling scheme** with the default proportion of 2/3 to use in the tuning process below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create holdout sampling\nholdout <- makeResampleDesc(\"Holdout\")\n\n# Perform tuning\nlrn_tune <- tuneParams(learner = lrn, task = task, resampling = holdout, control = ctrl_random, par.set = param_set)\n```\n:::\n\n\n2. Generate **hyperparameter effect data** for the `lrn_tune` object and use **partial dependence**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate hyperparameter effect data\nhyperpar_effects <- generateHyperParsEffectData(lrn_tune, partial.dep = TRUE)\n```\n:::\n\n\n3. **Plot** the hyperparameter effects with \"regr.glm\" to learn the partial dependence and plot `minsplit` on the x-axis against the `mmce` of the test data on the y-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required package: mmpf\n\n# Plot hyperparameter effects\np <- plotHyperParsEffect(hyperpar_effects, \n                    partial.dep.learn = \"regr.glm\",\n                    x = \"minsplit\", y = \"mmce.test.mean\", z = \"maxdepth\",\n                    plot.type = \"line\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np\n```\n:::\n\n\nGood job! You know how to do evaluate hyperparameter tuning results in mlr.\n\n## Advanced tuning with mlr\n\nTheory. Coming soon ...\n\n**1. Advanced tuning with mlr**\n\nNow, I will show you some advanced functions for hyperparameter tuning in mlr.\n\n**2. Advanced tuning controls**\n\nIn the previous lesson, you got to know grid search and random search. But we can also use more advanced methods, like- CMA Evolution Strategy, which is based on the concept of creating variation from the hyperparameter values in each iteration and choosing those with highest fitness for the next round. You can think of it as \"Survival of the fittest\" for hyperparameters.- We can also predefine a complete data frame of hyperparameters- Or use Generalized simulated annealing. Our hyperparameter search space for the model can be thought of as a complex non-linear function where the best hyperparameters will be found in its global minimum, which GenSA aims to find.- Another tuning control is iterated F-racing for automated configuration of algorithms to find the most optimal hyperparameter values in an optimization task.- And we could also use model-based or Bayesian optimization. As the name suggests, MBO uses Bayesian statistics to approximate the objective function. MBO works in conjunction with the functions `makeMBOControl` and `setMBOControlTermination`Check the help for each function to find out which hyperparameters can be defined with each function. Some allow only discrete values, while others can't deal with dependencies. An example for dependent hyperparameters is degree in Support Vector Machines, which only works with a polynomial kernel.\n\n**3. Choosing evaluation metrics**\n\nUntil now, we didn't define performance metrics and used the defaults. For classification, this was the Mean misclassification error (mmce).But we can also define one or more metric with the measure argument to tuneParams, which can take one value or a list of values. Let's look at an example:If we pass a list, the first element is used to optimize against during hyperparameter tuning, while the remaining elements of the list will only be evaluated and returned.For additional details, have a look at the Advanced Tuning section of the mlr package documentation. Here you see part of the output of our tuning run. You get information about the iteration number, hyperparameters and the metrics measured on the test (or more accurately the validation) data.\n\n**4. Choosing evaluation metrics**\n\nWe can also define more complex metrics with the setAggregation function, which additionally returns the standard deviation of a metric, aggregated after resampling. In our example, accuracy, aggregated by the mean performance values on the training set is used for optimization, while the mmce is evaluated.When we look at the output, we see that we get information about the performance not only for the test set but also for the training set.If the available performance metrics are not suitable for your particular problem, you can use the makeMeasure function to construct custom measures.\n\n**5. Nested cross-validation &amp; nested resampling**\n\nAnother advanced approach is nested cross validation. Here, we use the makeTuneWrapper function instead of tuneParams to customize our base learner and add a hyperparameter search strategy.We can use this wrapper either directly with the train function, where tuning and resampling are performed and a final model is fit with the best hyperparameter combination. These can be extracted with getTuneResult.Or we can add an additional layer of cross-validation with the resample function, where we pass a second tuning control to the resampling argument.\n\n**6. Choose hyperparameters from a tuning set**\n\nAnd finally, we can extract the hyperparameters of our learner object and use the setHyperPars function to specifically define a set of hyperparameters. These can then be used just as before with the fit function, which will return a trained model that can be used for prediction on new data.\n\n**7. It's your turn!**\n\nGreat, now it's your turn again!\n\n## Define advanced tuning controls\n\n> *Question*\n> ---\n> How do you define a **model-based / Bayesian** hyperparameter optimization strategy?<br>\n> <br>\n> ⬜ `makeTuneControlCMAES`<br>\n> ⬜ `makeTuneControlGenSA`<br>\n> ⬜ `makeTuneControlIrace`<br>\n> ✅ `makeTuneControlMBO`<br>\n\nCorrect! `makeTuneControlMBO` is for model-based / Bayesian optimization.\n\n## Define aggregated measures\n\n<!--\nLO: The student knows how to define aggregated measures for hyperparameter optimization\n-->\nNow, you are going to define **performance measures**.\nAnd the following code has also been run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask <- makeClassifTask(data = knowledge_train_data, \n                        target = \"UNS\")\n\nlrn <- makeLearner(cl = \"classif.nnet\", fix.factors.prediction = TRUE)\n\nparam_set <- makeParamSet(\n  makeIntegerParam(\"size\", lower = 1, upper = 5),\n  makeIntegerParam(\"maxit\", lower = 1, upper = 300),\n  makeNumericParam(\"decay\", lower = 0.0001, upper = 1)\n)\n\nctrl_random <- makeTuneControlRandom(maxit = 10)\n```\n:::\n\n\n**Steps**\n\n1. Use the `setAggregation` function, which **aggregates the standard deviation** of performance metrics.\n2. Apply `setAggregation` to the **mean misclassification error** and **accuracy after resampling**.\n3. **Optimize** your model by mean misclassification error. Remember that the **first argument** is used for optimization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create holdout sampling\nholdout <- makeResampleDesc(\"Holdout\", predict = \"both\")\n\n# Perform tuning\nlrn_tune <- tuneParams(learner = lrn, \n                       task = task, \n                       resampling = holdout, \n                       control = ctrl_random, \n                       par.set = param_set,\n                       measures = list(mmce, setAggregation(mmce, train.mean), acc, setAggregation(acc, train.mean)))\n```\n:::\n\n\nVery good! You know how to define aggregated measures for hyperparameter optimization.\n\n## Setting hyperparameters\n\n<!--\nLO: The student knows how to set hyperparameters in mlr\n-->\nAnd finally, you are going to set specific hyperparameters, which you might have found by examining your tuning results from before,\nThe `knowledge_train_data` dataset has already been loaded for you, as have the packages `mlr` and `tidyverse`. And the following code has also been run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask <- makeClassifTask(data = knowledge_train_data, \n                        target = \"UNS\")\n\nlrn <- makeLearner(cl = \"classif.nnet\", fix.factors.prediction = TRUE)\n```\n:::\n\n\n**Steps**\n\n1. Set the following hyperparameters for a neural net: One **hidden layer**, **maximum number of iterations** of 150 and 0 **decay**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set hyperparameters\nlrn_best <- setHyperPars(lrn, par.vals = list(size = 1, \n                                              maxit = 150, \n                                              decay = 0))\n\n# Train model\nmodel_best <- train(lrn_best, task)\n```\n:::\n\n\nGreat! You know how to set specific hyperparameters in mlr.\n\n# 4. Hyperparameter tuning with h2o\n\nIn this final chapter, you will use h2o, another package for machine learning with very convenient hyperparameter tuning functions. You will use it to train different models and define a Cartesian grid. Then, You will implement a Random Search use stopping criteria. Finally, you will learn AutoML, an  h2o interface which allows for very fast and convenient model and hyperparameter tuning with just one function.\n\n## Machine learning with h2o\n\nTheory. Coming soon ...\n\n\n**1. Machine learning with H2O**\n\nIn the previous chapters, you learned what hyperparameters are and how you can tune them with `caret` and `mlr`. There are many other popular machine learning packages and the one I want to present in this chapter is h2o.\n\n**2. What is H2O?**\n\nH2O is an open source machine learning platform you can use with R and the h2o package.What makes h2o special compared to caret and mlr is that h2o is designed for scalability. This means that the implementations of h2o's machine learning algorithms can be trained on distributed clusters. That's why you need to initiate an h2o cluster with the h2o.init() function - if you are not working on remote clusters, like Spark or Hadoop, you will initiate a local cluster on your machine.Another very useful feature of h2o is AutoML for automatic model comparison and hyperparameter tuning.\n\n**3. New dataset: seeds data**\n\nIn this chapter, we will be working on a dataset with measurements of geometrical properties of wheat seed kernels. These measurements are area, perimeter, compactness, kernel length and width, asymmetry and kernel grove.We also know the seed type, that describes three different varieties of wheat. In this dataset we have 50 instances for each of the three seed varieties, denoted with 1, 2 and 3.\n\n**4. Preparing the data for modeling with H2O**\n\nBefore we can start, we need to pass our data to the H2O instance. If you load data in from a file, you can directly load them as h2o frames, but often, we want to preprocess data with other R packages. In this case, we use the as.h2o function to convert an R object to an h2o frame.Next, it is good practice to define the names of the features (`x`) and the target variable (`y`). These names correspond to the column names of our dataset.In this dataset, the target seed type has been encoded numerically as 1, 2 and 3. Because we want to use the seed type for classification, we need to convert the target into factors.\n\n**5. Training, validation and test sets**\n\nh2o also contains a function for splitting data into training, validation and test sets.The h2o.splitframe function takes: - the h2o frame to split and- the ratios for how many instances should go into the created subsets (here, we want to have 70% of the data in the training set, 15% in the validation set and the remaining 15% in the test set.We can use the summary function on our response variable to compare the ratios in the different subsets. summary for h2o frames takes the additional exact_quantiles argument, which - if set to TRUE - computes exact quantiles. Per default, it use approximations.\n\n**6. Model training with H2O**\n\nh2o contains a number of different algorithms that can be trained in a distributed fashion:- Gradient Boosted models- Generalized linear models- Random Forest models- and Neural NetworksThese functions can take many arguments and hyperparameters. You can find them all by looking at the help for each function.\n\n**7. Model training with H2O**\n\nIn this gradient boosting example, I am telling h2o which column in my data is the target 'y' and which features 'x' I want to include in the model. And I give the training and validation data.Here is the beginning of the model output with a summary of the final hyperparameters.\n\n**8. Evaluate model performance with H2O**\n\nh2o also includes functions for evaluating model performance. The h2o.performance function calculates a set of metrics on a new h2o frame, here we use the test data.We can use additional functions to extract components from this model metrics object, like the confusion matrix and logloss.If we want to use our model to generate predictions, we use the h2o(dot)predict function.\n\n**9. Let's practice!**\n\nLet's practice!\n\n## Prepare data for modelling with h2o\n\n<!--\nLO: The student knows how to prepare data for machine learning with h2o\n-->\nIn order to train models with `h2o`, you need to **prepare the data** according to h2o's specific needs. Here, you will go over a common data preparation workflow in `h2o`.\n\nThe `h2o` library has already been loaded for you, as has the `seeds_train_data` object.\n\nThis chapter uses functions that can take some time to run, so don't be surprised if it takes a little longer than usual to submit your answer. On rare occurrences, you may get a server error. If this is the case, just reload the page.\n\n**Steps**\n\n1. Convert the `seeds_train_data` object to an **H2O frame**. Note, that you only need to give arguments that don't have a default value in the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nseeds_train_data <- read_csv(\"data/seeds_train_data.csv\")\n\n# Load package\nlibrary(h2o)\n\n# Initialise h2o cluster\nh2o.init()\n\n# Convert data to h2o frame\nseeds_train_data_hf <- as.h2o(seeds_train_data)\n```\n:::\n\n\n2. Define **vectors of target** (`y`) and **feature names** (`x`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify target and features\ny <- \"seed_type\"\nx <- setdiff(colnames(seeds_train_data_hf), y)\n\nseeds_train_data_hf[, y] <- as.factor(seeds_train_data_hf[, y])\n```\n:::\n\n\n3. Split the `seeds_train_data_hf` into a **training** and **validation** set and use the default proportion of 75% instances in one set, 25% in the other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split data into train & validation sets\nsframe <- h2o.splitFrame(seeds_train_data_hf, seed = 42)\ntrain <- sframe[[1]]\nvalid <- sframe[[2]]\n```\n:::\n\n\n4. Calculate the **ratio of the target variable** in the training set using **exact quantiles**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate ratios of the target variable\nsummary(train$seed_type, exact_quantiles = TRUE)\n```\n:::\n\n\nGood job! You successfully prepared data for machine learning with h2o.\n\n## Modeling with h2o\n\n<!--\nLO: The student knows how to train machine learning models with h2o\n-->\nIn the last exercise, you successfully prepared data for modeling with h2o. Now, you can use this data to **train a model**.\n\n**Steps**\n\n1. Train a **Random Forest** model with `h2o`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train random forest model\nrf_model <- h2o.randomForest(x = x,\n                             y = y,\n                             training_frame = train,\n                             validation_frame = valid)\n```\n:::\n\n\n2. Calculate **model performance** of the Random Forest model on the **validation** data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate model performance\nperf <- h2o.performance(rf_model, valid = TRUE)\nperf\n```\n:::\n\n\n3. Extract the **confusion matrix** from the model performance object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract confusion matrix\nh2o.confusionMatrix(perf)\n```\n:::\n\n\n4. Extract the `logloss` of the model performance object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract logloss\nh2o.logloss(perf)\n```\n:::\n\n\nGreat! You know how to train a random forest model with h2o.\n\n## Grid and random search with h2o\n\nTheory. Coming soon ...\n\n\n**1. Grid and random search with H2O**\n\nAs caret and mlr, h2o supports Cartesian grid search and random search.\n\n**2. Hyperparameters in H2O models**\n\nWe can find an overview of all hyperparameters in the help for each model function. A few of the hyperparameters for gradient boosting models are- the number of trees- maximum tree depth- fewest allowed observations in a leaf and- learning rate, optionally with scaling\n\n**3. Preparing our data for modeling with H2O**\n\nBefore we define hyperparameter grids, let's briefly go over how we prepared our data:- we converted the data to an h2o frame- defined features and target and- split into training, validation &amp; test data\n\n**4. Defining a hyperparameter grid**\n\nFor cartesian grid search, we define a list of values for the hyperparameters, we want to tune.This list, can be fed into the h2o(dot)grid function as input to the hyper_params argument.Additional arguments to give h2o(doc)grid can be- the algorithm, here gbm- a model id,- features and target- training and validation data- a seed for random number generationh2o will now train a model for every possible combination of hyperparameters from our grid.After training is complete, we can look at the tuning results with the h2o(dot)getGrid function.\n\n**5. Examining a grid object**\n\nTo examine the tuning results, h2o(dot)getGrid uses the grid id which we defined in the h2o.grid function before. We also give a metric and the order by which to sort the different models.The summary of this grid object tells us which hyperparameters were tuned, how many models were trained (and how many failed).\n\n**6. Extracting the best model from a grid**\n\nAll 27 models in our grid are given a unique model id, which we can use to extract any of the models with the h2o(dot)getModel function.Usually, we will want to extract the best model. Because we sorted by decreasing accuracy, the first model in the sorted table returned by get.grid will have the highest accuracy.Model summary will give us an overview of the hyperparameters used.\n\n**7. Extracting the best model from a grid**\n\nThe extracted best model can now be treated as a regular h2o model. We can for example use the h2o(dot)performance function to evaluate the performance on test data.\n\n**8. Random search with H2O**\n\nRandom search in h2o also takes a list of hyperparameter values, just as the grid search example before. In contrast, we now don't want to train models for every possible combination of our defined grid, but only for a randomly sampled subset of our hyperparameters.Thus, we need an additional list that defines the search criterium \"random discrete\". We have several options for controlling how the random search is performed- set maximum number of models to train with max_models- define stopping metric, rounds and tolerance- or set the maximum run time, as here with 60 secondsThis search criteria object can then be passed onto the search_criteria argument of h2o(dot)grid.\n\n**9. Stopping criteria**\n\nInstead of defining the maximum run time or the maximum number of model to train during random search, we can define early stopping criteria.Early stopping is calculated on the validation data and works with three arguments:- stopping_metric- stopping_rounds and - stopping_tolerance.If the performance metric doesn't improve for a number of consecutive rounds by at least the stopping tolerance, model training will stop. In this example here, training will stop if 6 times in a row, the mean per class error does not improve by at least 0.0001.For stopping metric, we can choose between several options, like- mean residual deviance (the default for regression tasks)- logloss (the default for classification tasks)- mean squared error MSE, etc.The remaining training code and model output looks just like before.\n\n**10. Time to practice!**\n\nTime to practice!\n\n## Grid search with h2o\n\n<!--\nLO: The student knows how to use grid search for model tuning with h2o\n-->\nNow that you successfully trained a Random Forest model with `h2o`, you can apply the same concepts to training all other algorithms, like **Deep Learning**. In this exercise, you are going to apply **a grid search** to tune a model.\nThe `h2o` library has already been loaded and initialized for you.\n\n**Steps**\n\n1. Start defining a **grid of hyperparameters for deep learning** with `h2o`: for **learning rate** use the values 0.001, 0.005 and 0.01. For an overview of all hyperparameters to use, go to the **help** for `h2o.deeplearning`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define hyperparameters\ndl_params <- list(rate = c(0.001, 0.005, 0.01))\n```\n:::\n\n\n2. Add values for the **number of training iterations** of 5, 10 and 15 to the tuning grid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define hyperparameters\ndl_params <- list(epochs = c(5, 10, 15),\n                  rate = c(0.001, 0.005, 0.01))\n```\n:::\n\n\n3. And finally, add two options for the **number nodes in two hidden layers**: 50 & 50 and 100 & 100. Note that the argument takes **two values** here, so you need to create a **list within the list** for the two hidden layers of one option.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define hyperparameters\ndl_params <- list(hidden = list(c(50, 50), c(100, 100)),\n                  epochs = c(5, 10, 15),\n                  rate = c(0.001, 0.005, 0.01))\n```\n:::\n\n\n> *Question*\n> ---\n> Which **argument** of the `h2o.grid()` function takes the hyperparameter grid as input?<br>\n> <br>\n> ✅ `hyper_params`<br>\n> ⬜ `algorithm`<br>\n> ⬜ `is_supervised`<br>\n> ⬜ `do_hyper_params_check`<br>\n\nCorrect! You know how to use grid search for tuning a deep learning model with h2o.\n\n## Random search with h2o\n\n<!--\nLO: The student knows how to use random search for model tuning with h2o\n-->\nNext, you will use **random search**. \n\n**Steps**\n\n1. Define a **search criteria** object that defines **random search** with a **maximum runtime of 10 seconds**.\n2. Add this search criteria object at the appropriate place in the `h2o.grid` function to **train the random models**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define search criteria\nsearch_criteria <- list(strategy = \"RandomDiscrete\", \n                        max_runtime_secs = 10, # this is way too short & only used to keep runtime short!\n                        seed = 42)\n\n# Train with random search\ndl_grid <- h2o.grid(\"deeplearning\", \n                    grid_id = \"dl_grid\",\n                    x = x, \n                    y = y,\n                    training_frame = train,\n                    validation_frame = valid,\n                    seed = 42,\n                    hyper_params = dl_params,\n                    search_criteria = search_criteria)\n```\n:::\n\n\nNice! You know how to use random search for tuning a deep learning model with h2o.\n\n## Stopping criteria\n\n<!--\nLO: The student knows how to use stopping criteria in random search for model tuning with h2o\n-->\nIn random search, you can also define **stopping criteria** instead of a maximum runtime. \nThe `h2o` library and `seeds_train_data` has already been loaded and initialized for you.\n\n**Steps**\n\n1. Modify the hyperparameter search by **adding misclassification rate** as the **stopping metric**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define early stopping\nstopping_params <- list(strategy = \"RandomDiscrete\", \n                        stopping_metric = \"misclassification\",\n                        seed = 42)\n```\n:::\n\n\n2. Add **3 stopping rounds** to the search criteria object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define early stopping\nstopping_params <- list(strategy = \"RandomDiscrete\", \n                        stopping_metric = \"misclassification\",\n                        stopping_rounds = 3, \n                        seed = 42)\n```\n:::\n\n\n3. And finally, add a **stopping tolerance** of 0.1 to the search criteria..\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define early stopping\nstopping_params <- list(strategy = \"RandomDiscrete\", \n                        stopping_metric = \"misclassification\",\n                        stopping_rounds = 2, \n                        stopping_tolerance = 0.1,\n                        seed = 42)\n```\n:::\n\n\n> *Question*\n> ---\n> Which **argument** of the `h2o.grid()` function takes the stopping criteria as input?<br>\n> <br>\n> ⬜ `algorithm`<br>\n> ⬜ `grid_id`<br>\n> ⬜ `strategy`<br>\n> ✅ `search_criteria`<br>\n\nCorrect! You know how to use stopping criteria in random search.\n\n## Automatic machine learning with H2O\n\nTheory. Coming soon ...\n\n\n**1. Automatic machine learning with H2O**\n\nThe final and most convenient function for advanced model tuning is h2o's automatic machine learning functionality.\n\n**2. Automatic Machine Learning (AutoML)**\n\nAutomatic Machine Learning goes one step beyond regular hyperparameter tuning: instead of tuning only one model type or algorithm, AutoML performs tuning for a number of different algorithms, as well as hyperparameters.AutoML makes finding the best (or almost best) model extremely fast and easybecause it is all combined in a single function, that only needs a dataset, the target in case of classification and a time or model number limit that tells it how long to train models for.\n\n**3. AutoML in H2O**\n\nAutoML trains a number of different algorithms during a default classification run in this specific order:- 1 generalized linear model- 1 distributed random forest- 1 extremely randomized tree- 3 XGBoost- 5 gradient boosting machines- a Neural Net, a random grid of XGBoost, a random grid of GBMs, a random grid of Neural Nets and- 2 Stacked EnsemblesOne of the 2 ensembles is calculated from all models, the other only from the best models of each family of algorithms.In case you want to exclude algorithms, you can define a list of these algorithms in your automl run. In some cases, it is recommended to exclude tree-based algorithms.\n\n**4. Hyperparameter tuning in H2O's AutoML**\n\nFor all algorithms where multiple models are run, automl automatically tests a range of hyperparameters for different arguments.These are some of the hyperparameters for gradient boosting modelsand for neural nets.XGBoost hyperparameters are similar to GBM.You can find out more about each hyperparameter by going to the help for the original h2o model functions. For gradient boosting that would be h2o.gbm.Random Forest and Extremely Randomized Trees are not grid searched because only one model is trained for each.\n\n**5. Using AutoML with H2O**\n\nHere you see the h2o.automl function in action.automl uses the same arguments as regular h2o algorithms: x, y, training_frame, validation_frame, etc.As before with random search, AutoML needs stopping criteria. These can either be the maximum run time (as here 60 seconds), which will define the time spent on grid searches or the maximum number of models. We could also give both and automl will stop when it reaches either of the criteria.Note, that training the stacked ensembles doesn't count to the maximum run time, nor the maximum number of models to train, they will always be calculated at the end.With sort_metric, we define how the models should be sorted in the final output, called the leaderboard. The best model according to this metric, here logloss, will be on position 1 in the leaderboard. You can choose- area under the curve (default for binary classification)- mean per class error (default for multinomial classification)- mean residual deviance (default for regression)and more.As always, the help functions will give you additional details.\n\n**6. Viewing the AutoML leaderboard**\n\nThis is how the leaderboard from the previous automl run looks like. You can extract it by calling automl_model@leaderboard.The leaderboard contains all models that were trained, as well as the model id and performance metrics, like - mean_per_class_error- logloss- root mean squared error- or mean squared errorThe second column of the leaderboard shows the metric that was used for ranking, in our case mean per class error, as specified in the automl function.If you don't specify a leaderboard dataset, metrics will be calculated on 5-fold cross-validation results.Follow this link to read the complete documentation.\n\n**7. Extracting models from AutoML leaderboard**\n\nYou can extract individual models from automl (usually, the best model) via their model_id, which you find the in the leaderboard.Models you extracted can again be treated just as you would any other h2o model, e.g. for predictions.\n\n**8. Get ready for your last round of exercises!**\n\nGet ready for your last round of exercises!\n\n## AutoML in h2o\n\n<!--\nLO: The student knows how to perform automatic machine learning with h2o\n-->\nA very convenient functionality of `h2o` is automatic machine learning (**AutoML**).\n\n**Steps**\n\n1. Define an **automatic machine learning training** with **maximum runtime** of 10 seconds. Note: 10 seconds is of course not enough for \"real-life\" but training for hours would take too long for the purpose of this exercise otherwise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run automatic machine learning\nautoml_model <- h2o.automl(x = x, \n                           y = y,\n                           training_frame = train,\n                           max_runtime_secs = 10,\n                           seed = 42)\n```\n:::\n\n\n2. Use **mean per class error** as the sorting metric in the leaderboard.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run automatic machine learning\nautoml_model <- h2o.automl(x = x, \n                           y = y,\n                           training_frame = train,\n                           max_runtime_secs = 10,\n                           sort_metric = \"mean_per_class_error\",\n                           seed = 42)\n```\n:::\n\n\n3. Have the leaderboard be calculated on **3-fold cross-validated data**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run automatic machine learning\nautoml_model <- h2o.automl(x = x, \n                           y = y,\n                           training_frame = train,\n                           max_runtime_secs = 10,\n                           sort_metric = \"mean_per_class_error\",\n                           nfolds = 3,\n                           seed = 42)\n```\n:::\n\n\n4. Have the **leaderboard be calculated based on the validation data** instead of on cross-validation results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run automatic machine learning\nautoml_model <- h2o.automl(x = x, \n                           y = y,\n                           training_frame = train,\n                           max_runtime_secs = 10,\n                           sort_metric = \"mean_per_class_error\",\n                           leaderboard_frame = valid,\n                           seed = 42)\n```\n:::\n\n\nVery good! You know how to use AutoML to perform automatic machine learning with h2o.\n\n## Scoring the leaderboard\n\nH2O's AutoML function returns the model results in the so called **leaderboard**.\n\n> *Question*\n> **Without cross-validation**, which datasets do you have to define if you want to:\n> <br>\n>    * use the **training data** as is\n>    * use half of the validation data for **validation**\n>    * and use the other half of the validation data for **scoring the leaderboard**\n> <br>\n> ⬜ `training_frame`<br>\n> ⬜ `training_frame` + `leaderboard_frame`<br>\n> ✅ `training_frame` + `validation_frame`<br>\n> ⬜ `training_frame` + `validation_frame` + `leaderboard_frame`<br>\n\nCorrect! With `training_frame` + `validation_frame`, training data is used as is, validation set is split 50/50 into validation and leaderboard data.\n\n## Extract h2o models and evaluate performance\n\n<!--\nLO: Student knows how to extract the best model from AutoML\n-->\nIn this final exercise, you will extract the **best model** from the **AutoML leaderboard**.\nThe `h2o` library and `test` (???) data has been loaded and the following code has been run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoml_model <- h2o.automl(x = x, \n                           y = y,\n                           training_frame = train,\n                           nfolds = 3,\n                           max_runtime_secs = 60,\n                           sort_metric = \"mean_per_class_error\",\n                           seed = 42)\n```\n:::\n\n\n**Steps**\n\n1. Extract the **leaderboard** from the AutoML output. Note, that you can extract subsets of objects not only with `$` but also with `@`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the leaderboard\nlb <- automl_model@leaderboard\nhead(lb)\n```\n:::\n\n\n2. Assign the **best model** from the leaderboard the name `aml_leader` and examine it with the `summary()` function. Remember, that you can also use the @ sign to access parts of the `automl_model` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign best model new object name\naml_leader <- automl_model@leader\n\n# Look at best model\nsummary(aml_leader)\n```\n:::\n\n\n--> NO VALIDATION DATA SET\n\n> *Question*\n> ---\n> Look at the **summary** of the best model: How high is the **residual deviance** of the validation data?<br>\n> <br>\n> ⬜ 14.70705<br>\n> ⬜ 4.039518<br>\n> ⬜ 22.54199<br>\n> ✅ [8.085209]<br>\n\n> *Question*\n> ---\n> The `aml_leader` object can now be treated as you would any H2O model object. How would you calculate the **model performance** of this best model on `test` data?<br>\n> <br>\n> ⬜ `h2o.aggregated_frame(aml_leader, test)`<br>\n> ⬜ `h2o.varimp(aml_leader, test)`<br>\n> ✅ `h2o.performance(aml_leader, test)`<br>\n> ⬜ `h2o.cross_validation_models(aml_leader, test)`<br>\n\nCorrect! You know how to extract the best model from an AutoML leaderboard and how to evaluate it on test data.\n\n## Wrap-up\n\nTheory. Coming soon ...\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
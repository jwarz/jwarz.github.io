[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "content/R/index.html",
    "href": "content/R/index.html",
    "title": "About R Tutorials",
    "section": "",
    "text": "Each class session has a set of required readings that you should complete before watching the lecture.\nEvery class session also has a YouTube playlist of short recorded videos for each of the lecture sections. The lecture slides are special HTML files made with the R package xaringan (R can do so much!). On each class session page you’ll see buttons for opening the presentation in a new tab or for downloading a PDF of the slides in case you want to print them or store them on your computer:\n\n View all slides in new window  Download PDF of all slides\n\nThe slides are also embedded on each page. You can click in the slides and navigate through them with ← and →. If you type ? (or shift + /) while viewing the slides you can see a list of slide-specific commands (like f for fullscreen or p for presenter mode if you want to see my notes)."
  },
  {
    "objectID": "content/R/r-manuals/01-content.html",
    "href": "content/R/r-manuals/01-content.html",
    "title": "Evaluation and the causal revolution",
    "section": "",
    "text": "The syllabus, content, examples, and assignments pages for this class\n Chapter 1 in Impact Evaluation in Practice [@wb-eval]\n Chapters 1 and 2 in The Effect [@Huntington-Klein:2021]\n DJ Patil, “What Makes a Radical and Revolutionary Technology?”\n\n(DJ Patil is the former Chief Data Scientist of the United States under President Obama. He gave this forum address at Brigham Young University on February 13, 2018.)\n\n Stephen Goldsmith, “Next Generation of Public Employees Must Understand Data and Policy”\n Hadley Wickham, “Data Science: How is it Different To Statistics?”"
  },
  {
    "objectID": "content/R/r-manuals/01-content.html#slides",
    "href": "content/R/r-manuals/01-content.html#slides",
    "title": "Evaluation and the causal revolution",
    "section": "Slides",
    "text": "Slides\n\n\n\n\n\n\nWarning\n\n\n\nImportant!!: In the “Class details” video, I say that there are three books for the class: the World Bank evaluation book, ’Metrics Matter, and Causal Inference: The Mixtape. That’s not the case this semester, since we’re using the new The Effect book, which replaces both ’Metrics Matter and the Mixtape. So ignore that part of the video. The slides are updated with the correct books, though: see here.\n\n\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/01-content.html#videos",
    "href": "content/R/r-manuals/01-content.html#videos",
    "title": "Evaluation and the causal revolution",
    "section": "Videos",
    "text": "Videos\n\n\n\n\n\n\nWarning\n\n\n\nImportant!!: In the “Class details” video, I say that there are three books for the class: the World Bank evaluation book, ’Metrics Matter, and Causal Inference: The Mixtape. That’s not the case this semester, since we’re using the new The Effect book, which replaces both ’Metrics Matter and the Mixtape. So ignore that part of the video. The slides are updated with the correct books, though: see here."
  },
  {
    "objectID": "content/R/r-manuals/01-content.html#in-class-stuff",
    "href": "content/R/r-manuals/01-content.html#in-class-stuff",
    "title": "Evaluation and the causal revolution",
    "section": "In-class stuff",
    "text": "In-class stuff\nHere are all the materials we’ll use in class:\n\nSession 1 in-person slides (PDF)\n\nRStudio labs:\n\nRStudio.cloud project\nProject .zip file\nLab slides 1: Markdown and universal writing (PDF)\nLab slides 2: Getting started with R and RStudio (PDF)\nLab slides 3: Data basics (PDF)\nLab slides 4: Visualize data with ggplot2 (PDF)\nLab slides 5: Transform data with dplyr (PDF)"
  },
  {
    "objectID": "content/R/r-manuals/02-content.html",
    "href": "content/R/r-manuals/02-content.html",
    "title": "Regression and inference",
    "section": "",
    "text": "Chapters 3 and 4 in The Effect [@Huntington-Klein:2021]"
  },
  {
    "objectID": "content/R/r-manuals/02-content.html#recommended-readings",
    "href": "content/R/r-manuals/02-content.html#recommended-readings",
    "title": "Regression and inference",
    "section": "Recommended readings",
    "text": "Recommended readings\nLook through your notes on regression from your last stats class. Also, you can skim through these resources:\n\n 5.1–5.4 in ModernDive [@IsmayKim:2018]\n 6.1–6.4 in ModernDive [@IsmayKim:2018]\n 7.1–7.3 in OpenIntro Statistics [@DiezBarrCetinkaya-Rundel:2017]\n 8.1 in OpenIntro Statistics [@DiezBarrCetinkaya-Rundel:2017]\n\nWe’ll review all this regression stuff in the videos, so don’t panic if this all looks terrifying! Also, take advantage of the videos that accompany the OpenIntro chapters. And also, the OpenIntro chapters are heavier on the math—don’t worry if you don’t understand everything."
  },
  {
    "objectID": "content/R/r-manuals/02-content.html#slides",
    "href": "content/R/r-manuals/02-content.html#slides",
    "title": "Regression and inference",
    "section": "Slides",
    "text": "Slides\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/02-content.html#videos",
    "href": "content/R/r-manuals/02-content.html#videos",
    "title": "Regression and inference",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "content/R/r-manuals/02-content.html#in-class-stuff",
    "href": "content/R/r-manuals/02-content.html#in-class-stuff",
    "title": "Regression and inference",
    "section": "In-class stuff",
    "text": "In-class stuff\nHere are all the materials we’ll use in class:\n\nSession 2 FAQ slides (PDF)\nErrors vs. warnings vs. messages (i.e. what to do when R shows you red text)\nR Markdown examples:\n\nExample R Markdown file used as a code-through or step-by-step teaching document:\n\nLots of blog posts here\nJulia Silge, “Modeling human/computer interactions on Star Trek from #TidyTuesday with workflowsets”\nBob Rudis, “Some Covid Donuts To End The Week”\nHolger K. von Jouanne-Diedrich, “The “Youth Bulge” of Afghanistan: The Hidden Force behind Political Instability”\n\nExample R Markdown file used as a publicly-consumable document:\n\nClick on the “Manuscript” menu item at this site\nSee the Rmd file here\n\n\n\nHands-on R materials:\n\nRStudio.cloud project\nProject .zip file\nGapminder data\nLab slides 1: Markdown and universal writing (PDF)\nLab slides 2: Getting started with R and RStudio (PDF)\nLab slides 3: Data basics (PDF)\nLab slides 4: Visualize data with ggplot2 (PDF)\nLab slides 5: Transform data with dplyr (PDF)\n restaurant_inspections.csv"
  },
  {
    "objectID": "content/R/r-manuals/02-content.html#bayesian-statistics-resources",
    "href": "content/R/r-manuals/02-content.html#bayesian-statistics-resources",
    "title": "Regression and inference",
    "section": "Bayesian statistics resources",
    "text": "Bayesian statistics resources\nIn class I briefly mentioned the difference between frequentist and Bayesian statistics. You can see a bunch of additional resources and examples of these two approaches to statistics here. This huge blog post also shows how to do multilevel models with Bayesian models."
  },
  {
    "objectID": "content/R/r-manuals/03-content.html",
    "href": "content/R/r-manuals/03-content.html",
    "title": "Theories of change and logic models",
    "section": "",
    "text": "Chapter 2 in Impact Evaluation in Practice [@wb-eval]\n Chapter 2 in Evaluation: A Systematic Approach [@RossiLipseyHenry:2019]. This is available on iCollege.\n Chapter 3 in Evaluation: A Systematic Approach [@RossiLipseyHenry:2019]. This is available on iCollege."
  },
  {
    "objectID": "content/R/r-manuals/03-content.html#slides",
    "href": "content/R/r-manuals/03-content.html#slides",
    "title": "Theories of change and logic models",
    "section": "Slides",
    "text": "Slides\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/03-content.html#videos",
    "href": "content/R/r-manuals/03-content.html#videos",
    "title": "Theories of change and logic models",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "content/R/r-manuals/04-content.html",
    "href": "content/R/r-manuals/04-content.html",
    "title": "Measurement and DAGs",
    "section": "",
    "text": "The witch trial scene from Monty Python and the Holy Grail\n Chapter 5 in Evaluation: A Systematic Approach [@RossiLipseyHenry:2019]. This is available on iCollege.\n Chapter 5 in The Effect [@Huntington-Klein:2021]\n\n\n\n\n\n Julia M. Rohrer, “Thinking Clearly About Correlations and Causation: Graphical Causal Models for Observational Data” [@Rohrer:2018] This will be posted on iCollege.\n Section 2 only (pp. 4–11) from Julian Schuessler and Peter Selb, “Graphical Causal Models for Survey Inference.” [@SchuesslerSelb:2019] The PDF is available at SocArXiv.\n Chapters 6 and 7 in The Effect [@Huntington-Klein:2021]\n\n\n\n\n\nThe example page on DAGs shows how to draw and analyze DAGs with both dagitty.net and R + ggdag"
  },
  {
    "objectID": "content/R/r-manuals/04-content.html#slides",
    "href": "content/R/r-manuals/04-content.html#slides",
    "title": "Measurement and DAGs",
    "section": "Slides",
    "text": "Slides\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/04-content.html#videos",
    "href": "content/R/r-manuals/04-content.html#videos",
    "title": "Measurement and DAGs",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "content/R/r-manuals/04-content.html#in-class-stuff",
    "href": "content/R/r-manuals/04-content.html#in-class-stuff",
    "title": "Measurement and DAGs",
    "section": "In-class stuff",
    "text": "In-class stuff\nHere are all the materials we’ll use in class:\n\nSession 4 FAQ slides (PDF)"
  },
  {
    "objectID": "content/R/r-manuals/05-content.html",
    "href": "content/R/r-manuals/05-content.html",
    "title": "DAGs and potential outcomes",
    "section": "",
    "text": "Prologue and at least one of the four acts from This American Life, “Gardens of Branching Paths,” episode #691, January 10, 2020\n Chapter 3 in Impact Evaluation in Practice [@wb-eval]\n Chapters 8, 9, and 10 in The Effect [@Huntington-Klein:2021]\n\n\n\n\nThe example page on potential outcomes, ATEs, and CATEs shows how to use R to calculate ATEs and CATEs"
  },
  {
    "objectID": "content/R/r-manuals/05-content.html#slides",
    "href": "content/R/r-manuals/05-content.html#slides",
    "title": "DAGs and potential outcomes",
    "section": "Slides",
    "text": "Slides\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/05-content.html#videos",
    "href": "content/R/r-manuals/05-content.html#videos",
    "title": "DAGs and potential outcomes",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "content/R/r-manuals/05-content.html#in-class-stuff",
    "href": "content/R/r-manuals/05-content.html#in-class-stuff",
    "title": "DAGs and potential outcomes",
    "section": "In-class stuff",
    "text": "In-class stuff\nHere are all the materials we’ll use in class:\n\nSession 5 FAQ slides (PDF)\n\n\nConfounding, unblocked\n\n\n\n\n\n\n\nConfounding, blocked\n\n\n\n\n\n\n\nMediation"
  },
  {
    "objectID": "content/R/r-manuals/06-content.html",
    "href": "content/R/r-manuals/06-content.html",
    "title": "Threats to validity",
    "section": "",
    "text": "Guido Imbens, “Statistical Significance, p-Values, and the Reporting of Uncertainty” [@Imbens:2021]. This is available on iCollege, and it’s also free here.\n Randall Munroe, “Significant”\n Alexander Coppock, “10 Things to Know About Statistical Power”\n Play around with FiveThirtyEight, “Hack Your Way To Scientific Glory”\n Chapter 9 in Impact Evaluation in Practice [@wb-eval]\n Chapter 11 in The Effect [@Huntington-Klein:2021]"
  },
  {
    "objectID": "content/R/r-manuals/06-content.html#slides",
    "href": "content/R/r-manuals/06-content.html#slides",
    "title": "Threats to validity",
    "section": "Slides",
    "text": "Slides\nThe slides for today’s lesson are available online as an HTML file. Use the buttons below to open the slides either as an interactive website or as a static PDF (for printing or storing for later). You can also click in the slides below and navigate through them with your left and right arrow keys.\n\n\n\n\n\n\nTip\n\n\n\nFun fact: If you type ? (or shift + /) while going through the slides, you can see a list of special slide-specific commands."
  },
  {
    "objectID": "content/R/r-manuals/06-content.html#videos",
    "href": "content/R/r-manuals/06-content.html#videos",
    "title": "Threats to validity",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "content/R/r-manuals/06-content.html#in-class-stuff",
    "href": "content/R/r-manuals/06-content.html#in-class-stuff",
    "title": "Threats to validity",
    "section": "In-class stuff",
    "text": "In-class stuff\nHere are all the materials we’ll use in class:\n\nSession 6 FAQ slides (PDF)\nZilch!\n Live R script\n restaurant_inspections.csv"
  },
  {
    "objectID": "content/R/r-manuals/test.html",
    "href": "content/R/r-manuals/test.html",
    "title": "R Manuals :: An Introduction to R",
    "section": "",
    "text": "This is an introduction to R (“GNU S”), a language and environment for statistical computing and graphics. R is similar to the award-winning1 S system, which was developed at Bell Laboratories by John Chambers et al. It provides a wide variety of statistical and graphical techniques (linear and nonlinear modelling, statistical tests, time series analysis, classification, clustering, ...).\nThis manual provides information on data types, programming elements, statistical modelling and graphics.\nThis manual is for R, version 4.3.0 Under development.\nCopyright © 1990 W. N. Venables\nCopyright © 1992 W. N. Venables & D. M. Smith\nCopyright © 1997 R. Gentleman & R. Ihaka\nCopyright © 1997, 1998 M. Maechler\nCopyright © 1999–2022 R Core Team\n\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that this permission notice may be stated in a translation approved by the R Core Team."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-r-environment",
    "href": "content/R/r-manuals/test.html#sec-the-r-environment",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.1 The R environment",
    "text": "1.1 The R environment\nR is an integrated suite of software facilities for data manipulation, calculation and graphical display. Among other things it has\n\nan effective data handling and storage facility,\na suite of operators for calculations on arrays, in particular matrices,\na large, coherent, integrated collection of intermediate tools for data analysis,\ngraphical facilities for data analysis and display either directly at the computer or on hardcopy, and\na well developed, simple and effective programming language (called ‘S’) which includes conditionals, loops, user defined recursive functions and input and output facilities. (Indeed most of the system supplied functions are themselves written in the S language.)\n\nThe term “environment” is intended to characterize it as a fully planned and coherent system, rather than an incremental accretion of very specific and inflexible tools, as is frequently the case with other data analysis software.\nR is very much a vehicle for newly developing methods of interactive data analysis. It has developed rapidly, and has been extended by a large collection of packages. However, most programs written in R are essentially ephemeral, written for a single piece of data analysis."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-related-software-and-documentation",
    "href": "content/R/r-manuals/test.html#sec-related-software-and-documentation",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.2 Related software and documentation",
    "text": "1.2 Related software and documentation\nR can be regarded as an implementation of the S language which was developed at Bell Laboratories by Rick Becker, John Chambers and Allan Wilks, and also forms the basis of the S-PLUS systems.\nThe evolution of the S language is characterized by four books by John Chambers and coauthors. For R, the basic reference is The New S Language: A Programming Environment for Data Analysis and Graphics by Richard A. Becker, John M. Chambers and Allan R. Wilks. The new features of the 1991 release of S are covered in Statistical Models in S edited by John M. Chambers and Trevor J. Hastie. The formal methods and classes of the methods package are based on those described in Programming with Data by John M. Chambers. See Section 20, for precise references.\nThere are now a number of books which describe how to use R for data analysis and statistics, and documentation for S/S-PLUS can typically be used with R, keeping the differences between the S implementations in mind. See What documentation exists for R in the R statistical system FAQ."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-r-and-statistics",
    "href": "content/R/r-manuals/test.html#sec-r-and-statistics",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.3 R and statistics",
    "text": "1.3 R and statistics\nOur introduction to the R environment did not mention statistics, yet many people use R as a statistics system. We prefer to think of it of an environment within which many classical and modern statistical techniques have been implemented. A few of these are built into the base R environment, but many are supplied as packages. There are about 25 packages supplied with R (called “standard” and “recommended” packages) and many more are available through the CRAN family of Internet sites (via https://CRAN.R-project.org) and elsewhere. More details on packages are given later (see Section 13).\nMost classical statistics and much of the latest methodology is available for use with R, but users may need to be prepared to do a little work to find it.\nThere is an important difference in philosophy between S (and hence R) and the other main statistical systems. In S a statistical analysis is normally done as a series of steps, with intermediate results being stored in objects. Thus whereas SAS and SPSS will give copious output from a regression or discriminant analysis, R will give minimal output and store the results in a fit object for subsequent interrogation by further R functions."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-r-and-the-window-system",
    "href": "content/R/r-manuals/test.html#sec-r-and-the-window-system",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.4 R and the window system",
    "text": "1.4 R and the window system\nThe most convenient way to use R is at a graphics workstation running a windowing system. This guide is aimed at users who have this facility. In particular we will occasionally refer to the use of R on an X window system although the vast bulk of what is said applies generally to any implementation of the R environment.\nMost users will find it necessary to interact directly with the operating system on their computer from time to time. In this guide, we mainly discuss interaction with the operating system on UNIX machines. If you are running R under Windows or macOS you will need to make some small adjustments.\nSetting up a workstation to take full advantage of the customizable features of R is a straightforward if somewhat tedious procedure, and will not be considered further here. Users in difficulty should seek local expert help."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-using-r-interactively",
    "href": "content/R/r-manuals/test.html#sec-using-r-interactively",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.5 Using R interactively",
    "text": "1.5 Using R interactively\nWhen you use the R program it issues a prompt when it expects input commands. The default prompt is >, which on UNIX might be the same as the shell prompt, and so it may appear that nothing is happening. However, as we shall see, it is easy to change to a different R prompt if you wish. We will assume that the UNIX shell prompt is $.\nIn using R under UNIX the suggested procedure for the first occasion is as follows:\n\nCreate a separate sub-directory, say work, to hold data files on which you will use R for this problem. This will be the working directory whenever you use R for this particular problem. R     $ mkdir work     $ cd work\nStart the R program with the command R     $ R\nAt this point R commands may be issued (see later).\nTo quit the R program the command is\n> q()\nAt this point you will be asked whether you want to save the data from your R session. On some systems this will bring up a dialog box, and on others you will receive a text prompt to which you can respond yes, no or cancel (a single letter abbreviation will do) to save the data before quitting, quit without saving, or return to the R session. Data which is saved will be available in future R sessions.\n\nFurther R sessions are simple.\n\nMake work the working directory and start the program as before: R     $ cd work     $ R\nUse the R program, terminating with the q() command at the end of the session.\n\nTo use R under Windows the procedure to follow is basically the same. Create a folder as the working directory, and set that in the Start In field in your R shortcut. Then launch R by double clicking on the icon."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-1.6-an-introductory-session",
    "href": "content/R/r-manuals/test.html#sec-1.6-an-introductory-session",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.6 1.6 An introductory session",
    "text": "1.6 1.6 An introductory session\nReaders wishing to get a feel for R at a computer before proceeding are strongly advised to work through the introductory session given in Section 15."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-getting-help-with-functions-and-features",
    "href": "content/R/r-manuals/test.html#sec-getting-help-with-functions-and-features",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.7 Getting help with functions and features",
    "text": "1.7 Getting help with functions and features\nR has an inbuilt help facility similar to the man facility of UNIX. To get more information on any specific named function, for example solve, the command is\n> help(solve)\nAn alternative is\n> ?solve\nFor a feature specified by special characters, the argument must be enclosed in double or single quotes, making it a “character string”: This is also necessary for a few words with syntactic meaning including if, for and function.\n> help(\"[[\")\nEither form of quote mark may be used to escape the other, as in the string \"It's important\". Our convention is to use double quote marks for preference.\nOn most R installations help is available in HTML format by running\n> help.start()\nwhich will launch a Web browser that allows the help pages to be browsed with hyperlinks. On UNIX, subsequent help requests are sent to the HTML-based help system. The ‘Search Engine and Keywords’ link in the page loaded by help.start() is particularly useful as it is contains a high-level concept list which searches though available functions. It can be a great way to get your bearings quickly and to understand the breadth of what R has to offer.\nThe help.search command (alternatively ??) allows searching for help in various ways. For example,\n> ??solve\nTry ?help.search for details and more examples.\nThe examples on a help topic can normally be run by\n> example(topic)\nWindows versions of R have other optional help systems: use\n> ?help\nfor further details."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-r-commands-case-sensitivity-etc.",
    "href": "content/R/r-manuals/test.html#sec-r-commands-case-sensitivity-etc.",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.8 R commands, case sensitivity, etc.",
    "text": "1.8 R commands, case sensitivity, etc.\nTechnically R is an expression language with a very simple syntax. It is case sensitive as are most UNIX based packages, so A and a are different symbols and would refer to different variables. The set of symbols which can be used in R names depends on the operating system and country within which R is being run (technically on the locale in use). Normally all alphanumeric symbols are allowed2 (and in some countries this includes accented letters) plus . and _‘, with the restriction that a name must start with’. or a letter, and if it starts with . the second character must not be a digit. Names are effectively unlimited in length.\nElementary commands consist of either expressions or assignments. If an expression is given as a command, it is evaluated, printed (unless specifically made invisible), and the value is lost. An assignment also evaluates an expression and passes the value to a variable but the result is not automatically printed.\nCommands are separated either by a semi-colon (;), or by a newline. Elementary commands can be grouped together into one compound expression by braces ({’ and ’}). Comments can be put almost3 anywhere, starting with a hashmark (#), everything to the end of the line is a comment.\nIf a command is not complete at the end of a line, R will give a different prompt, by default\n+\non second and subsequent lines and continue to read input until the command is syntactically complete. This prompt may be changed by the user. We will generally omit the continuation prompt and indicate continuation by simple indenting.\nCommand lines entered at the console are limited4 to about 4095 bytes (not characters)."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-recall-and-correction-of-previous-commands",
    "href": "content/R/r-manuals/test.html#sec-recall-and-correction-of-previous-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.9 Recall and correction of previous commands",
    "text": "1.9 Recall and correction of previous commands\nUnder many versions of UNIX and on Windows, R provides a mechanism for recalling and re-executing previous commands. The vertical arrow keys on the keyboard can be used to scroll forward and backward through a command history. Once a command is located in this way, the cursor can be moved within the command using the horizontal arrow keys, and characters can be removed with the DEL key or added with the other keys. More details are provided later: see Section 17 .\nThe recall and editing capabilities under UNIX are highly customizable. You can find out how to do this by reading the manual entry for the readline library.\nAlternatively, the Emacs text editor provides more general support mechanisms (via ESS, Emacs Speaks Statistics) for working interactively with R. See R and Emacs in The R statistical system FAQ."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-executing-commands-from-or-diverting-output-to-a-file",
    "href": "content/R/r-manuals/test.html#sec-executing-commands-from-or-diverting-output-to-a-file",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.10 Executing commands from or diverting output to a file",
    "text": "1.10 Executing commands from or diverting output to a file\nIf commands5 are stored in an external file, say commands.R in the working directory work, they may be executed at any time in an R session with the command\n> source(\"commands.R\")\nFor Windows Source is also available on the File menu. The function sink,\n> sink(\"record.lis\")\nwill divert all subsequent output from the console to an external file, record.lis. The command\n> sink()\nrestores it to the console once again."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-data-permanency-and-removing-objects",
    "href": "content/R/r-manuals/test.html#sec-data-permanency-and-removing-objects",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.11 Data permanency and removing objects",
    "text": "1.11 Data permanency and removing objects\nThe entities that R creates and manipulates are known as objects. These may be variables, arrays of numbers, character strings, functions, or more general structures built from such components.\nDuring an R session, objects are created and stored by name (we discuss this process in the next section). The R command\n> objects()\n(alternatively, ls()) can be used to display the names of (most of) the objects which are currently stored within R. The collection of objects currently stored is called the workspace.\nTo remove objects the function rm is available:\n> rm(x, y, z, ink, junk, temp, foo, bar)\nAll objects created during an R session can be stored permanently in a file for use in future R sessions. At the end of each R session you are given the opportunity to save all the currently available objects. If you indicate that you want to do this, the objects are written to a file called .RData6 in the current directory, and the command lines used in the session are saved to a file called .Rhistory.\nWhen R is started at later time from the same directory it reloads the workspace from this file. At the same time the associated commands history is reloaded.\nIt is recommended that you should use separate working directories for analyses conducted with R. It is quite common for objects with names x and y to be created during an analysis. Names like this are often meaningful in the context of a single analysis, but it can be quite hard to decide what they might be when the several analyses have been conducted in the same directory."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-vectors-and-assignment",
    "href": "content/R/r-manuals/test.html#sec-vectors-and-assignment",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.1 Vectors and assignment",
    "text": "2.1 Vectors and assignment\nR operates on named data structures. The simplest such structure is the numeric vector, which is a single entity consisting of an ordered collection of numbers. To set up a vector named x, say, consisting of five numbers, namely 10.4, 5.6, 3.1, 6.4 and 21.7, use the R command\n> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)\nThis is an assignment statement using the function c() which in this context can take an arbitrary number of vector arguments and whose value is a vector got by concatenating its arguments end to end.7\nA number occurring by itself in an expression is taken as a vector of length one.\nNotice that the assignment operator (<-), which consists of the two characters <’ (“less than”) and ‘- (“minus”) occurring strictly side-by-side and it ’points’ to the object receiving the value of the expression. In most contexts the = operator can be used as an alternative.\nAssignment can also be made using the function assign(). An equivalent way of making the same assignment as above is with:\n> assign(\"x\", c(10.4, 5.6, 3.1, 6.4, 21.7))\nThe usual operator, <-, can be thought of as a syntactic short-cut to this.\nAssignments can also be made in the other direction, using the obvious change in the assignment operator. So the same assignment could be made using\n> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x\nIf an expression is used as a complete command, the value is printed and lost8. So now if we were to use the command\n> 1/x\nthe reciprocals of the five values would be printed at the terminal (and the value of x, of course, unchanged).\nThe further assignment\n> y <- c(x, 0, x)\nwould create a vector y with 11 entries consisting of two copies of x with a zero in the middle place."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-vector-arithmetic",
    "href": "content/R/r-manuals/test.html#sec-vector-arithmetic",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.2 Vector arithmetic",
    "text": "2.2 Vector arithmetic\nVectors can be used in arithmetic expressions, in which case the operations are performed element by element. Vectors occurring in the same expression need not all be of the same length. If they are not, the value of the expression is a vector with the same length as the longest vector which occurs in the expression. Shorter vectors in the expression are recycled as often as need be (perhaps fractionally) until they match the length of the longest vector. In particular a constant is simply repeated. So with the above assignments the command\n> v <- 2*x + y + 1\ngenerates a new vector v of length 11 constructed by adding together, element by element, 2*x repeated 2.2 times, y repeated just once, and 1 repeated 11 times.\nThe elementary arithmetic operators are the usual +, -, *, / and ^ for raising to a power. In addition all of the common arithmetic functions are available. log, exp, sin, cos, tan, sqrt, and so on, all have their usual meaning. max and min select the largest and smallest elements of a vector respectively. range is a function whose value is a vector of length two, namely c(min(x), max(x)). length(x) is the number of elements in x, sum(x) gives the total of the elements in x, and prod(x) their product.\nTwo statistical functions are mean(x) which calculates the sample mean, which is the same as sum(x)/length(x), and var(x) which gives\nsum((x-mean(x))^2)/(length(x)-1)\nor sample variance. If the argument to var() is an n-by-p matrix the value is a p-by-p sample covariance matrix got by regarding the rows as independent p-variate sample vectors.\nsort(x) returns a vector of the same size as x with the elements arranged in increasing order; however there are other more flexible sorting facilities available (see order() or sort.list() which produce a permutation to do the sorting).\nNote that max and min select the largest and smallest values in their arguments, even if they are given several vectors. The parallel maximum and minimum functions pmax and pmin return a vector (of length equal to their longest argument) that contains in each element the largest (smallest) element in that position in any of the input vectors.\nFor most purposes the user will not be concerned if the “numbers” in a numeric vector are integers, reals or even complex. Internally calculations are done as double precision real numbers, or double precision complex numbers if the input data are complex.\nTo work with complex numbers, supply an explicit complex part. Thus\nsqrt(-17)\nwill give NaN and a warning, but\nsqrt(-17+0i)\nwill do the computations as complex numbers."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-generating-regular-sequences",
    "href": "content/R/r-manuals/test.html#sec-generating-regular-sequences",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.3 Generating regular sequences",
    "text": "2.3 Generating regular sequences\nR has a number of facilities for generating commonly used sequences of numbers. For example 1:30 is the vector c(1, 2, …, 29, 30). The colon operator has high priority within an expression, so, for example 2*1:15 is the vector c(2, 4, …, 28, 30). Put n <- 10 and compare the sequences 1:n-1 and 1:(n-1).\nThe construction 30:1 may be used to generate a sequence backwards.\nThe function seq() is a more general facility for generating sequences. It has five arguments, only some of which may be specified in any one call. The first two arguments, if given, specify the beginning and end of the sequence, and if these are the only two arguments given the result is the same as the colon operator. That is seq(2,10) is the same vector as 2:10.\nArguments to seq(), and to many other R functions, can also be given in named form, in which case the order in which they appear is irrelevant. The first two arguments may be named from=``value and to=``value; thus seq(1,30), seq(from=1, to=30) and seq(to=30, from=1) are all the same as 1:30. The next two arguments to seq() may be named by=``value and length=``value, which specify a step size and a length for the sequence respectively. If neither of these is given, the default by=1 is assumed.\nFor example\n> seq(-5, 5, by=.2) -> s3\ngenerates in s3 the vector c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0). Similarly\n> s4 <- seq(length=51, from=-5, by=.2)\ngenerates the same vector in s4.\nThe fifth argument may be named along=``vector, which is normally used as the only argument to create the sequence 1, 2, …, length(``vector), or the empty sequence if the vector is empty (as it can be).\nA related function is rep() which can be used for replicating an object in various complicated ways. The simplest form is\n> s5 <- rep(x, times=5)\nwhich will put five copies of x end-to-end in s5. Another useful version is\n> s6 <- rep(x, each=5)\nwhich repeats each element of x five times before moving on to the next."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-logical-vectors",
    "href": "content/R/r-manuals/test.html#sec-logical-vectors",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.4 Logical vectors",
    "text": "2.4 Logical vectors\nAs well as numerical vectors, R allows manipulation of logical quantities. The elements of a logical vector can have the values TRUE, FALSE, and NA (for “not available”, see below). The first two are often abbreviated as T and F, respectively. Note however that T and F are just variables which are set to TRUE and FALSE by default, but are not reserved words and hence can be overwritten by the user. Hence, you should always use TRUE and FALSE.\nLogical vectors are generated by conditions. For example\n> temp <- x > 13\nsets temp as a vector of the same length as x with values FALSE corresponding to elements of x where the condition is not met and TRUE where it is.\nThe logical operators are <, <=, >, >=, == for exact equality and != for inequality. In addition if c1 and c2 are logical expressions, then c1 & c2 is their intersection (“and”), c1 | c2 is their union (“or”), and !c1 is the negation of c1.\nLogical vectors may be used in ordinary arithmetic, in which case they are coerced into numeric vectors, FALSE becoming 0 and TRUE becoming 1. However there are situations where logical vectors and their coerced numeric counterparts are not equivalent, for example see the next subsection."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-missing-values",
    "href": "content/R/r-manuals/test.html#sec-missing-values",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.5 Missing values",
    "text": "2.5 Missing values\nIn some cases the components of a vector may not be completely known. When an element or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an NA becomes an NA. The motivation for this rule is simply that if the specification of an operation is incomplete, the result cannot be known and hence is not available.\nThe function is.na(x) gives a logical vector of the same size as x with value TRUE if and only if the corresponding element in x is NA.\n> z <- c(1:3,NA);  ind <- is.na(z)\nNotice that the logical expression x == NA is quite different from is.na(x) since NA is not really a value but a marker for a quantity that is not available. Thus x == NA is a vector of the same length as x all of whose values are NA as the logical expression itself is incomplete and hence undecidable.\nNote that there is a second kind of “missing” values which are produced by numerical computation, the so-called Not a Number, NaN, values. Examples are\n> 0/0\nor\n> Inf - Inf\nwhich both give NaN since the result cannot be defined sensibly.\nIn summary, is.na(xx) is TRUE both for NA and NaN values. To differentiate these, is.nan(xx) is only TRUE for NaNs.\nMissing values are sometimes printed as <NA> when character vectors are printed without quotes."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-character-vectors",
    "href": "content/R/r-manuals/test.html#sec-character-vectors",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.6 Character vectors",
    "text": "2.6 Character vectors\nCharacter quantities and character vectors are used frequently in R, for example as plot labels. Where needed they are denoted by a sequence of characters delimited by the double quote character, e.g., \"x-values\", \"New iteration results\".\nCharacter strings are entered using either matching double (\") or single (') quotes, but are printed using double quotes (or sometimes without quotes). They use C-style escape sequences, using \\ as the escape character, so \\ is entered and printed as \\\\, and inside double quotes \" is entered as \\\". Other useful escape sequences are \\n, newline, \\t, tab and \\b, backspace—see ?Quotes for a full list.\nCharacter vectors may be concatenated into a vector by the c() function; examples of their use will emerge frequently.\nThe paste() function takes an arbitrary number of arguments and concatenates them one by one into character strings. Any numbers given among the arguments are coerced into character strings in the evident way, that is, in the same way they would be if they were printed. The arguments are by default separated in the result by a single blank character, but this can be changed by the named argument, sep=``string, which changes it to string, possibly empty.\nFor example\n> labs <- paste(c(\"X\",\"Y\"), 1:10, sep=\"\")\nmakes labs into the character vector\nc(\"X1\", \"Y2\", \"X3\", \"Y4\", \"X5\", \"Y6\", \"X7\", \"Y8\", \"X9\", \"Y10\")\nNote particularly that recycling of short lists takes place here too; thus c(\"X\", \"Y\") is repeated 5 times to match the sequence 1:10. 9"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-index-vectors-selecting-and-modifying-subsets-of-a-data-set",
    "href": "content/R/r-manuals/test.html#sec-index-vectors-selecting-and-modifying-subsets-of-a-data-set",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.7 Index vectors; selecting and modifying subsets of a data set",
    "text": "2.7 Index vectors; selecting and modifying subsets of a data set\nSubsets of the elements of a vector may be selected by appending to the name of the vector an index vector in square brackets. More generally any expression that evaluates to a vector may have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression.\nSuch index vectors can be any of four distinct types.\n\nA logical vector. In this case the index vector is recycled to the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected and those corresponding to FALSE are omitted. For example\n> y <- x[!is.na(x)]\ncreates (or re-creates) an object y which will contain the non-missing values of x, in the same order. Note that if x has missing values, y will be shorter than x. Also\n> (x+1)[(!is.na(x)) & x>0] -> z\ncreates an object z and places in it the values of the vector x+1 for which the corresponding value in x was both non-missing and positive.\nA vector of positive integral quantities. In this case the values in the index vector must lie in the set {1, 2, …, length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x and\n> x[1:10]\nselects the first 10 elements of x (assuming length(x) is not less than 10). Also\n> c(\"x\",\"y\")[rep(c(1,2,2,1), times=4)]\n(an admittedly unlikely thing to do) produces a character vector of length 16 consisting of \"x\", \"y\", \"y\", \"x\" repeated four times.\nA vector of negative integral quantities. Such an index vector specifies the values to be excluded rather than included. Thus\n> y <- x[-(1:5)]\ngives y all but the first five elements of x.\nA vector of character strings. This possibility only applies where an object has a names attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above.\n> fruit <- c(5, 10, 1, 20)\n> names(fruit) <- c(\"orange\", \"banana\", \"apple\", \"peach\")\n> lunch <- fruit[c(\"apple\",\"orange\")]\nThe advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with data frames, as we shall see later.\n\nAn indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form vector[``index_vector] as having an arbitrary expression in place of the vector name does not make much sense here.\nFor example\n> x[is.na(x)] <- 0\nreplaces any missing values in x by zeros and\n> y[y < 0] <- -y[y < 0]\nhas the same effect as\n> y <- abs(y)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-other-types-of-objects",
    "href": "content/R/r-manuals/test.html#sec-other-types-of-objects",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.8 Other types of objects",
    "text": "2.8 Other types of objects\nVectors are the most important type of object in R, but there are several others which we will meet more formally in later sections.\n\nmatrices or more generally arrays are multi-dimensional generalizations of vectors. In fact, they are vectors that can be indexed by two or more indices and will be printed in special ways. See Section 5.\nfactors provide compact ways to handle categorical data. See Section 4.\nlists are a general form of vector in which the various elements need not be of the same type, and are often themselves vectors or lists. Lists provide a convenient way to return the results of a statistical computation. See Section 6.1.\ndata frames are matrix-like structures, in which the columns can be of different types. Think of data frames as ‘data matrices’ with one row per observational unit but with (possibly) both numerical and categorical variables. Many experiments are best described by data frames: the treatments are categorical but the response is numeric. See Section 6.3.\nfunctions are themselves objects in R which can be stored in the project’s workspace. This provides a simple and convenient way to extend R. See Section 10 ."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-intrinsic-attributes:-mode-and-length",
    "href": "content/R/r-manuals/test.html#sec-intrinsic-attributes:-mode-and-length",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.1 Intrinsic attributes: mode and length",
    "text": "3.1 Intrinsic attributes: mode and length\nThe entities R operates on are technically known as objects. Examples are vectors of numeric (real) or complex values, vectors of logical values and vectors of character strings. These are known as “atomic” structures since their components are all of the same type, or mode, namely numeric10, complex, logical, character and raw.\nVectors must have their values all of the same mode. Thus any given vector must be unambiguously either logical, numeric, complex, character or raw. (The only apparent exception to this rule is the special “value” listed as NA for quantities not available, but in fact there are several types of NA). Note that a vector can be empty and still have a mode. For example the empty character string vector is listed as character(0) and the empty numeric vector as numeric(0).\nR also operates on objects called lists, which are of mode list. These are ordered sequences of objects which individually can be of any mode. lists are known as “recursive” rather than atomic structures since their components can themselves be lists in their own right.\nThe other recursive structures are those of mode function and expression. Functions are the objects that form part of the R system along with similar user written functions, which we discuss in some detail later. Expressions as objects form an advanced part of R which will not be discussed in this guide, except indirectly when we discuss formulae used with modeling in R.\nBy the mode of an object we mean the basic type of its fundamental constituents. This is a special case of a “property” of an object. Another property of every object is its length. The functions mode(``object) and length(``object) can be used to find out the mode and length of any defined structure 11.\nFurther properties of an object are usually provided by attributes(``object), see Section 3.3. Because of this, mode and length are also called “intrinsic attributes” of an object.\nFor example, if z is a complex vector of length 100, then in an expression mode(z) is the character string \"complex\" and length(z) is 100.\nR caters for changes of mode almost anywhere it could be considered sensible to do so, (and a few where it might not be). For example with\n> z <- 0:9\nwe could put\n> digits <- as.character(z)\nafter which digits is the character vector c(\"0\", \"1\", \"2\", …, \"9\"). A further coercion, or change of mode, reconstructs the numerical vector again:\n> d <- as.integer(digits)\nNow d and z are the same.12 There is a large collection of functions of the form as.``something() for either coercion from one mode to another, or for investing an object with some other attribute it may not already possess. The reader should consult the different help files to become familiar with them."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-changing-the-length-of-an-object",
    "href": "content/R/r-manuals/test.html#sec-changing-the-length-of-an-object",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.2 Changing the length of an object",
    "text": "3.2 Changing the length of an object\nAn “empty” object may still have a mode. For example\n> e <- numeric()\nmakes e an empty vector structure of mode numeric. Similarly character() is a empty character vector, and so on. Once an object of any size has been created, new components may be added to it simply by giving it an index value outside its previous range. Thus\n> e[3] <- 17\nnow makes e a vector of length 3, (the first two components of which are at this point both NA). This applies to any structure at all, provided the mode of the additional component(s) agrees with the mode of the object in the first place.\nThis automatic adjustment of lengths of an object is used often, for example in the scan() function for input. (see Section 7.2.)\nConversely to truncate the size of an object requires only an assignment to do so. Hence if alpha is an object of length 10, then\n> alpha <- alpha[2 * 1:5]\nmakes it an object of length 5 consisting of just the former components with even index. (The old indices are not retained, of course.) We can then retain just the first three values by\n> length(alpha) <- 3\nand vectors can be extended (by missing values) in the same way."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-getting-and-setting-attributes",
    "href": "content/R/r-manuals/test.html#sec-getting-and-setting-attributes",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.3 Getting and setting attributes",
    "text": "3.3 Getting and setting attributes\nThe function attributes(``object) returns a list of all the non-intrinsic attributes currently defined for that object. The function attr(``object, ``name) can be used to select a specific attribute. These functions are rarely used, except in rather special circumstances when some new attribute is being created for some particular purpose, for example to associate a creation date or an operator with an R object. The concept, however, is very important.\nSome care should be exercised when assigning or deleting attributes since they are an integral part of the object system used in R.\nWhen it is used on the left hand side of an assignment it can be used either to associate a new attribute with object or to change an existing one. For example\n> attr(z, \"dim\") <- c(10,10)\nallows R to treat z as if it were a 10-by-10 matrix."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-class-of-an-object",
    "href": "content/R/r-manuals/test.html#sec-the-class-of-an-object",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.4 The class of an object",
    "text": "3.4 The class of an object\nAll objects in R have a class, reported by the function class. For simple vectors this is just the mode, for example \"numeric\", \"logical\", \"character\" or \"list\", but \"matrix\", \"array\", \"factor\" and \"data.frame\" are other possible values.\nA special attribute known as the class of the object is used to allow for an object-oriented style13 of programming in R. For example if an object has class \"data.frame\", it will be printed in a certain way, the plot() function will display it graphically in a certain way, and other so-called generic functions such as summary() will react to it as an argument in a way sensitive to its class.\nTo remove temporarily the effects of class, use the function unclass(). For example if winter has the class \"data.frame\" then\n> winter\nwill print it in data frame form, which is rather like a matrix, whereas\n> unclass(winter)\nwill print it as an ordinary list. Only in rather special situations do you need to use this facility, but one is when you are learning to come to terms with the idea of class and generic functions.\nGeneric functions and classes will be discussed further in Object orientation, but only briefly."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-4.1-a-specific-example",
    "href": "content/R/r-manuals/test.html#sec-4.1-a-specific-example",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.1 4.1 A specific example",
    "text": "4.1 4.1 A specific example\nSuppose, for example, we have a sample of 30 tax accountants from all the states and territories of Australia14 and their individual state of origin is specified by a character vector of state mnemonics as\n> state <- c(\"tas\", \"sa\",  \"qld\", \"nsw\", \"nsw\", \"nt\",  \"wa\",  \"wa\",\n             \"qld\", \"vic\", \"nsw\", \"vic\", \"qld\", \"qld\", \"sa\",  \"tas\",\n             \"sa\",  \"nt\",  \"wa\",  \"vic\", \"qld\", \"nsw\", \"nsw\", \"wa\",\n             \"sa\",  \"act\", \"nsw\", \"vic\", \"vic\", \"act\")\nNotice that in the case of a character vector, “sorted” means sorted in alphabetical order.\nA factor is similarly created using the factor() function:\n> statef <- factor(state)\nThe print() function handles factors slightly differently from other objects:\n> statef\n [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa\n[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act\nLevels:  act nsw nt qld sa tas vic wa\nTo find out the levels of a factor the function levels() can be used.\n> levels(statef)\n[1] \"act\" \"nsw\" \"nt\"  \"qld\" \"sa\"  \"tas\" \"vic\" \"wa\"\n\n\n\n• The function tapply() and ragged arrays\n  \n\n\n\n• Ordered factors"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-function-tapply-and-ragged-arrays",
    "href": "content/R/r-manuals/test.html#sec-the-function-tapply-and-ragged-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.2 The function tapply() and ragged arrays",
    "text": "4.2 The function tapply() and ragged arrays\nTo continue the previous example, suppose we have the incomes of the same tax accountants in another vector (in suitably large units of money)\n> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,\n               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,\n               59, 46, 58, 43)\nTo calculate the sample mean income for each state we can now use the special function tapply():\n> incmeans <- tapply(incomes, statef, mean)\ngiving a means vector with the components labelled by the levels\n   act    nsw     nt    qld     sa    tas    vic     wa\n44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250\nThe function tapply() is used to apply a function, here mean(), to each group of components of the first argument, here incomes, defined by the levels of the second component, here statef15, as if they were separate vector structures. The result is a structure of the same length as the levels attribute of the factor containing the results. The reader should consult the help document for more details.\nSuppose further we needed to calculate the standard errors of the state income means. To do this we need to write an R function to calculate the standard error for any given vector. Since there is an builtin function var() to calculate the sample variance, such a function is a very simple one liner, specified by the assignment:\n> stdError <- function(x) sqrt(var(x)/length(x))\n(Writing functions will be considered later in Section 10 . Note that R’s a builtin function sd() is something different.) After this assignment, the standard errors are calculated by\n> incster <- tapply(incomes, statef, stdError)\nand the values calculated are then\n> incster\nact    nsw  nt    qld     sa tas   vic     wa\n1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575\nAs an exercise you may care to find the usual 95% confidence limits for the state mean incomes. To do this you could use tapply() once more with the length() function to find the sample sizes, and the qt() function to find the percentage points of the appropriate t-distributions. (You could also investigate R’s facilities for t-tests.)\nThe function tapply() can also be used to handle more complicated indexing of a vector by multiple categories. For example, we might wish to split the tax accountants by both state and sex. However in this simple instance (just one factor) what happens can be thought of as follows. The values in the vector are collected into groups corresponding to the distinct entries in the factor. The function is then applied to each of these groups individually. The value is a vector of function results, labelled by the levels attribute of the factor.\nThe combination of a vector and a labelling factor is an example of what is sometimes called a ragged array, since the subclass sizes are possibly irregular. When the subclass sizes are all the same the indexing may be done implicitly and much more efficiently, as we see in the next section."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-ordered-factors",
    "href": "content/R/r-manuals/test.html#sec-ordered-factors",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.3 Ordered factors",
    "text": "4.3 Ordered factors\nThe levels of factors are stored in alphabetical order, or in the order they were specified to factor if they were specified explicitly.\nSometimes the levels will have a natural ordering that we want to record and want our statistical analysis to make use of. The ordered() function creates such ordered factors but is otherwise identical to factor. For most purposes the only difference between ordered and unordered factors is that the former are printed showing the ordering of the levels, but the contrasts generated for them in fitting linear models are different."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-arrays",
    "href": "content/R/r-manuals/test.html#sec-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.1 Arrays",
    "text": "5.1 Arrays\nAn array can be considered as a multiply subscripted collection of data entries, for example numeric. R allows simple facilities for creating and handling arrays, and in particular the special case of matrices.\nA dimension vector is a vector of non-negative integers. If its length is k then the array is k-dimensional, e.g. a matrix is a 2-dimensional array. The dimensions are indexed from one up to the values given in the dimension vector.\nA vector can be used by R as an array only if it has a dimension vector as its dim attribute. Suppose, for example, z is a vector of 1500 elements. The assignment\n> dim(z) <- c(3,5,100)\ngives it the dim attribute that allows it to be treated as a 3 by 5 by 100 array.\nOther functions such as matrix() and array() are available for simpler and more natural looking assignments, as we shall see in The array() function.\nThe values in the data vector give the values in the array in the same order as they would occur in FORTRAN, that is “column major order,” with the first subscript moving fastest and the last subscript slowest.\nFor example if the dimension vector for an array, say a, is c(3,4,2) then there are 3 * 4 * 2 = 24 entries in a and the data vector holds them in the order a[1,1,1], a[2,1,1], …, a[2,4,2], a[3,4,2].\nArrays can be one-dimensional: such arrays are usually treated in the same way as vectors (including when printing), but the exceptions can cause confusion."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-array-indexing.-subsections-of-an-array",
    "href": "content/R/r-manuals/test.html#sec-array-indexing.-subsections-of-an-array",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.2 Array indexing. Subsections of an array",
    "text": "5.2 Array indexing. Subsections of an array\nIndividual elements of an array may be referenced by giving the name of the array followed by the subscripts in square brackets, separated by commas.\nMore generally, subsections of an array may be specified by giving a sequence of index vectors in place of subscripts; however if any index position is given an empty index vector, then the full range of that subscript is taken.\nContinuing the previous example, a[2,,] is a 4 * 2 array with dimension vector c(4,2) and data vector containing the values\nc(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],\n  a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])\nin that order. a[,,] stands for the entire array, which is the same as omitting the subscripts entirely and using a alone.\nFor any array, say Z, the dimension vector may be referenced explicitly as dim(Z) (on either side of an assignment).\nAlso, if an array name is given with just one subscript or index vector, then the corresponding values of the data vector only are used; in this case the dimension vector is ignored. This is not the case, however, if the single index is not a vector but itself an array, as we next discuss."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-index-matrices",
    "href": "content/R/r-manuals/test.html#sec-index-matrices",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.3 Index matrices",
    "text": "5.3 Index matrices\nAs well as an index vector in any subscript position, a matrix may be used with a single index matrix in order either to assign a vector of quantities to an irregular collection of elements in the array, or to extract an irregular collection as a vector.\nA matrix example makes the process clear. In the case of a doubly indexed array, an index matrix may be given consisting of two columns and as many rows as desired. The entries in the index matrix are the row and column indices for the doubly indexed array. Suppose for example we have a 4 by 5 array X and we wish to do the following:\n\nExtract elements X[1,3], X[2,2] and X[3,1] as a vector structure, and\nReplace these entries in the array X by zeroes.\n\nIn this case we need a 3 by 2 subscript array, as in the following example.\n> x <- array(1:20, dim=c(4,5))   # Generate a 4 by 5 array.\n> x\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n> i <- array(c(1:3,3:1), dim=c(3,2))\n> i                             # i is a 3 by 2 index array.\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    2\n[3,]    3    1\n> x[i]                          # Extract those elements\n[1] 9 6 3\n> x[i] <- 0                     # Replace those elements by zeros.\n> x\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    0   13   17\n[2,]    2    0   10   14   18\n[3,]    0    7   11   15   19\n[4,]    4    8   12   16   20\n>\nNegative indices are not allowed in index matrices. NA and zero values are allowed: rows in the index matrix containing a zero are ignored, and rows containing an NA produce an NA in the result.\nAs a less trivial example, suppose we wish to generate an (unreduced) design matrix for a block design defined by factors blocks (b levels) and varieties (v levels). Further suppose there are n plots in the experiment. We could proceed as follows:\n> Xb <- matrix(0, n, b)\n> Xv <- matrix(0, n, v)\n> ib <- cbind(1:n, blocks)\n> iv <- cbind(1:n, varieties)\n> Xb[ib] <- 1\n> Xv[iv] <- 1\n> X <- cbind(Xb, Xv)\nTo construct the incidence matrix, N say, we could use\n> N <- crossprod(Xb, Xv)\nHowever a simpler direct way of producing this matrix is to use table():\n> N <- table(blocks, varieties)\nIndex matrices must be numerical: any other form of matrix (e.g. a logical or character matrix) supplied as a matrix is treated as an indexing vector."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-array-function",
    "href": "content/R/r-manuals/test.html#sec-the-array-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.4 The array() function",
    "text": "5.4 The array() function\nAs well as giving a vector structure a dim attribute, arrays can be constructed from vectors by the array function, which has the form\n> Z <- array(data_vector, dim_vector)\nFor example, if the vector h contains 24 or fewer, numbers then the command\n> Z <- array(h, dim=c(3,4,2))\nwould use h to set up 3 by 4 by 2 array in Z. If the size of h is exactly 24 the result is the same as\n> Z <- h ; dim(Z) <- c(3,4,2)\nHowever if h is shorter than 24, its values are recycled from the beginning again to make it up to size 24 (see The recycling rule) but dim(h) <- c(3,4,2) would signal an error about mismatching length. As an extreme but common example\n> Z <- array(0, c(3,4,2))\nmakes Z an array of all zeros.\nAt this point dim(Z) stands for the dimension vector c(3,4,2), and Z[1:24] stands for the data vector as it was in h, and Z[] with an empty subscript or Z with no subscript stands for the entire array as an array.\nArrays may be used in arithmetic expressions and the result is an array formed by element-by-element operations on the data vector. The dim attributes of operands generally need to be the same, and this becomes the dimension vector of the result. So if A, B and C are all similar arrays, then\n> D <- 2*A*B + C + 1\nmakes D a similar array with its data vector being the result of the given element-by-element operations. However the precise rule concerning mixed array and vector calculations has to be considered a little more carefully.\n\n5.4.1 Mixed vector and array arithmetic. The recycling rule\nThe precise rule affecting element by element mixed calculations with vectors and arrays is somewhat quirky and hard to find in the references. From experience we have found the following to be a reliable guide.\n\nThe expression is scanned from left to right.\nAny short vector operands are extended by recycling their values until they match the size of any other operands.\nAs long as short vectors and arrays only are encountered, the arrays must all have the same dim attribute or an error results.\nAny vector operand longer than a matrix or array operand generates an error.\nIf array structures are present and no error or coercion to vector has been precipitated, the result is an array structure with the common dim attribute of its array operands."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-outer-product-of-two-arrays",
    "href": "content/R/r-manuals/test.html#sec-the-outer-product-of-two-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.5 The outer product of two arrays",
    "text": "5.5 The outer product of two arrays\nAn important operation on arrays is the outer product. If a and b are two numeric arrays, their outer product is an array whose dimension vector is obtained by concatenating their two dimension vectors (order is important), and whose data vector is got by forming all possible products of elements of the data vector of a with those of b. The outer product is formed by the special operator %o%:\n> ab <- a %o% b\nAn alternative is\n> ab <- outer(a, b, \"*\")\nThe multiplication function can be replaced by an arbitrary function of two variables. For example if we wished to evaluate the function f(x; y) = cos(y)/(1 + x^2) over a regular grid of values with x- and y-coordinates defined by the R vectors x and y respectively, we could proceed as follows:\n> f <- function(x, y) cos(y)/(1 + x^2)\n> z <- outer(x, y, f)\nIn particular the outer product of two ordinary vectors is a doubly subscripted array (that is a matrix, of rank at most 1). Notice that the outer product operator is of course non-commutative. Defining your own R functions will be considered further in Section 10 .\n\n5.5.1 An example: Determinants of 2 by 2 single-digit matrices\nAs an artificial but cute example, consider the determinants of 2 by 2 matrices [a, b; c, d] where each entry is a non-negative integer in the range 0, 1, …, 9, that is a digit.\nThe problem is to find the determinants, ad - bc, of all possible matrices of this form and represent the frequency with which each value occurs as a high density plot. This amounts to finding the probability distribution of the determinant if each digit is chosen independently and uniformly at random.\nA neat way of doing this uses the outer() function twice:\n> d <- outer(0:9, 0:9)\n> fr <- table(outer(d, d, \"-\"))\n> plot(fr, xlab=\"Determinant\", ylab=\"Frequency\")\nNotice that plot() here uses a histogram like plot method, because it “sees” that fr is of class \"table\". The “obvious” way of doing this problem with for loops, to be discussed in Loops and conditional execution, is so inefficient as to be impractical.\nIt is also perhaps surprising that about 1 in 20 such matrices is singular."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-generalized-transpose-of-an-array",
    "href": "content/R/r-manuals/test.html#sec-generalized-transpose-of-an-array",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.6 Generalized transpose of an array",
    "text": "5.6 Generalized transpose of an array\nThe function aperm(a, perm) may be used to permute an array, a. The argument perm must be a permutation of the integers {1, …, k}, where k is the number of subscripts in a. The result of the function is an array of the same size as a but with old dimension given by perm[j] becoming the new j-th dimension. The easiest way to think of this operation is as a generalization of transposition for matrices. Indeed if A is a matrix, (that is, a doubly subscripted array) then B given by\n> B <- aperm(A, c(2,1))\nis just the transpose of A. For this special case a simpler function t() is available, so we could have used B <- t(A)."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-matrix-facilities",
    "href": "content/R/r-manuals/test.html#sec-matrix-facilities",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.7 Matrix facilities",
    "text": "5.7 Matrix facilities\nAs noted above, a matrix is just an array with two subscripts. However it is such an important special case it needs a separate discussion. R contains many operators and functions that are available only for matrices. For example t(X) is the matrix transpose function, as noted above. The functions nrow(A) and ncol(A) give the number of rows and columns in the matrix A respectively.\n\n5.7.1 Matrix multiplication\nThe operator %*% is used for matrix multiplication. An n by 1 or 1 by n matrix may of course be used as an n-vector if in the context such is appropriate. Conversely, vectors which occur in matrix multiplication expressions are automatically promoted either to row or column vectors, whichever is multiplicatively coherent, if possible, (although this is not always unambiguously possible, as we see later).\nIf, for example, A and B are square matrices of the same size, then\n> A * B\nis the matrix of element by element products and\n> A %*% B\nis the matrix product. If x is a vector, then\n> x %*% A %*% x\nis a quadratic form.16\nThe function crossprod() forms “crossproducts”, meaning that crossprod(X, y) is the same as t(X) %*% y but the operation is more efficient. If the second argument to crossprod() is omitted it is taken to be the same as the first.\nThe meaning of diag() depends on its argument. diag(v), where v is a vector, gives a diagonal matrix with elements of the vector as the diagonal entries. On the other hand diag(M), where M is a matrix, gives the vector of main diagonal entries of M. This is the same convention as that used for diag() in MATLAB. Also, somewhat confusingly, if k is a single numeric value then diag(k) is the k by k identity matrix!\n\n\n5.7.2 Linear equations and inversion\nSolving linear equations is the inverse of matrix multiplication. When after\n> b <- A %*% x\nonly A and b are given, the vector x is the solution of that linear equation system. In R,\n> solve(A,b)\nsolves the system, returning x (up to some accuracy loss). Note that in linear algebra, formally x = A^{-1} %*% b where A^{-1} denotes the inverse of A, which can be computed by\nsolve(A)\nbut rarely is needed. Numerically, it is both inefficient and potentially unstable to compute x <- solve(A) %*% b instead of solve(A,b).\nThe quadratic form  x %*% A^{-1} %*% x   which is used in multivariate computations, should be computed by something like17 x %*% solve(A,x), rather than computing the inverse of A.\n\n\n5.7.3 Eigenvalues and eigenvectors\nThe function eigen(Sm) calculates the eigenvalues and eigenvectors of a symmetric matrix Sm. The result of this function is a list of two components named values and vectors. The assignment\n> ev <- eigen(Sm)\nwill assign this list to ev. Then ev$val is the vector of eigenvalues of Sm and ev$vec is the matrix of corresponding eigenvectors. Had we only needed the eigenvalues we could have used the assignment:\n> evals <- eigen(Sm)$values\nevals now holds the vector of eigenvalues and the second component is discarded. If the expression\n> eigen(Sm)\nis used by itself as a command the two components are printed, with their names. For large matrices it is better to avoid computing the eigenvectors if they are not needed by using the expression\n> evals <- eigen(Sm, only.values = TRUE)$values\n\n\n5.7.4 Singular value decomposition and determinants\nThe function svd(M) takes an arbitrary matrix argument, M, and calculates the singular value decomposition of M. This consists of a matrix of orthonormal columns U with the same column space as M, a second matrix of orthonormal columns V whose column space is the row space of M and a diagonal matrix of positive entries D such that M = U %*% D %*% t(V). D is actually returned as a vector of the diagonal elements. The result of svd(M) is actually a list of three components named d, u and v, with evident meanings.\nIf M is in fact square, then, it is not hard to see that\n> absdetM <- prod(svd(M)$d)\ncalculates the absolute value of the determinant of M. If this calculation were needed often with a variety of matrices it could be defined as an R function\n> absdet <- function(M) prod(svd(M)$d)\nafter which we could use absdet() as just another R function. As a further trivial but potentially useful example, you might like to consider writing a function, say tr(), to calculate the trace of a square matrix. [Hint: You will not need to use an explicit loop. Look again at the diag() function.]\nR has a builtin function det to calculate a determinant, including the sign, and another, determinant, to give the sign and modulus (optionally on log scale),\n\n\n5.7.5 Least squares fitting and the QR decomposition\nThe function lsfit() returns a list giving results of a least squares fitting procedure. An assignment such as\n> ans <- lsfit(X, y)\ngives the results of a least squares fit where y is the vector of observations and X is the design matrix. See the help facility for more details, and also for the follow-up function ls.diag() for, among other things, regression diagnostics. Note that a grand mean term is automatically included and need not be included explicitly as a column of X. Further note that you almost always will prefer using lm(.) (see Linear models) to lsfit() for regression modelling.\nAnother closely related function is qr() and its allies. Consider the following assignments\n> Xplus <- qr(X)\n> b <- qr.coef(Xplus, y)\n> fit <- qr.fitted(Xplus, y)\n> res <- qr.resid(Xplus, y)\nThese compute the orthogonal projection of y onto the range of X in fit, the projection onto the orthogonal complement in res and the coefficient vector for the projection in b, that is, b is essentially the result of the MATLAB ‘backslash’ operator.\nIt is not assumed that X has full column rank. Redundancies will be discovered and removed as they are found.\nThis alternative is the older, low-level way to perform least squares calculations. Although still useful in some contexts, it would now generally be replaced by the statistical models features, as will be discussed in Statistical models in R."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-forming-partitioned-matrices-cbind-and-rbind",
    "href": "content/R/r-manuals/test.html#sec-forming-partitioned-matrices-cbind-and-rbind",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.8 Forming partitioned matrices, cbind() and rbind()",
    "text": "5.8 Forming partitioned matrices, cbind() and rbind()\nAs we have already seen informally, matrices can be built up from other vectors and matrices by the functions cbind() and rbind(). Roughly cbind() forms matrices by binding together matrices horizontally, or column-wise, and rbind() vertically, or row-wise.\nIn the assignment\n> X <- cbind(arg_1, arg_2, arg_3, …)\nthe arguments to cbind() must be either vectors of any length, or matrices with the same column size, that is the same number of rows. The result is a matrix with the concatenated arguments arg_1, arg_2, … forming the columns.\nIf some of the arguments to cbind() are vectors they may be shorter than the column size of any matrices present, in which case they are cyclically extended to match the matrix column size (or the length of the longest vector if no matrices are given).\nThe function rbind() does the corresponding operation for rows. In this case any vector argument, possibly cyclically extended, are of course taken as row vectors.\nSuppose X1 and X2 have the same number of rows. To combine these by columns into a matrix X, together with an initial column of 1s we can use\n> X <- cbind(1, X1, X2)\nThe result of rbind() or cbind() always has matrix status. Hence cbind(x) and rbind(x) are possibly the simplest ways explicitly to allow the vector x to be treated as a column or row matrix respectively."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-concatenation-function-c-with-arrays",
    "href": "content/R/r-manuals/test.html#sec-the-concatenation-function-c-with-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.9 The concatenation function, c(), with arrays",
    "text": "5.9 The concatenation function, c(), with arrays\nIt should be noted that whereas cbind() and rbind() are concatenation functions that respect dim attributes, the basic c() function does not, but rather clears numeric objects of all dim and dimnames attributes. This is occasionally useful in its own right.\nThe official way to coerce an array back to a simple vector object is to use as.vector()\n> vec <- as.vector(X)\nHowever a similar result can be achieved by using c() with just one argument, simply for this side-effect:\n> vec <- c(X)\nThere are slight differences between the two, but ultimately the choice between them is largely a matter of style (with the former being preferable)."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-frequency-tables-from-factors",
    "href": "content/R/r-manuals/test.html#sec-frequency-tables-from-factors",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.10 Frequency tables from factors",
    "text": "5.10 Frequency tables from factors\nRecall that a factor defines a partition into groups. Similarly a pair of factors defines a two way cross classification, and so on. The function table() allows frequency tables to be calculated from equal length factors. If there are k factor arguments, the result is a k-way array of frequencies.\nSuppose, for example, that statef is a factor giving the state code for each entry in a data vector. The assignment\n> statefr <- table(statef)\ngives in statefr a table of frequencies of each state in the sample. The frequencies are ordered and labelled by the levels attribute of the factor. This simple case is equivalent to, but more convenient than,\n> statefr <- tapply(statef, statef, length)\nFurther suppose that incomef is a factor giving a suitably defined “income class” for each entry in the data vector, for example with the cut() function:\n> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef\nThen to calculate a two-way table of frequencies:\n> table(incomef,statef)\n         statef\nincomef   act nsw nt qld sa tas vic wa\n  (35,45]   1   1  0   1  0   0   1  0\n  (45,55]   1   1  1   1  2   0   1  3\n  (55,65]   0   3  1   3  2   2   2  1\n  (65,75]   0   1  0   0  0   0   1  0\nExtension to higher-way frequency tables is immediate."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-lists",
    "href": "content/R/r-manuals/test.html#sec-lists",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.1 Lists",
    "text": "6.1 Lists\nAn R list is an object consisting of an ordered collection of objects known as its components.\nThere is no particular need for the components to be of the same mode or type, and, for example, a list could consist of a numeric vector, a logical value, a matrix, a complex vector, a character array, a function, and so on. Here is a simple example of how to make a list:\n> Lst <- list(name=\"Fred\", wife=\"Mary\", no.children=3,\n              child.ages=c(4,7,9))\nComponents are always numbered and may always be referred to as such. Thus if Lst is the name of a list with four components, these may be individually referred to as Lst[[1]], Lst[[2]], Lst[[3]] and Lst[[4]]. If, further, Lst[[4]] is a vector subscripted array then Lst[[4]][1] is its first entry.\nIf Lst is a list, then the function length(Lst) gives the number of (top level) components it has.\nComponents of lists may also be named, and in this case the component may be referred to either by giving the component name as a character string in place of the number in double square brackets, or, more conveniently, by giving an expression of the form\n> name$component_name\nfor the same thing.\nThis is a very useful convention as it makes it easier to get the right component if you forget the number.\nSo in the simple example given above:\nLst$name is the same as Lst[[1]] and is the string \"Fred\",\nLst$wife is the same as Lst[[2]] and is the string \"Mary\",\nLst$child.ages[1] is the same as Lst[[4]][1] and is the number 4.\nAdditionally, one can also use the names of the list components in double square brackets, i.e., Lst[[\"name\"]] is the same as Lst$name. This is especially useful, when the name of the component to be extracted is stored in another variable as in\n> x <- \"name\"; Lst[[x]]\nIt is very important to distinguish Lst[[1]] from Lst[1]. [[``…]] is the operator used to select a single element, whereas [``…] is a general subscripting operator. Thus the former is the first object in the list Lst, and if it is a named list the name is not included. The latter is a sublist of the list Lst consisting of the first entry only. If it is a named list, the names are transferred to the sublist.\nThe names of components may be abbreviated down to the minimum number of letters needed to identify them uniquely. Thus Lst$coefficients may be minimally specified as Lst$coe and Lst$covariance as Lst$cov.\nThe vector of names is in fact simply an attribute of the list like any other and may be handled as such. Other structures besides lists may, of course, similarly be given a names attribute also."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-constructing-and-modifying-lists",
    "href": "content/R/r-manuals/test.html#sec-constructing-and-modifying-lists",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.2 Constructing and modifying lists",
    "text": "6.2 Constructing and modifying lists\nNew lists may be formed from existing objects by the function list(). An assignment of the form\n> Lst <- list(name_1=object_1, …, name_m=object_m)\nsets up a list Lst of m components using object_1, …, object_m for the components and giving them names as specified by the argument names, (which can be freely chosen). If these names are omitted, the components are numbered only. The components used to form the list are copied when forming the new list and the originals are not affected.\nLists, like any subscripted object, can be extended by specifying additional components. For example\n> Lst[5] <- list(matrix=Mat)\n\n6.2.1 Concatenating lists\nWhen the concatenation function c() is given list arguments, the result is an object of mode list also, whose components are those of the argument lists joined together in sequence.\n> list.ABC <- c(list.A, list.B, list.C)\nRecall that with vector objects as arguments the concatenation function similarly joined together all arguments into a single vector structure. In this case all other attributes, such as dim attributes, are discarded."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-data-frames",
    "href": "content/R/r-manuals/test.html#sec-data-frames",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.3 Data frames",
    "text": "6.3 Data frames\nA data frame is a list with class \"data.frame\". There are restrictions on lists that may be made into data frames, namely\n\nThe components must be vectors (numeric, character, or logical), factors, numeric matrices, lists, or other data frames.\nMatrices, lists, and data frames provide as many variables to the new data frame as they have columns, elements, or variables, respectively.\nVector structures appearing as variables of the data frame must all have the same length, and matrix structures must all have the same number of rows.\n\nA data frame may for many purposes be regarded as a matrix with columns possibly of differing modes and attributes. It may be displayed in matrix form, and its rows and columns extracted using matrix indexing conventions.\n\n6.3.1 Making data frames\nObjects satisfying the restrictions placed on the columns (components) of a data frame may be used to form one using the function data.frame:\n> accountants <- data.frame(home=statef, loot=incomes, shot=incomef)\nA list whose components conform to the restrictions of a data frame may be coerced into a data frame using the function as.data.frame()\nThe simplest way to construct a data frame from scratch is to use the read.table() function to read an entire data frame from an external file. This is discussed further in Reading data from files.\n\n\n6.3.2 attach() and detach()\nThe $ notation, such as accountants$home, for list components is not always very convenient. A useful facility would be somehow to make the components of a list or data frame temporarily visible as variables under their component name, without the need to quote the list name explicitly each time.\nThe attach() function takes a ‘database’ such as a list or data frame as its argument. Thus suppose lentils is a data frame with three variables lentils$u, lentils$v, lentils$w. The attach\n> attach(lentils)\nplaces the data frame in the search path at position 2, and provided there are no variables u, v or w in position 1, u, v and w are available as variables from the data frame in their own right. At this point an assignment such as\n> u <- v+w\ndoes not replace the component u of the data frame, but rather masks it with another variable u in the working directory at position 1 on the search path. To make a permanent change to the data frame itself, the simplest way is to resort once again to the $ notation:\n> lentils$u <- v+w\nHowever the new value of component u is not visible until the data frame is detached and attached again.\nTo detach a data frame, use the function\n> detach()\nMore precisely, this statement detaches from the search path the entity currently at position 2. Thus in the present context the variables u, v and w would be no longer visible, except under the list notation as lentils$u and so on. Entities at positions greater than 2 on the search path can be detached by giving their number to detach, but it is much safer to always use a name, for example by detach(lentils) or detach(\"lentils\")\n\nNote: In R lists and data frames can only be attached at position 2 or above, and what is attached is a copy of the original object. You can alter the attached values via assign, but the original list or data frame is unchanged.\n\n\n\n6.3.3 Working with data frames\nA useful convention that allows you to work with many different problems comfortably together in the same working directory is\n\ngather together all variables for any well defined and separate problem in a data frame under a suitably informative name;\nwhen working with a problem attach the appropriate data frame at position 2, and use the working directory at level 1 for operational quantities and temporary variables;\nbefore leaving a problem, add any variables you wish to keep for future reference to the data frame using the $ form of assignment, and then detach();\nfinally remove all unwanted variables from the working directory and keep it as clean of left-over temporary variables as possible.\n\nIn this way it is quite simple to work with many problems in the same directory, all of which have variables named x, y and z, for example.\n\n\n6.3.4 Attaching arbitrary lists\nattach() is a generic function that allows not only directories and data frames to be attached to the search path, but other classes of object as well. In particular any object of mode \"list\" may be attached in the same way:\n> attach(any.old.list)\nAnything that has been attached can be detached by detach, by position number or, preferably, by name.\n\n\n6.3.5 Managing the search path\nThe function search shows the current search path and so is a very useful way to keep track of which data frames and lists (and packages) have been attached and detached. Initially it gives\n> search()\n[1] \".GlobalEnv\"   \"Autoloads\"    \"package:base\"\nwhere .GlobalEnv is the workspace.18\nAfter lentils is attached we have\n> search()\n[1] \".GlobalEnv\"   \"lentils\"      \"Autoloads\"    \"package:base\"\n> ls(2)\n[1] \"u\" \"v\" \"w\"\nand as we see ls (or objects) can be used to examine the contents of any position on the search path.\nFinally, we detach the data frame and confirm it has been removed from the search path.\n> detach(\"lentils\")\n> search()\n[1] \".GlobalEnv\"   \"Autoloads\"    \"package:base\""
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-read.table-function",
    "href": "content/R/r-manuals/test.html#sec-the-read.table-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.1 The read.table() function",
    "text": "7.1 The read.table() function\nTo read an entire data frame directly, the external file will normally have a special form.\n\nThe first line of the file should have a name for each variable in the data frame.\nEach additional line of the file has as its first item a row label and the values for each variable.\n\nIf the file has one fewer item in its first line than in its second, this arrangement is presumed to be in force. So the first few lines of a file to be read as a data frame might look as follows.\n\n\n\n\n\n\n\n\nInput file form with names and row labels:\n\n     Price    Floor     Area   Rooms     Age  Cent.heat\n01   52.00    111.0      830     5       6.2      no\n02   54.75    128.0      710     5       7.5      no\n03   57.50    101.0     1000     5       4.2      no\n04   57.50    131.0      690     6       8.8      no\n05   59.75     93.0      900     5       1.9     yes\n...\n\n\n\n\n\nBy default numeric items (except row labels) are read as numeric variables and non-numeric variables, such as Cent.heat in the example, as character variables. This can be changed if necessary.\nThe function read.table() can then be used to read the data frame directly\n> HousePrice <- read.table(\"houses.data\")\nOften you will want to omit including the row labels directly and use the default labels. In this case the file may omit the row label column as in the following.\n\n\n\n\n\n\n\n\nInput file form without row labels:\n\nPrice    Floor     Area   Rooms     Age  Cent.heat\n52.00    111.0      830     5       6.2      no\n54.75    128.0      710     5       7.5      no\n57.50    101.0     1000     5       4.2      no\n57.50    131.0      690     6       8.8      no\n59.75     93.0      900     5       1.9     yes\n...\n\n\n\n\n\nThe data frame may then be read as\n> HousePrice <- read.table(\"houses.data\", header=TRUE)\nwhere the header=TRUE option specifies that the first line is a line of headings, and hence, by implication from the form of the file, that no explicit row labels are given."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-the-scan-function",
    "href": "content/R/r-manuals/test.html#sec-the-scan-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.2 The scan() function",
    "text": "7.2 The scan() function\nSuppose the data vectors are of equal length and are to be read in parallel. Further suppose that there are three vectors, the first of mode character and the remaining two of mode numeric, and the file is input.dat. The first step is to use scan() to read in the three vectors as a list, as follows\n> inp <- scan(\"input.dat\", list(\"\",0,0))\nThe second argument is a dummy list structure that establishes the mode of the three vectors to be read. The result, held in inp, is a list whose components are the three vectors read in. To separate the data items into three separate vectors, use assignments like\n> label <- inp[[1]]; x <- inp[[2]]; y <- inp[[3]]\nMore conveniently, the dummy list can have named components, in which case the names can be used to access the vectors read in. For example\n> inp <- scan(\"input.dat\", list(id=\"\", x=0, y=0))\nIf you wish to access the variables separately they may either be re-assigned to variables in the working frame:\n> label <- inp$id; x <- inp$x; y <- inp$y\nor the list may be attached at position 2 of the search path (see Attaching arbitrary lists).\nIf the second argument is a single value and not a list, a single vector is read in, all components of which must be of the same mode as the dummy value.\n> X <- matrix(scan(\"light.dat\", 0), ncol=5, byrow=TRUE)\nThere are more elaborate input facilities available and these are detailed in the manuals."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-accessing-builtin-datasets",
    "href": "content/R/r-manuals/test.html#sec-accessing-builtin-datasets",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.3 Accessing builtin datasets",
    "text": "7.3 Accessing builtin datasets\nAround 100 datasets are supplied with R (in package datasets), and others are available in packages (including the recommended packages supplied with R). To see the list of datasets currently available use\ndata()\nAll the datasets supplied with R are available directly by name. However, many packages still use the obsolete convention in which data was also used to load datasets into R, for example\ndata(infert)\nand this can still be used with the standard packages (as in this example). In most cases this will load an R object of the same name. However, in a few cases it loads several objects, so see the on-line help for the object to see what to expect.\n\n7.3.1 7.3.1 Loading data from other R packages\nTo access data from a particular package, use the package argument, for example\ndata(package=\"rpart\")\ndata(Puromycin, package=\"datasets\")\nIf a package has been attached by library, its datasets are automatically included in the search.\nUser-contributed packages can be a rich source of datasets."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-editing-data",
    "href": "content/R/r-manuals/test.html#sec-editing-data",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.4 Editing data",
    "text": "7.4 Editing data\nWhen invoked on a data frame or matrix, edit brings up a separate spreadsheet-like environment for editing. This is useful for making small changes once a data set has been read. The command\n> xnew <- edit(xold)\nwill allow you to edit your data set xold, and on completion the changed object is assigned to xnew. If you want to alter the original dataset xold, the simplest way is to use fix(xold), which is equivalent to xold <- edit(xold).\nUse\n> xnew <- edit(data.frame())\nto enter new data via the spreadsheet interface."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-r-as-a-set-of-statistical-tables",
    "href": "content/R/r-manuals/test.html#sec-r-as-a-set-of-statistical-tables",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.1 R as a set of statistical tables",
    "text": "8.1 R as a set of statistical tables\nOne convenient use of R is to provide a comprehensive set of statistical tables. Functions are provided to evaluate the cumulative distribution function P(X <= x), the probability density function and the quantile function (given q, the smallest x such that P(X <= x) > q), and to simulate from the distribution.\n\n\n\n\n\nDistribution\nR name\nadditional arguments\n\n\n\n\nbeta\nbeta\nshape1, shape2, ncp\n\n\nbinomial\nbinom\nsize, prob\n\n\nCauchy\ncauchy\nlocation, scale\n\n\nchi-squared\nchisq\ndf, ncp\n\n\nexponential\nexp\nrate\n\n\nF\nf\ndf1, df2, ncp\n\n\ngamma\ngamma\nshape, scale\n\n\ngeometric\ngeom\nprob\n\n\nhypergeometric\nhyper\nm, n, k\n\n\nlog-normal\nlnorm\nmeanlog, sdlog\n\n\nlogistic\nlogis\nlocation, scale\n\n\nnegative binomial\nnbinom\nsize, prob\n\n\nnormal\nnorm\nmean, sd\n\n\nPoisson\npois\nlambda\n\n\nsigned rank\nsignrank\nn\n\n\nStudent’s t\nt\ndf, ncp\n\n\nuniform\nunif\nmin, max\n\n\nWeibull\nweibull\nshape, scale\n\n\nWilcoxon\nwilcox\nm, n\n\n\n\n\n\nPrefix the name given here by ‘d’ for the density, ‘p’ for the CDF, ‘q’ for the quantile function and ‘r’ for simulation (random deviates). The first argument is x for d``xxx, q for p``xxx, p for q``xxx and n for r``xxx (except for rhyper, rsignrank and rwilcox, for which it is nn). In not quite all cases is the non-centrality parameter ncp currently available: see the on-line help for details.\nThe p``xxx and q``xxx functions all have logical arguments lower.tail and log.p and the d``xxx ones have log. This allows, e.g., getting the cumulative (or “integrated”) hazard function, H(t) = - log(1 - F(t)), by\n - pxxx(t, ..., lower.tail = FALSE, log.p = TRUE)\nor more accurate log-likelihoods (by d``xxx(..., log = TRUE)), directly.\nIn addition there are functions ptukey and qtukey for the distribution of the studentized range of samples from a normal distribution, and dmultinom and rmultinom for the multinomial distribution. Further distributions are available in contributed packages, notably SuppDists.\nHere are some examples\n> ## 2-tailed p-value for t distribution\n> 2*pt(-2.43, df = 13)\n> ## upper 1% point for an F(2, 7) distribution\n> qf(0.01, 2, 7, lower.tail = FALSE)\nSee the on-line help on RNG for how random-number generation is done in R."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-examining-the-distribution-of-a-set-of-data",
    "href": "content/R/r-manuals/test.html#sec-examining-the-distribution-of-a-set-of-data",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.2 Examining the distribution of a set of data",
    "text": "8.2 Examining the distribution of a set of data\nGiven a (univariate) set of data we can examine its distribution in a large number of ways. The simplest is to examine the numbers. Two slightly different summaries are given by summary and fivenum and a display of the numbers by stem (a “stem and leaf” plot).\n> attach(faithful)\n> summary(eruptions)\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n  1.600   2.163   4.000   3.488   4.454   5.100\n> fivenum(eruptions)\n[1] 1.6000 2.1585 4.0000 4.4585 5.1000\n> stem(eruptions)\n\n  The decimal point is 1 digit(s) to the left of the |\n\n  16 | 070355555588\n  18 | 000022233333335577777777888822335777888\n  20 | 00002223378800035778\n  22 | 0002335578023578\n  24 | 00228\n  26 | 23\n  28 | 080\n  30 | 7\n  32 | 2337\n  34 | 250077\n  36 | 0000823577\n  38 | 2333335582225577\n  40 | 0000003357788888002233555577778\n  42 | 03335555778800233333555577778\n  44 | 02222335557780000000023333357778888\n  46 | 0000233357700000023578\n  48 | 00000022335800333\n  50 | 0370\nA stem-and-leaf plot is like a histogram, and R has a function hist to plot histograms.\n> hist(eruptions)\n## make the bins smaller, make a plot of density\n> hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)\n> lines(density(eruptions, bw=0.1))\n> rug(eruptions) # show the actual data points\nMore elegant density plots can be made by density, and we added a line produced by density in this example. The bandwidth bw was chosen by trial-and-error as the default gives too much smoothing (it usually does for “interesting” densities). (Better automated methods of bandwidth choice are available, and in this example bw = \"SJ\" gives a good result.)\n\n\n\nimages/hist\n\n\nWe can plot the empirical cumulative distribution function by using the function ecdf.\n> plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)\nThis distribution is obviously far from any standard distribution. How about the right-hand mode, say eruptions of longer than 3 minutes? Let us fit a normal distribution and overlay the fitted CDF.\n> long <- eruptions[eruptions > 3]\n> plot(ecdf(long), do.points=FALSE, verticals=TRUE)\n> x <- seq(3, 5.4, 0.01)\n> lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)\n\n\n\nimages/ecdf\n\n\nQuantile-quantile (Q-Q) plots can help us examine this more carefully.\npar(pty=\"s\")       # arrange for a square figure region\nqqnorm(long); qqline(long)\nwhich shows a reasonable fit but a shorter right tail than one would expect from a normal distribution. Let us compare this with some simulated data from a t distribution\n\n\n\nimages/QQ\n\n\nx <- rt(250, df = 5)\nqqnorm(x); qqline(x)\nwhich will usually (if it is a random sample) show longer tails than expected for a normal. We can make a Q-Q plot against the generating distribution by\nqqplot(qt(ppoints(250), df = 5), x, xlab = \"Q-Q plot for t dsn\")\nqqline(x)\nFinally, we might want a more formal test of agreement with normality (or not). R provides the Shapiro-Wilk test\n> shapiro.test(long)\n\n         Shapiro-Wilk normality test\n\ndata:  long\nW = 0.9793, p-value = 0.01052\nand the Kolmogorov-Smirnov test\n> ks.test(long, \"pnorm\", mean = mean(long), sd = sqrt(var(long)))\n\n         One-sample Kolmogorov-Smirnov test\n\ndata:  long\nD = 0.0661, p-value = 0.4284\nalternative hypothesis: two.sided\n(Note that the distribution theory is not valid here as we have estimated the parameters of the normal distribution from the same sample.)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-one--and-two-sample-tests",
    "href": "content/R/r-manuals/test.html#sec-one--and-two-sample-tests",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.3 One- and two-sample tests",
    "text": "8.3 One- and two-sample tests\nSo far we have compared a single sample to a normal distribution. A much more common operation is to compare aspects of two samples. Note that in R, all “classical” tests including the ones used below are in package stats which is normally loaded.\nConsider the following sets of data on the latent heat of the fusion of ice (cal/gm) from Rice (1995, p.490)\nMethod A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97\n          80.05 80.03 80.02 80.00 80.02\nMethod B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97\nBoxplots provide a simple graphical comparison of the two samples.\nA <- scan()\n79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97\n80.05 80.03 80.02 80.00 80.02\n\nB <- scan()\n80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97\n\nboxplot(A, B)\nwhich indicates that the first group tends to give higher results than the second.\n\n\n\nimages/ice\n\n\nTo test for the equality of the means of the two examples, we can use an unpaired t-test by\n> t.test(A, B)\n\n         Welch Two Sample t-test\n\ndata:  A and B\nt = 3.2499, df = 12.027, p-value = 0.00694\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.01385526 0.07018320\nsample estimates:\nmean of x mean of y\n 80.02077  79.97875\nwhich does indicate a significant difference, assuming normality. By default the R function does not assume equality of variances in the two samples. We can use the F test to test for equality in the variances, provided that the two samples are from normal populations.\n> var.test(A, B)\n\n         F test to compare two variances\n\ndata:  A and B\nF = 0.5837, num df = 12, denom df =  7, p-value = 0.3938\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1251097 2.1052687\nsample estimates:\nratio of variances\n         0.5837405\nwhich shows no evidence of a significant difference, and so we can use the classical t-test that assumes equality of the variances.\n> t.test(A, B, var.equal=TRUE)\n\n         Two Sample t-test\n\ndata:  A and B\nt = 3.4722, df = 19, p-value = 0.002551\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.01669058 0.06734788\nsample estimates:\nmean of x mean of y\n 80.02077  79.97875\nAll these tests assume normality of the two samples. The two-sample Wilcoxon (or Mann-Whitney) test only assumes a common continuous distribution under the null hypothesis.\n> wilcox.test(A, B)\n\n         Wilcoxon rank sum test with continuity correction\n\ndata:  A and B\nW = 89, p-value = 0.007497\nalternative hypothesis: true location shift is not equal to 0\n\nWarning message:\nCannot compute exact p-value with ties in: wilcox.test(A, B)\nNote the warning: there are several ties in each sample, which suggests strongly that these data are from a discrete distribution (probably due to rounding).\nThere are several ways to compare graphically the two samples. We have already seen a pair of boxplots. The following\n> plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))\n> plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)\nwill show the two empirical CDFs, and qqplot will perform a Q-Q plot of the two samples. The Kolmogorov-Smirnov test is of the maximal vertical distance between the two ecdf’s, assuming a common continuous distribution:\n> ks.test(A, B)\n\n         Two-sample Kolmogorov-Smirnov test\n\ndata:  A and B\nD = 0.5962, p-value = 0.05919\nalternative hypothesis: two-sided\n\nWarning message:\ncannot compute correct p-values with ties in: ks.test(A, B)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-grouped-expressions",
    "href": "content/R/r-manuals/test.html#sec-grouped-expressions",
    "title": "R Manuals :: An Introduction to R",
    "section": "9.1 Grouped expressions",
    "text": "9.1 Grouped expressions\nR is an expression language in the sense that its only command type is a function or expression which returns a result. Even an assignment is an expression whose result is the value assigned, and it may be used wherever any expression may be used; in particular multiple assignments are possible.\nCommands may be grouped together in braces, {``expr_1; ``…; ``expr_m}, in which case the value of the group is the result of the last expression in the group evaluated. Since such a group is also an expression it may, for example, be itself included in parentheses and used as part of an even larger expression, and so on."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-control-statements",
    "href": "content/R/r-manuals/test.html#sec-control-statements",
    "title": "R Manuals :: An Introduction to R",
    "section": "9.2 Control statements",
    "text": "9.2 Control statements\n\n9.2.1 Conditional execution: if statements\nThe language has available a conditional construction of the form\n> if (expr_1) expr_2 else expr_3\nwhere expr_1 must evaluate to a single logical value and the result of the entire expression is then evident.\nThe “short-circuit” operators && and || are often used as part of the condition in an if statement. Whereas & and | apply element-wise to vectors, && and || apply to vectors of length one, and only evaluate their second argument if necessary.\nThere is a vectorized version of the if/else construct, the ifelse function. This has the form ifelse(condition, a, b) and returns a vector of the same length as condition, with elements a[i] if condition[i] is true, otherwise b[i] (where a and b are recycled as necessary).\n\n\n9.2.2 Repetitive execution: for loops, repeat and while\nThere is also a for loop construction which has the form\n> for (name in expr_1) expr_2\nwhere name is the loop variable. expr_1 is a vector expression, (often a sequence like 1:20), and expr_2 is often a grouped expression with its sub-expressions written in terms of the dummy name. expr_2 is repeatedly evaluated as name ranges through the values in the vector result of expr_1.\nAs an example, suppose ind is a vector of class indicators and we wish to produce separate plots of y versus x within classes. One possibility here is to use coplot(),20 which will produce an array of plots corresponding to each level of the factor. Another way to do this, now putting all plots on the one display, is as follows:\n> xc <- split(x, ind)\n> yc <- split(y, ind)\n> for (i in 1:length(yc)) {\n    plot(xc[[i]], yc[[i]])\n    abline(lsfit(xc[[i]], yc[[i]]))\n  }\n(Note the function split() which produces a list of vectors obtained by splitting a larger vector according to the classes specified by a factor. This is a useful function, mostly used in connection with boxplots. See the help facility for further details.)\n\nWarning: for() loops are used in R code much less often than in compiled languages. Code that takes a ‘whole object’ view is likely to be both clearer and faster in R.\n\nOther looping facilities include the\n> repeat expr\nstatement and the\n> while (condition) expr\nstatement.\nThe break statement can be used to terminate any loop, possibly abnormally. This is the only way to terminate repeat loops.\nThe next statement can be used to discontinue one particular cycle and skip to the “next”.\nControl statements are most often used in connection with functions which are discussed in Section 10 , and where more examples will emerge."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-simple-examples",
    "href": "content/R/r-manuals/test.html#sec-simple-examples",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.1 Simple examples",
    "text": "10.1 Simple examples\nAs a first example, consider a function to calculate the two sample t-statistic, showing “all the steps”. This is an artificial example, of course, since there are other, simpler ways of achieving the same end.\nThe function is defined as follows:\n> twosam <- function(y1, y2) {\n    n1  <- length(y1); n2  <- length(y2)\n    yb1 <- mean(y1);   yb2 <- mean(y2)\n    s1  <- var(y1);    s2  <- var(y2)\n    s <- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)\n    tst <- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))\n    tst\n  }\nWith this function defined, you could perform two sample t-tests using a call such as\n> tstat <- twosam(data$male, data$female); tstat\nAs a second example, consider a function to emulate directly the MATLAB backslash command, which returns the coefficients of the orthogonal projection of the vector y onto the column space of the matrix, X. (This is ordinarily called the least squares estimate of the regression coefficients.) This would ordinarily be done with the qr() function; however this is sometimes a bit tricky to use directly and it pays to have a simple function such as the following to use it safely.\nThus given a n by 1 vector y and an n by p matrix X then X \\ y is defined as (X’X)^{-}X’y, where (X’X)^{-} is a generalized inverse of X'X.\n> bslash <- function(X, y) {\n  X <- qr(X)\n  qr.coef(X, y)\n}\nAfter this object is created it may be used in statements such as\n> regcoeff <- bslash(Xmat, yvar)\nand so on.\nThe classical R function lsfit() does this job quite well, and more21. It in turn uses the functions qr() and qr.coef() in the slightly counterintuitive way above to do this part of the calculation. Hence there is probably some value in having just this part isolated in a simple to use function if it is going to be in frequent use. If so, we may wish to make it a matrix binary operator for even more convenient use."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-defining-new-binary-operators",
    "href": "content/R/r-manuals/test.html#sec-defining-new-binary-operators",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.2 Defining new binary operators",
    "text": "10.2 Defining new binary operators\nHad we given the bslash() function a different name, namely one of the form\n%anything%\nit could have been used as a binary operator in expressions rather than in function form. Suppose, for example, we choose ! for the internal character. The function definition would then start as\n> \"%!%\" <- function(X, y) { … }\n(Note the use of quote marks.) The function could then be used as X %!% y. (The backslash symbol itself is not a convenient choice as it presents special problems in this context.)\nThe matrix multiplication operator, %*%, and the outer product matrix operator %o% are other examples of binary operators defined in this way."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-named-arguments-and-defaults",
    "href": "content/R/r-manuals/test.html#sec-named-arguments-and-defaults",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.3 Named arguments and defaults",
    "text": "10.3 Named arguments and defaults\nAs first noted in Generating regular sequences, if arguments to called functions are given in the “name=``object” form, they may be given in any order. Furthermore the argument sequence may begin in the unnamed, positional form, and specify named arguments after the positional arguments.\nThus if there is a function fun1 defined by\n> fun1 <- function(data, data.frame, graph, limit) {\n    [function body omitted]\n  }\nthen the function may be invoked in several ways, for example\n> ans <- fun1(d, df, TRUE, 20)\n> ans <- fun1(d, df, graph=TRUE, limit=20)\n> ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)\nare all equivalent.\nIn many cases arguments can be given commonly appropriate default values, in which case they may be omitted altogether from the call when the defaults are appropriate. For example, if fun1 were defined as\n> fun1 <- function(data, data.frame, graph=TRUE, limit=20) { … }\nit could be called as\n> ans <- fun1(d, df)\nwhich is now equivalent to the three cases above, or as\n> ans <- fun1(d, df, limit=10)\nwhich changes one of the defaults.\nIt is important to note that defaults may be arbitrary expressions, even involving other arguments to the same function; they are not restricted to be constants as in our simple example here."
  },
  {
    "objectID": "content/R/r-manuals/test.html#the-sec-the--argument",
    "href": "content/R/r-manuals/test.html#the-sec-the--argument",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.4 The ‘…{#sec-the-’…’-argument}",
    "text": "10.4 The ‘…{#sec-the-’…’-argument}\nAnother frequent requirement is to allow one function to pass on argument settings to another. For example many graphics functions use the function par() and functions like plot() allow the user to pass on graphical parameters to par() to control the graphical output. (See The par() function, for more details on the par() function.) This can be done by including an extra argument, literally ‘…’, of the function, which may then be passed on. An outline example is given below.\nfun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {\n  [omitted statements]\n  if (graph)\n    par(pch=\"*\", ...)\n  [more omissions]\n}\nLess frequently, a function will need to refer to components of ‘…’. The expression list(...) evaluates all such arguments and returns them in a named list, while ..1, ..2, etc. evaluate them one at a time, with ‘..n’ returning the n’th unmatched argument."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-assignments-within-functions",
    "href": "content/R/r-manuals/test.html#sec-assignments-within-functions",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.5 Assignments within functions",
    "text": "10.5 Assignments within functions\nNote that any ordinary assignments done within the function are local and temporary and are lost after exit from the function. Thus the assignment X <- qr(X) does not affect the value of the argument in the calling program.\nTo understand completely the rules governing the scope of R assignments the reader needs to be familiar with the notion of an evaluation frame. This is a somewhat advanced, though hardly difficult, topic and is not covered further here.\nIf global and permanent assignments are intended within a function, then either the “superassignment” operator, <<- or the function assign() can be used. See the help document for details."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-more-advanced-examples",
    "href": "content/R/r-manuals/test.html#sec-more-advanced-examples",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.6 More advanced examples",
    "text": "10.6 More advanced examples\n\n10.6.1 Efficiency factors in block designs\nAs a more complete, if a little pedestrian, example of a function, consider finding the efficiency factors for a block design. (Some aspects of this problem have already been discussed in Index matrices.)\nA block design is defined by two factors, say blocks (b levels) and varieties (v levels). If R and K are the v by v and b by b replications and block size matrices, respectively, and N is the b by v incidence matrix, then the efficiency factors are defined as the eigenvalues of the matrix E = I_v - R^{-1/2}N’K^{-1}NR^{-1/2} = I_v - A’A, where A = K^{-1/2}NR^{-1/2}. One way to write the function is given below.\n> bdeff <- function(blocks, varieties) {\n    blocks <- as.factor(blocks)             # minor safety move\n    b <- length(levels(blocks))\n    varieties <- as.factor(varieties)       # minor safety move\n    v <- length(levels(varieties))\n    K <- as.vector(table(blocks))           # remove dim attr\n    R <- as.vector(table(varieties))        # remove dim attr\n    N <- table(blocks, varieties)\n    A <- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))\n    sv <- svd(A)\n    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)\n}\nIt is numerically slightly better to work with the singular value decomposition on this occasion rather than the eigenvalue routines.\nThe result of the function is a list giving not only the efficiency factors as the first component, but also the block and variety canonical contrasts, since sometimes these give additional useful qualitative information.\n\n\n10.6.2 Dropping all names in a printed array\nFor printing purposes with large matrices or arrays, it is often useful to print them in close block form without the array names or numbers. Removing the dimnames attribute will not achieve this effect, but rather the array must be given a dimnames attribute consisting of empty strings. For example to print a matrix, X\n> temp <- X\n> dimnames(temp) <- list(rep(\"\", nrow(X)), rep(\"\", ncol(X)))\n> temp; rm(temp)\nThis can be much more conveniently done using a function, no.dimnames(), shown below, as a “wrap around” to achieve the same result. It also illustrates how some effective and useful user functions can be quite short.\nno.dimnames <- function(a) {\n  ## Remove all dimension names from an array for compact printing.\n  d <- list()\n  l <- 0\n  for(i in dim(a)) {\n    d[[l <- l + 1]] <- rep(\"\", i)\n  }\n  dimnames(a) <- d\n  a\n}\nWith this function defined, an array may be printed in close format using\n> no.dimnames(X)\nThis is particularly useful for large integer arrays, where patterns are the real interest rather than the values.\n\n\n10.6.3 Recursive numerical integration\nFunctions may be recursive, and may themselves define functions within themselves. Note, however, that such functions, or indeed variables, are not inherited by called functions in higher evaluation frames as they would be if they were on the search path.\nThe example below shows a naive way of performing one-dimensional numerical integration. The integrand is evaluated at the end points of the range and in the middle. If the one-panel trapezium rule answer is close enough to the two panel, then the latter is returned as the value. Otherwise the same process is recursively applied to each panel. The result is an adaptive integration process that concentrates function evaluations in regions where the integrand is farthest from linear. There is, however, a heavy overhead, and the function is only competitive with other algorithms when the integrand is both smooth and very difficult to evaluate.\nThe example is also given partly as a little puzzle in R programming.\narea <- function(f, a, b, eps = 1.0e-06, lim = 10) {\n  fun1 <- function(f, a, b, fa, fb, a0, eps, lim, fun) {\n    ## function ‘fun1’ is only visible inside ‘area’\n    d <- (a + b)/2\n    h <- (b - a)/4\n    fd <- f(d)\n    a1 <- h * (fa + fd)\n    a2 <- h * (fd + fb)\n    if(abs(a0 - a1 - a2) < eps || lim == 0)\n      return(a1 + a2)\n    else {\n      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +\n             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))\n    }\n  }\n  fa <- f(a)\n  fb <- f(b)\n  a0 <- ((fa + fb) * (b - a))/2\n  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)\n}"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-scope",
    "href": "content/R/r-manuals/test.html#sec-scope",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.7 Scope",
    "text": "10.7 Scope\nThe discussion in this section is somewhat more technical than in other parts of this document. However, it details one of the major differences between S-PLUS and R.\nThe symbols which occur in the body of a function can be divided into three classes; formal parameters, local variables and free variables. The formal parameters of a function are those occurring in the argument list of the function. Their values are determined by the process of binding the actual function arguments to the formal parameters. Local variables are those whose values are determined by the evaluation of expressions in the body of the functions. Variables which are not formal parameters or local variables are called free variables. Free variables become local variables if they are assigned to. Consider the following function definition.\nf <- function(x) {\n  y <- 2*x\n  print(x)\n  print(y)\n  print(z)\n}\nIn this function, x is a formal parameter, y is a local variable and z is a free variable.\nIn R the free variable bindings are resolved by first looking in the environment in which the function was created. This is called lexical scope. First we define a function called cube.\ncube <- function(n) {\n  sq <- function() n*n\n  n*sq()\n}\nThe variable n in the function sq is not an argument to that function. Therefore it is a free variable and the scoping rules must be used to ascertain the value that is to be associated with it. Under static scope (S-PLUS) the value is that associated with a global variable named n. Under lexical scope (R) it is the parameter to the function cube since that is the active binding for the variable n at the time the function sq was defined. The difference between evaluation in R and evaluation in S-PLUS is that S-PLUS looks for a global variable called n while R first looks for a variable called n in the environment created when cube was invoked.\n## first evaluation in S\nS> cube(2)\nError in sq(): Object \"n\" not found\nDumped\nS> n <- 3\nS> cube(2)\n[1] 18\n## then the same function evaluated in R\nR> cube(2)\n[1] 8\nLexical scope can also be used to give functions mutable state. In the following example we show how R can be used to mimic a bank account. A functioning bank account needs to have a balance or total, a function for making withdrawals, a function for making deposits and a function for stating the current balance. We achieve this by creating the three functions within account and then returning a list containing them. When account is invoked it takes a numerical argument total and returns a list containing the three functions. Because these functions are defined in an environment which contains total, they will have access to its value.\nThe special assignment operator, <<-, is used to change the value associated with total. This operator looks back in enclosing environments for an environment that contains the symbol total and when it finds such an environment it replaces the value, in that environment, with the value of right hand side. If the global or top-level environment is reached without finding the symbol total then that variable is created and assigned to there. For most users <<- creates a global variable and assigns the value of the right hand side to it22. Only when <<- has been used in a function that was returned as the value of another function will the special behavior described here occur.\nopen.account <- function(total) {\n  list(\n    deposit = function(amount) {\n      if(amount <= 0)\n        stop(\"Deposits must be positive!\\n\")\n      total <<- total + amount\n      cat(amount, \"deposited.  Your balance is\", total, \"\\n\\n\")\n    },\n    withdraw = function(amount) {\n      if(amount > total)\n        stop(\"You don't have that much money!\\n\")\n      total <<- total - amount\n      cat(amount, \"withdrawn.  Your balance is\", total, \"\\n\\n\")\n    },\n    balance = function() {\n      cat(\"Your balance is\", total, \"\\n\\n\")\n    }\n  )\n}\n\nross <- open.account(100)\nrobert <- open.account(200)\n\nross$withdraw(30)\nross$balance()\nrobert$balance()\n\nross$deposit(50)\nross$balance()\nross$withdraw(500)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-customizing-the-environment",
    "href": "content/R/r-manuals/test.html#sec-customizing-the-environment",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.8 Customizing the environment",
    "text": "10.8 Customizing the environment\nUsers can customize their environment in several different ways. There is a site initialization file and every directory can have its own special initialization file. Finally, the special functions .First and .Last can be used.\nThe location of the site initialization file is taken from the value of the R_PROFILE environment variable. If that variable is unset, the file Rprofile.site in the R home subdirectory etc is used. This file should contain the commands that you want to execute every time R is started under your system. A second, personal, profile file named .Rprofile23 can be placed in any directory. If R is invoked in that directory then that file will be sourced. This file gives individual users control over their workspace and allows for different startup procedures in different working directories. If no .Rprofile file is found in the startup directory, then R looks for a .Rprofile file in the user’s home directory and uses that (if it exists). If the environment variable R_PROFILE_USER is set, the file it points to is used instead of the .Rprofile files.\nAny function named .First() in either of the two profile files or in the .RData image has a special status. It is automatically performed at the beginning of an R session and may be used to initialize the environment. For example, the definition in the example below alters the prompt to $ and sets up various other useful things that can then be taken for granted in the rest of the session.\nThus, the sequence in which files are executed is, Rprofile.site, the user profile, .RData and then .First(). A definition in later files will mask definitions in earlier files.\n> .First <- function() {\n  options(prompt=\"$ \", continue=\"+\\t\")  # $ is the prompt\n  options(digits=5, length=999)         # custom numbers and printout\n  x11()                                 # for graphics\n  par(pch = \"+\")                        # plotting character\n  source(file.path(Sys.getenv(\"HOME\"), \"R\", \"mystuff.R\"))\n                                        # my personal functions\n  library(MASS)                         # attach a package\n}\nSimilarly a function .Last(), if defined, is (normally) executed at the very end of the session. An example is given below.\n> .Last <- function() {\n  graphics.off()                        # a small safety measure.\n  cat(paste(date(),\"\\nAdios\\n\"))        # Is it time for lunch?\n}"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-classes-generic-functions-and-object-orientation",
    "href": "content/R/r-manuals/test.html#sec-classes-generic-functions-and-object-orientation",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.9 Classes, generic functions and object orientation",
    "text": "10.9 Classes, generic functions and object orientation\nThe class of an object determines how it will be treated by what are known as generic functions. Put the other way round, a generic function performs a task or action on its arguments specific to the class of the argument itself. If the argument lacks any class attribute, or has a class not catered for specifically by the generic function in question, there is always a default action provided.\nAn example makes things clearer. The class mechanism offers the user the facility of designing and writing generic functions for special purposes. Among the other generic functions are plot() for displaying objects graphically, summary() for summarizing analyses of various types, and anova() for comparing statistical models.\nThe number of generic functions that can treat a class in a specific way can be quite large. For example, the functions that can accommodate in some fashion objects of class \"data.frame\" include\n[     [[<-    any    as.matrix\n[<-   mean    plot   summary\nA currently complete list can be got by using the methods() function:\n> methods(class=\"data.frame\")\nConversely the number of classes a generic function can handle can also be quite large. For example the plot() function has a default method and variants for objects of classes \"data.frame\", \"density\", \"factor\", and more. A complete list can be got again by using the methods() function:\n> methods(plot)\nFor many generic functions the function body is quite short, for example\n> coef\nfunction (object, ...)\nUseMethod(\"coef\")\nThe presence of UseMethod indicates this is a generic function. To see what methods are available we can use methods()\n> methods(coef)\n[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*\n[5] coef.nls*         coef.summary.nls*\n\n   Non-visible functions are asterisked\nIn this example there are six methods, none of which can be seen by typing its name. We can read these by either of\n> getAnywhere(\"coef.aov\")\nA single object matching 'coef.aov' was found\nIt was found in the following places\n  registered S3 method for coef from namespace stats\n  namespace:stats\nwith value\n\nfunction (object, ...)\n{\n    z <- object$coef\n    z[!is.na(z)]\n}\n\n> getS3method(\"coef\", \"aov\")\nfunction (object, ...)\n{\n    z <- object$coef\n    z[!is.na(z)]\n}\nA function named gen.``cl will be invoked by the generic gen for class cl, so do not name functions in this style unless they are intended to be methods.\nThe reader is referred to the R Language Definition for a more complete discussion of this mechanism."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-defining-statistical-models-formulae",
    "href": "content/R/r-manuals/test.html#sec-defining-statistical-models-formulae",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.1 Defining statistical models; formulae",
    "text": "11.1 Defining statistical models; formulae\nThe template for a statistical model is a linear regression model with independent, homoscedastic errors\n\ny_i = sum_{j=0}^p beta_j x_{ij} + e_i,     i = 1, …, n,\n\nwhere the e_i are NID(0, sigma^2). In matrix terms this would be written\n\ny = X  beta + e\n\nwhere the y is the response vector, X is the model matrix or design matrix and has columns x_0, x_1, …, x_p, the determining variables. Very often x_0 will be a column of ones defining an intercept term.\n\n11.1.1 Examples\nBefore giving a formal specification, a few examples may usefully set the picture.\nSuppose y, x, x0, x1, x2, … are numeric variables, X is a matrix and A, B, C, … are factors. The following formulae on the left side below specify statistical models as described on the right.\ny ~ x\ny ~ 1 + x\n: Both imply the same simple linear regression model of y on x. The first has an implicit intercept term, and the second an explicit one.\ny ~ 0 + x\ny ~ -1 + x\ny ~ x - 1\n: Simple linear regression of y on x through the origin (that is, without an intercept term).\n\nlog(y) ~ x1 + x2\n\nMultiple regression of the transformed variable, log(y), on x1 and x2 (with an implicit intercept term).\n\n\ny ~ poly(x,2)\ny ~ 1 + x + I(x^2)\n: Polynomial regression of y on x of degree 2. The first form uses orthogonal polynomials, and the second uses explicit powers, as basis.\n\ny ~ X + poly(x,2)\n\nMultiple regression y with model matrix consisting of the matrix X as well as polynomial terms in x to degree 2.\n\ny ~ A\n\nSingle classification analysis of variance model of y, with classes determined by A.\n\ny ~ A + x\n\nSingle classification analysis of covariance model of y, with classes determined by A, and with covariate x.\n\n\ny ~ A*B\ny ~ A + B + A:B\ny ~ B %in% A\ny ~ A/B\n: Two factor non-additive model of y on A and B. The first two specify the same crossed classification and the second two specify the same nested classification. In abstract terms all four specify the same model subspace.\ny ~ (A + B + C)^2\ny ~ A*B*C - A:B:C\n: Three factor experiment but with a model containing main effects and two factor interactions only. Both formulae specify the same model.\ny ~ A * x\ny ~ A/x\ny ~ A/(1 + x) - 1\n: Separate simple linear regression models of y on x within the levels of A, with different codings. The last form produces explicit estimates of as many different intercepts and slopes as there are levels in A.\n\ny ~ A*B + Error(C)\n\nAn experiment with two treatment factors, A and B, and error strata determined by factor C. For example a split plot experiment, with whole plots (and hence also subplots), determined by factor C.\n\n\nThe operator ~ is used to define a model formula in R. The form, for an ordinary linear model, is\nresponse ~ op_1 term_1 op_2 term_2 op_3 term_3 …\nwhere\n\nresponse\n\nis a vector or matrix, (or expression evaluating to a vector or matrix) defining the response variable(s).\n\nop_i\n\nis an operator, either + or -, implying the inclusion or exclusion of a term in the model, (the first is optional).\n\nterm_i\n\nis either\n\na vector or matrix expression, or 1,\na factor, or\na formula expression consisting of factors, vectors or matrices connected by formula operators.\n\nIn all cases each term defines a collection of columns either to be added to or removed from the model matrix. A 1 stands for an intercept column and is by default included in the model matrix unless explicitly removed.\n\n\nThe formula operators are similar in effect to the Wilkinson and Rogers notation used by such programs as Glim and Genstat. One inevitable change is that the operator .’ becomes ’: since the period is a valid name character in R.\nThe notation is summarized below (based on Chambers & Hastie, 1992, p.29):\n\nY~ ``M\n\nY is modeled as M.\n\nM_1+ ``M_2\n\nInclude M_1 and M_2.\n\nM_1- ``M_2\n\nInclude M_1 leaving out terms of M_2.\n\nM_1: ``M_2\n\nThe tensor product of M_1 and M_2. If both terms are factors, then the “subclasses” factor.\n\nM_1%in% ``M_2\n\nSimilar to M_1:``M_2, but with a different coding.\n\nM_1* ``M_2\n\nM_1+ ``M_2+ ``M_1:``M_2.\n\nM_1/ ``M_2\n\nM_1+ ``M_2%in% ``M_1.\n\nM^``n\n\nAll terms in M together with “interactions” up to order n\n\nI(``M)\n\nInsulate M. Inside M all operators have their normal arithmetic meaning, and that term appears in the model matrix.\n\n\nNote that inside the parentheses that usually enclose function arguments all operators have their normal arithmetic meaning. The function I() is an identity function used to allow terms in model formulae to be defined using arithmetic operators.\nNote particularly that the model formulae specify the columns of the model matrix, the specification of the parameters being implicit. This is not the case in other contexts, for example in specifying nonlinear models.\n\n\n11.1.2 Contrasts\nWe need at least some idea how the model formulae specify the columns of the model matrix. This is easy if we have continuous variables, as each provides one column of the model matrix (and the intercept will provide a column of ones if included in the model).\nWhat about a k-level factor A? The answer differs for unordered and ordered factors. For unordered factors k - 1 columns are generated for the indicators of the second, …, kth levels of the factor. (Thus the implicit parameterization is to contrast the response at each level with that at the first.) For ordered factors the k - 1 columns are the orthogonal polynomials on 1, …, k, omitting the constant term.\nAlthough the answer is already complicated, it is not the whole story. First, if the intercept is omitted in a model that contains a factor term, the first such term is encoded into k columns giving the indicators for all the levels. Second, the whole behavior can be changed by the options setting for contrasts. The default setting in R is\noptions(contrasts = c(\"contr.treatment\", \"contr.poly\"))\nThe main reason for mentioning this is that R and S have different defaults for unordered factors, S using Helmert contrasts. So if you need to compare your results to those of a textbook or paper which used S-PLUS, you will need to set\noptions(contrasts = c(\"contr.helmert\", \"contr.poly\"))\nThis is a deliberate difference, as treatment contrasts (R’s default) are thought easier for newcomers to interpret.\nWe have still not finished, as the contrast scheme to be used can be set for each term in the model using the functions contrasts and C.\nWe have not yet considered interaction terms: these generate the products of the columns introduced for their component terms.\nAlthough the details are complicated, model formulae in R will normally generate the models that an expert statistician would expect, provided that marginality is preserved. Fitting, for example, a model with an interaction but not the corresponding main effects will in general lead to surprising results, and is for experts only."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-linear-models",
    "href": "content/R/r-manuals/test.html#sec-linear-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.2 Linear models",
    "text": "11.2 Linear models\nThe basic function for fitting ordinary multiple models is lm(), and a streamlined version of the call is as follows:\n> fitted.model <- lm(formula, data = data.frame)\nFor example\n> fm2 <- lm(y ~ x1 + x2, data = production)\nwould fit a multiple regression model of y on x1 and x2 (with implicit intercept term).\nThe important (but technically optional) parameter data = production specifies that any variables needed to construct the model should come first from the production data frame. This is the case regardless of whether data frame production has been attached on the search path or not."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-generic-functions-for-extracting-model-information",
    "href": "content/R/r-manuals/test.html#sec-generic-functions-for-extracting-model-information",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.3 Generic functions for extracting model information",
    "text": "11.3 Generic functions for extracting model information\nThe value of lm() is a fitted model object; technically a list of results of class \"lm\". Information about the fitted model can then be displayed, extracted, plotted and so on by using generic functions that orient themselves to objects of class \"lm\". These include\nadd1    deviance   formula      predict  step\nalias   drop1      kappa        print    summary\nanova   effects    labels       proj     vcov\ncoef    family     plot         residuals\nA brief description of the most commonly used ones is given below.\n\nanova(``object_1, ``object_2)\nCompare a submodel with an outer model and produce an analysis of variance table.\ncoef(``object)\nExtract the regression coefficient (matrix).\nLong form: coefficients(``object).\ndeviance(``object)\nResidual sum of squares, weighted if appropriate.\nformula(``object)\nExtract the model formula.\nplot(``object)\nProduce four plots, showing residuals, fitted values and some diagnostics.\npredict(``object, newdata=``data.frame)\nThe data frame supplied must have variables specified with the same labels as the original. The value is a vector or matrix of predicted values corresponding to the determining variable values in data.frame.\nprint(``object)\nPrint a concise version of the object. Most often used implicitly.\nresiduals(``object)\nExtract the (matrix of) residuals, weighted as appropriate.\nShort form: resid(``object).\nstep(``object)\nSelect a suitable model by adding or dropping terms and preserving hierarchies. The model with the smallest value of AIC (Akaike’s An Information Criterion) discovered in the stepwise search is returned.\nsummary(``object)\nPrint a comprehensive summary of the results of the regression analysis.\nvcov(``object)\nReturns the variance-covariance matrix of the main parameters of a fitted model object."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-analysis-of-variance-and-model-comparison",
    "href": "content/R/r-manuals/test.html#sec-analysis-of-variance-and-model-comparison",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.4 Analysis of variance and model comparison",
    "text": "11.4 Analysis of variance and model comparison\nThe model fitting function aov(``formula, data=``data.frame) operates at the simplest level in a very similar way to the function lm(), and most of the generic functions listed in the table in Generic functions for extracting model information apply.\nIt should be noted that in addition aov() allows an analysis of models with multiple error strata such as split plot experiments, or balanced incomplete block designs with recovery of inter-block information. The model formula\nresponse ~ mean.formula + Error(strata.formula)\nspecifies a multi-stratum experiment with error strata defined by the strata.formula. In the simplest case, strata.formula is simply a factor, when it defines a two strata experiment, namely between and within the levels of the factor.\nFor example, with all determining variables factors, a model formula such as that in:\n> fm <- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)\nwould typically be used to describe an experiment with mean model v + n*p*k and three error strata, namely “between farms”, “within farms, between blocks” and “within blocks”.\n\n11.4.1 ANOVA tables\nNote also that the analysis of variance table (or tables) are for a sequence of fitted models. The sums of squares shown are the decrease in the residual sums of squares resulting from an inclusion of that term in the model at that place in the sequence. Hence only for orthogonal experiments will the order of inclusion be inconsequential.\nFor multistratum experiments the procedure is first to project the response onto the error strata, again in sequence, and to fit the mean model to each projection. For further details, see Chambers & Hastie (1992).\nA more flexible alternative to the default full ANOVA table is to compare two or more models directly using the anova() function.\n> anova(fitted.model.1, fitted.model.2, …)\nThe display is then an ANOVA table showing the differences between the fitted models when fitted in sequence. The fitted models being compared would usually be an hierarchical sequence, of course. This does not give different information to the default, but rather makes it easier to comprehend and control."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-updating-fitted-models",
    "href": "content/R/r-manuals/test.html#sec-updating-fitted-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.5 Updating fitted models",
    "text": "11.5 Updating fitted models\nThe update() function is largely a convenience function that allows a model to be fitted that differs from one previously fitted usually by just a few additional or removed terms. Its form is\n> new.model <- update(old.model, new.formula)\nIn the new.formula the special name consisting of a period, ., only, can be used to stand for “the corresponding part of the old model formula”. For example,\n> fm05 <- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)\n> fm6  <- update(fm05, . ~ . + x6)\n> smf6 <- update(fm6, sqrt(.) ~ .)\nwould fit a five variate multiple regression with variables (presumably) from the data frame production, fit an additional model including a sixth regressor variable, and fit a variant on the model where the response had a square root transform applied.\nNote especially that if the data= argument is specified on the original call to the model fitting function, this information is passed on through the fitted model object to update() and its allies.\nThe name ‘.’ can also be used in other contexts, but with slightly different meaning. For example\n> fmfull <- lm(y ~ . , data = production)\nwould fit a model with response y and regressor variables all other variables in the data frame production.\nOther functions for exploring incremental sequences of models are add1(), drop1() and step(). The names of these give a good clue to their purpose, but for full details see the on-line help."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-generalized-linear-models",
    "href": "content/R/r-manuals/test.html#sec-generalized-linear-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.6 Generalized linear models",
    "text": "11.6 Generalized linear models\nGeneralized linear modeling is a development of linear models to accommodate both non-normal response distributions and transformations to linearity in a clean and straightforward way. A generalized linear model may be described in terms of the following sequence of assumptions:\n\nThere is a response, y, of interest and stimulus variables x_1, x_2, …, whose values influence the distribution of the response.\nThe stimulus variables influence the distribution of y through a single linear function, only. This linear function is called the linear predictor, and is usually written\n\neta = beta_1 x_1 + beta_2 x_2 + … + beta_p x_p,\n\nhence x_i has no influence on the distribution of y if and only if beta_i is zero.\nThe distribution of y is of the form\n\nf_Y(y; mu, phi)\n  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))\n\nwhere phi is a scale parameter (possibly known), and is constant for all observations, A represents a prior weight, assumed known but possibly varying with the observations, and $\\mu$ is the mean of y. So it is assumed that the distribution of y is determined by its mean and possibly a scale parameter as well.\nThe mean, mu, is a smooth invertible function of the linear predictor:\n\nmu = m(eta),    eta = m^{-1}(mu) = ell(mu)\n\nand this inverse function, ell(), is called the link function.\n\nThese assumptions are loose enough to encompass a wide class of models useful in statistical practice, but tight enough to allow the development of a unified methodology of estimation and inference, at least approximately. The reader is referred to any of the current reference works on the subject for full details, such as McCullagh & Nelder (1989) or Dobson (1990).\n\n11.6.1 Families\nThe class of generalized linear models handled by facilities supplied in R includes gaussian, binomial, poisson, inverse gaussian and gamma response distributions and also quasi-likelihood models where the response distribution is not explicitly specified. In the latter case the variance function must be specified as a function of the mean, but in other cases this function is implied by the response distribution.\nEach response distribution admits a variety of link functions to connect the mean with the linear predictor. Those automatically available are shown in the following table:\n\n\n\n\n\nFamily name\nLink functions\n\n\n\n\nbinomial\nlogit, probit, log, cloglog\n\n\ngaussian\nidentity, log, inverse\n\n\nGamma\nidentity, inverse, log\n\n\ninverse.gaussian\n1/mu^2, identity, inverse, log\n\n\npoisson\nidentity, log, sqrt\n\n\nquasi\nlogit, probit, cloglog, identity, inverse, log, 1/mu^2, sqrt\n\n\n\n\n\nThe combination of a response distribution, a link function and various other pieces of information that are needed to carry out the modeling exercise is called the family of the generalized linear model.\n\n\n11.6.2 The glm() function\nSince the distribution of the response depends on the stimulus variables through a single linear function only, the same mechanism as was used for linear models can still be used to specify the linear part of a generalized model. The family has to be specified in a different way.\nThe R function to fit a generalized linear model is glm() which uses the form\n> fitted.model <- glm(formula, family=family.generator, data=data.frame)\nThe only new feature is the family.generator, which is the instrument by which the family is described. It is the name of a function that generates a list of functions and expressions that together define and control the model and estimation process. Although this may seem a little complicated at first sight, its use is quite simple.\nThe names of the standard, supplied family generators are given under “Family Name” in the table in Families. Where there is a choice of links, the name of the link may also be supplied with the family name, in parentheses as a parameter. In the case of the quasi family, the variance function may also be specified in this way.\nSome examples make the process clear.\n\n\n11.6.3 The gaussian family\nA call such as\n> fm <- glm(y ~ x1 + x2, family = gaussian, data = sales)\nachieves the same result as\n> fm <- lm(y ~ x1+x2, data=sales)\nbut much less efficiently. Note how the gaussian family is not automatically provided with a choice of links, so no parameter is allowed. If a problem requires a gaussian family with a nonstandard link, this can usually be achieved through the quasi family, as we shall see later.\n\n\n11.6.4 The binomial family\nConsider a small, artificial example, from Silvey (1970).\nOn the Aegean island of Kalythos the male inhabitants suffer from a congenital eye disease, the effects of which become more marked with increasing age. Samples of islander males of various ages were tested for blindness and the results recorded. The data is shown below:\nThe problem we consider is to fit both logistic and probit models to this data, and to estimate for each model the LD50, that is the age at which the chance of blindness for a male inhabitant is 50%.\nIf y is the number of blind at age x and n the number tested, both models have the form y ~ B(n, F(beta_0 + beta_1 x)) where for the probit case, F(z) = Phi(z) is the standard normal distribution function, and in the logit case (the default), F(z) = e^z/(1+e^z). In both cases the LD50 is LD50 = - beta_0/beta_1 that is, the point at which the argument of the distribution function is zero.\nThe first step is to set the data up as a data frame\n> kalythos <- data.frame(x = c(20,35,45,55,70), n = rep(50,5),\n                         y = c(6,17,26,37,44))\nTo fit a binomial model using glm() there are three possibilities for the response:\n\nIf the response is a vector it is assumed to hold binary data, and so must be a 0/1 vector.\nIf the response is a two-column matrix it is assumed that the first column holds the number of successes for the trial and the second holds the number of failures.\nIf the response is a factor, its first level is taken as failure (0) and all other levels as ‘success’ (1).\n\nHere we need the second of these conventions, so we add a matrix to our data frame:\n> kalythos$Ymat <- cbind(kalythos$y, kalythos$n - kalythos$y)\nTo fit the models we use\n> fmp <- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)\n> fml <- glm(Ymat ~ x, family = binomial, data = kalythos)\nSince the logit link is the default the parameter may be omitted on the second call. To see the results of each fit we could use\n> summary(fmp)\n> summary(fml)\nBoth models fit (all too) well. To find the LD50 estimate we can use a simple function:\n> ld50 <- function(b) -b[1]/b[2]\n> ldp <- ld50(coef(fmp)); ldl <- ld50(coef(fml)); c(ldp, ldl)\nThe actual estimates from this data are 43.663 years and 43.601 years respectively.\n\n\n11.6.5 Poisson models\nWith the Poisson family the default link is the log, and in practice the major use of this family is to fit surrogate Poisson log-linear models to frequency data, whose actual distribution is often multinomial. This is a large and important subject we will not discuss further here. It even forms a major part of the use of non-gaussian generalized models overall.\nOccasionally genuinely Poisson data arises in practice and in the past it was often analyzed as gaussian data after either a log or a square-root transformation. As a graceful alternative to the latter, a Poisson generalized linear model may be fitted as in the following example:\n> fmod <- glm(y ~ A + B + x, family = poisson(link=sqrt),\n              data = worm.counts)\n\n\n11.6.6 Quasi-likelihood models\nFor all families the variance of the response will depend on the mean and will have the scale parameter as a multiplier. The form of dependence of the variance on the mean is a characteristic of the response distribution; for example for the poisson distribution Var(y) = mu.\nFor quasi-likelihood estimation and inference the precise response distribution is not specified, but rather only a link function and the form of the variance function as it depends on the mean. Since quasi-likelihood estimation uses formally identical techniques to those for the gaussian distribution, this family provides a way of fitting gaussian models with non-standard link functions or variance functions, incidentally.\nFor example, consider fitting the non-linear regression y = theta_1 z_1 / (z_2 - theta_2) + e which may be written alternatively as y = 1 / (beta_1 x_1 + beta_2 x_2) + e where x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 = theta_2/theta_1. Supposing a suitable data frame to be set up we could fit this non-linear regression as\n> nlfit <- glm(y ~ x1 + x2 - 1,\n               family = quasi(link=inverse, variance=constant),\n               data = biochem)\nThe reader is referred to the manual and the help document for further information, as needed."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-nonlinear-least-squares-and-maximum-likelihood-models",
    "href": "content/R/r-manuals/test.html#sec-nonlinear-least-squares-and-maximum-likelihood-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.7 Nonlinear least squares and maximum likelihood models",
    "text": "11.7 Nonlinear least squares and maximum likelihood models\nCertain forms of nonlinear model can be fitted by Generalized Linear Models (glm()). But in the majority of cases we have to approach the nonlinear curve fitting problem as one of nonlinear optimization. R’s nonlinear optimization routines are optim(), nlm() and nlminb(), We seek the parameter values that minimize some index of lack-of-fit, and they do this by trying out various parameter values iteratively. Unlike linear regression for example, there is no guarantee that the procedure will converge on satisfactory estimates. All the methods require initial guesses about what parameter values to try, and convergence may depend critically upon the quality of the starting values.\n\n11.7.1 Least squares\nOne way to fit a nonlinear model is by minimizing the sum of the squared errors (SSE) or residuals. This method makes sense if the observed errors could have plausibly arisen from a normal distribution.\nHere is an example from Bates & Watts (1988), page 51. The data are:\n> x <- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,\n         1.10, 1.10)\n> y <- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)\nThe fit criterion to be minimized is:\n> fn <- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)\nIn order to do the fit we need initial estimates of the parameters. One way to find sensible starting values is to plot the data, guess some parameter values, and superimpose the model curve using those values.\n> plot(x, y)\n> xfit <- seq(.02, 1.1, .05)\n> yfit <- 200 * xfit/(0.1 + xfit)\n> lines(spline(xfit, yfit))\nWe could do better, but these starting values of 200 and 0.1 seem adequate. Now do the fit:\n> out <- nlm(fn, p = c(200, 0.1), hessian = TRUE)\nAfter the fitting, out$minimum is the SSE, and out$estimate are the least squares estimates of the parameters. To obtain the approximate standard errors (SE) of the estimates we do:\n> sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))\nThe 2 which is subtracted in the line above represents the number of parameters. A 95% confidence interval would be the parameter estimate +/- 1.96 SE. We can superimpose the least squares fit on a new plot:\n> plot(x, y)\n> xfit <- seq(.02, 1.1, .05)\n> yfit <- 212.68384222 * xfit/(0.06412146 + xfit)\n> lines(spline(xfit, yfit))\nThe standard package stats provides much more extensive facilities for fitting non-linear models by least squares. The model we have just fitted is the Michaelis-Menten model, so we can use\n> df <- data.frame(x=x, y=y)\n> fit <- nls(y ~ SSmicmen(x, Vm, K), df)\n> fit\nNonlinear regression model\n  model:  y ~ SSmicmen(x, Vm, K)\n   data:  df\n          Vm            K\n212.68370711   0.06412123\n residual sum-of-squares:  1195.449\n> summary(fit)\n\nFormula: y ~ SSmicmen(x, Vm, K)\n\nParameters:\n    Estimate Std. Error t value Pr(>|t|)\nVm 2.127e+02  6.947e+00  30.615 3.24e-11\nK  6.412e-02  8.281e-03   7.743 1.57e-05\n\nResidual standard error: 10.93 on 10 degrees of freedom\n\nCorrelation of Parameter Estimates:\n      Vm\nK 0.7651\n\n\n11.7.2 Maximum likelihood\nMaximum likelihood is a method of nonlinear model fitting that applies even if the errors are not normal. The method finds the parameter values which maximize the log likelihood, or equivalently which minimize the negative log-likelihood. Here is an example from Dobson (1990), pp. 108–111. This example fits a logistic model to dose-response data, which clearly could also be fit by glm(). The data are:\n> x <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,\n         1.8369, 1.8610, 1.8839)\n> y <- c( 6, 13, 18, 28, 52, 53, 61, 60)\n> n <- c(59, 60, 62, 56, 63, 59, 62, 60)\nThe negative log-likelihood to minimize is:\n> fn <- function(p)\n   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))\n           + log(choose(n, y)) ))\nWe pick sensible starting values and do the fit:\n> out <- nlm(fn, p = c(-50,20), hessian = TRUE)\nAfter the fitting, out$minimum is the negative log-likelihood, and out$estimate are the maximum likelihood estimates of the parameters. To obtain the approximate SEs of the estimates we do:\n> sqrt(diag(solve(out$hessian)))\nA 95% confidence interval would be the parameter estimate +/- 1.96 SE."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-some-non-standard-models",
    "href": "content/R/r-manuals/test.html#sec-some-non-standard-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.8 Some non-standard models",
    "text": "11.8 Some non-standard models\nWe conclude this chapter with just a brief mention of some of the other facilities available in R for special regression and data analysis problems.\n\n Mixed models. The recommended nlme package provides functions lme() and nlme() for linear and non-linear mixed-effects models, that is linear and non-linear regressions in which some of the coefficients correspond to random effects. These functions make heavy use of formulae to specify the models.\n Local approximating regressions. The loess() function fits a nonparametric regression by using a locally weighted regression. Such regressions are useful for highlighting a trend in messy data or for data reduction to give some insight into a large data set.\nFunction loess is in the standard package stats, together with code for projection pursuit regression.\n Robust regression. There are several functions available for fitting regression models in a way resistant to the influence of extreme outliers in the data. Function lqs in the recommended package MASS provides state-of-art algorithms for highly-resistant fits. Less resistant but statistically more efficient methods are available in packages, for example function rlm in package MASS.\n Additive models. This technique aims to construct a regression function from smooth additive functions of the determining variables, usually one for each determining variable. Functions avas and ace in package acepack and functions bruto and mars in package mda provide some examples of these techniques in user-contributed packages to R. An extension is Generalized Additive Models, implemented in user-contributed packages gam and mgcv.\n Tree-based models. Rather than seek an explicit global linear model for prediction or interpretation, tree-based models seek to bifurcate the data, recursively, at critical points of the determining variables in order to partition the data ultimately into groups that are as homogeneous as possible within, and as heterogeneous as possible between. The results often lead to insights that other data analysis methods tend not to yield.\nModels are again specified in the ordinary linear model form. The model fitting function is tree(), but many other generic functions such as plot() and text() are well adapted to displaying the results of a tree-based model fit in a graphical way.\nTree models are available in R via the user-contributed packages rpart and tree."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-high-level-plotting-commands",
    "href": "content/R/r-manuals/test.html#sec-high-level-plotting-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.1 High-level plotting commands",
    "text": "12.1 High-level plotting commands\nHigh-level plotting functions are designed to generate a complete plot of the data passed as arguments to the function. Where appropriate, axes, labels and titles are automatically generated (unless you request otherwise.) High-level plotting commands always start a new plot, erasing the current plot if necessary.\n\n12.1.1 The plot() function\nOne of the most frequently used plotting functions in R is the plot() function. This is a generic function: the type of plot produced is dependent on the type or class of the first argument.\nplot(``x, ``y)\nplot(``xy)\n: If x and y are vectors, plot(``x, ``y) produces a scatterplot of y against x. The same effect can be produced by supplying one argument (second form) as either a list containing two elements x and y or a two-column matrix.\n\nplot(``x)\n\nIf x is a time series, this produces a time-series plot. If x is a numeric vector, it produces a plot of the values in the vector against their index in the vector. If x is a complex vector, it produces a plot of imaginary versus real parts of the vector elements.\n\n\nplot(``f)\nplot(``f, ``y)\n: f is a factor object, y is a numeric vector. The first form generates a bar plot of f; the second form produces boxplots of y for each level of f.\nplot(``df)\nplot(~ ``expr)\nplot(``y~ ``expr)\n: df is a data frame, y is any object, expr is a list of object names separated by + (e.g., a + b + c). The first two forms produce distributional plots of the variables in a data frame (first form) or of a number of named objects (second form). The third form plots y against every object named in expr.\n\n\n12.1.2 Displaying multivariate data\nR provides two very useful functions for representing multivariate data. If X is a numeric matrix or data frame, the command\n> pairs(X)\nproduces a pairwise scatterplot matrix of the variables defined by the columns of X, that is, every column of X is plotted against every other column of X and the resulting n(n-1) plots are arranged in a matrix with plot scales constant over the rows and columns of the matrix.\nWhen three or four variables are involved a coplot may be more enlightening. If a and b are numeric vectors and c is a numeric vector or factor object (all of the same length), then the command\n> coplot(a ~ b | c)\nproduces a number of scatterplots of a against b for given values of c. If c is a factor, this simply means that a is plotted against b for every level of c. When c is numeric, it is divided into a number of conditioning intervals and for each interval a is plotted against b for values of c within the interval. The number and position of intervals can be controlled with given.values= argument to coplot()—the function co.intervals() is useful for selecting intervals. You can also use two given variables with a command like\n> coplot(a ~ b | c + d)\nwhich produces scatterplots of a against b for every joint conditioning interval of c and d.\nThe coplot() and pairs() function both take an argument panel= which can be used to customize the type of plot which appears in each panel. The default is points() to produce a scatterplot but by supplying some other low-level graphics function of two vectors x and y as the value of panel= you can produce any type of plot you wish. An example panel function useful for coplots is panel.smooth().\n\n\n12.1.3 Display graphics\nOther high-level graphics functions produce different types of plots. Some examples are:\nqqnorm(x)\nqqline(x)\nqqplot(x, y)\n: \nDistribution-comparison plots. The first form plots the numeric\nvector `x` against the expected Normal order scores (a normal scores\nplot) and the second adds a straight line to such a plot by drawing\na line through the distribution and data quartiles. The third form\nplots the quantiles of `x` against those of `y` to compare their\nrespective distributions.\nhist(x)\nhist(x, nclass=``n)\nhist(x, breaks=``b, …)\n: \nProduces a histogram of the numeric vector `x`. A sensible number of\nclasses is usually chosen, but a recommendation can be given with\nthe `nclass=` argument. Alternatively, the breakpoints can be\nspecified exactly with the `breaks=` argument. If the\n`probability=TRUE` argument is given, the bars represent relative\nfrequencies divided by bin width instead of counts.\n\ndotchart(x, …)\n\n\nConstructs a dotchart of the data in x. In a dotchart the y-axis gives a labelling of the data in x and the x-axis gives its value. For example it allows easy visual selection of all data entries with values lying in specified ranges.\n\n\nimage(x, y, z, …)\ncontour(x, y, z, …)\npersp(x, y, z, …)\n: \nPlots of three variables. The `image` plot draws a grid of\nrectangles using different colours to represent the value of `z`,\nthe `contour` plot draws contour lines to represent the value of\n`z`, and the `persp` plot draws a 3D surface.\n\n\n12.1.4 Arguments to high-level plotting functions\nThere are a number of arguments which may be passed to high-level graphics functions, as follows:\n\nadd=TRUE\n\nForces the function to act as a low-level graphics function, superimposing the plot on the current plot (some functions only).\n\naxes=FALSE\n\nSuppresses generation of axes—useful for adding your own custom axes with the axis() function. The default, axes=TRUE, means include axes.\n\n\nlog=\"x\"\nlog=\"y\"\nlog=\"xy\"\n: Causes the x, y or both axes to be logarithmic. This will work for many, but not all, types of plot.\n\ntype=\n\nThe type= argument controls the type of plot produced, as follows:\n\ntype=\"p\"\n\nPlot individual points (the default)\n\ntype=\"l\"\n\nPlot lines\n\ntype=\"b\"\n\nPlot points connected by lines (both)\n\ntype=\"o\"\n\nPlot points overlaid by lines\n\ntype=\"h\"\n\nPlot vertical lines from points to the zero axis (high-density)\n\n\ntype=\"s\"\ntype=\"S\"\n: Step-function plots. In the first form, the top of the vertical defines the point; in the second, the bottom.\n\ntype=\"n\"\n\nNo plotting at all. However axes are still drawn (by default) and the coordinate system is set up according to the data. Ideal for creating plots with subsequent low-level graphics functions.\n\n\n\n\nxlab=``string\nylab=``string\n: Axis labels for the x and y axes. Use these arguments to change the default labels, usually the names of the objects used in the call to the high-level plotting function.\n\nmain=``string\n\nFigure title, placed at the top of the plot in a large font.\n\nsub=``string\n\nSub-title, placed just below the x-axis in a smaller font."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-low-level-plotting-commands",
    "href": "content/R/r-manuals/test.html#sec-low-level-plotting-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.2 Low-level plotting commands",
    "text": "12.2 Low-level plotting commands\nSometimes the high-level plotting functions don’t produce exactly the kind of plot you desire. In this case, low-level plotting commands can be used to add extra information (such as points, lines or text) to the current plot.\nSome of the more useful low-level plotting functions are:\npoints(x, y)\nlines(x, y)\n: \nAdds points or connected lines to the current plot. `plot()`'s\n`type=` argument can also be passed to these functions (and defaults\nto `\"p\"` for `points()` and `\"l\"` for `lines()`.)\n\ntext(x, y, labels, …)\n\n\nAdd text to a plot at points given by x, y. Normally labels is an integer or character vector in which case labels[i] is plotted at point (x[i], y[i]). The default is 1:length(x).\nNote: This function is often used in the sequence\n> plot(x, y, type=\"n\"); text(x, y, names)\nThe graphics parameter type=\"n\" suppresses the points but sets up the axes, and the text() function supplies special characters, as specified by the character vector names for the points.\n\n\nabline(a, b)\nabline(h=``y)\nabline(v=``x)\nabline(``lm.obj)\n: \nAdds a line of slope `b` and intercept `a` to the current plot.\n`h=``y`{.variable} may be used to specify *y*-coordinates for the\nheights of horizontal lines to go across a plot, and\n`v=``x`{.variable} similarly for the *x*-coordinates for vertical\nlines. Also `lm.obj`{.variable} may be list with a `coefficients`\ncomponent of length 2 (such as the result of model-fitting\nfunctions,) which are taken as an intercept and slope, in that\norder.\n\npolygon(x, y, …)\n\n\nDraws a polygon defined by the ordered vertices in (x, y) and (optionally) shade it in with hatch lines, or fill it if the graphics device allows the filling of figures.\n\nlegend(x, y, legend, …)\n\n\nAdds a legend to the current plot at the specified position. Plotting characters, line styles, colors etc., are identified with the labels in the character vector legend. At least one other argument v (a vector the same length as legend) with the corresponding values of the plotting unit must also be given, as follows:\n\nlegend( , fill=``v)\n\nColors for filled boxes\n\nlegend( , col=``v)\n\nColors in which points or lines will be drawn\n\nlegend( , lty=``v)\n\nLine styles\n\nlegend( , lwd=``v)\n\nLine widths\n\nlegend( , pch=``v)\n\nPlotting characters (character vector)\n\n\n\ntitle(main, sub)\n\n\nAdds a title main to the top of the current plot in a large font and (optionally) a sub-title sub at the bottom in a smaller font.\n\naxis(side, …)\n\n\nAdds an axis to the current plot on the side given by the first argument (1 to 4, counting clockwise from the bottom.) Other arguments control the positioning of the axis within or beside the plot, and tick positions and labels. Useful for adding custom axes after calling plot() with the axes=FALSE argument.\n\n\nLow-level plotting functions usually require some positioning information (e.g., x and y coordinates) to determine where to place the new plot elements. Coordinates are given in terms of user coordinates which are defined by the previous high-level graphics command and are chosen based on the supplied data.\nWhere x and y arguments are required, it is also sufficient to supply a single argument being a list with elements named x and y. Similarly a matrix with two columns is also valid input. In this way functions such as locator() (see below) may be used to specify positions on a plot interactively.\n\n12.2.1 Mathematical annotation\nIn some cases, it is useful to add mathematical symbols and formulae to a plot. This can be achieved in R by specifying an expression rather than a character string in any one of text, mtext, axis, or title. For example, the following code draws the formula for the Binomial probability function:\n> text(x, y, expression(paste(bgroup(\"(\", atop(n, x), \")\"), p^x, q^{n-x})))\nMore information, including a full listing of the features available can obtained from within R using the commands:\n> help(plotmath)\n> example(plotmath)\n> demo(plotmath)\n\n\n12.2.2 Hershey vector fonts\nIt is possible to specify Hershey vector fonts for rendering text when using the text and contour functions. There are three reasons for using the Hershey fonts:\n\nHershey fonts can produce better output, especially on a computer screen, for rotated and/or small text.\nHershey fonts provide certain symbols that may not be available in the standard fonts. In particular, there are zodiac signs, cartographic symbols and astronomical symbols.\nHershey fonts provide Cyrillic and Japanese (Kana and Kanji) characters.\n\nMore information, including tables of Hershey characters can be obtained from within R using the commands:\n> help(Hershey)\n> demo(Hershey)\n> help(Japanese)\n> demo(Japanese)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-interacting-with-graphics",
    "href": "content/R/r-manuals/test.html#sec-interacting-with-graphics",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.3 Interacting with graphics",
    "text": "12.3 Interacting with graphics\nR also provides functions which allow users to extract or add information to a plot using a mouse. The simplest of these is the locator() function:\n\nlocator(n, type)\n\n\nWaits for the user to select locations on the current plot using the left mouse button. This continues until n (default 512) points have been selected, or another mouse button is pressed. The type argument allows for plotting at the selected points and has the same effect as for high-level graphics commands; the default is no plotting. locator() returns the locations of the points selected as a list with two components x and y.\n\n\nlocator() is usually called with no arguments. It is particularly useful for interactively selecting positions for graphic elements such as legends or labels when it is difficult to calculate in advance where the graphic should be placed. For example, to place some informative text near an outlying point, the command\n> text(locator(1), \"Outlier\", adj=0)\nmay be useful. (locator() will be ignored if the current device, such as postscript does not support interactive pointing.)\n\nidentify(x, y, labels)\n\n\nAllow the user to highlight any of the points defined by x and y (using the left mouse button) by plotting the corresponding component of labels nearby (or the index number of the point if labels is absent). Returns the indices of the selected points when another button is pressed.\n\n\nSometimes we want to identify particular points on a plot, rather than their positions. For example, we may wish the user to select some observation of interest from a graphical display and then manipulate that observation in some way. Given a number of (x, y) coordinates in two numeric vectors x and y, we could use the identify() function as follows:\n> plot(x, y)\n> identify(x, y)\nThe identify() functions performs no plotting itself, but simply allows the user to move the mouse pointer and click the left mouse button near a point. If there is a point near the mouse pointer it will be marked with its index number (that is, its position in the x/y vectors) plotted nearby. Alternatively, you could use some informative string (such as a case name) as a highlight by using the labels argument to identify(), or disable marking altogether with the plot = FALSE argument. When the process is terminated (see above), identify() returns the indices of the selected points; you can use these indices to extract the selected points from the original vectors x and y."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-using-graphics-parameters",
    "href": "content/R/r-manuals/test.html#sec-using-graphics-parameters",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.4 Using graphics parameters",
    "text": "12.4 Using graphics parameters\nWhen creating graphics, particularly for presentation or publication purposes, R’s defaults do not always produce exactly that which is required. You can, however, customize almost every aspect of the display using graphics parameters. R maintains a list of a large number of graphics parameters which control things such as line style, colors, figure arrangement and text justification among many others. Every graphics parameter has a name (such as col, which controls colors,) and a value (a color number, for example.)\nA separate list of graphics parameters is maintained for each active device, and each device has a default set of parameters when initialized. Graphics parameters can be set in two ways: either permanently, affecting all graphics functions which access the current device; or temporarily, affecting only a single graphics function call.\n\n12.4.1 Permanent changes: The par() function\nThe par() function is used to access and modify the list of graphics parameters for the current graphics device.\n\npar()\n\nWithout arguments, returns a list of all graphics parameters and their values for the current device.\n\npar(c(\"col\", \"lty\"))\n\nWith a character vector argument, returns only the named graphics parameters (again, as a list.)\n\npar(col=4, lty=2)\n\nWith named arguments (or a single list argument), sets the values of the named graphics parameters, and returns the original values of the parameters as a list.\n\n\nSetting graphics parameters with the par() function changes the value of the parameters permanently, in the sense that all future calls to graphics functions (on the current device) will be affected by the new value. You can think of setting graphics parameters in this way as setting “default” values for the parameters, which will be used by all graphics functions unless an alternative value is given.\nNote that calls to par() always affect the global values of graphics parameters, even when par() is called from within a function. This is often undesirable behavior—usually we want to set some graphics parameters, do some plotting, and then restore the original values so as not to affect the user’s R session. You can restore the initial values by saving the result of par() when making changes, and restoring the initial values when plotting is complete.\n> oldpar <- par(col=4, lty=2)\n  … plotting commands …\n> par(oldpar)\nTo save and restore all settable24 graphical parameters use\n> oldpar <- par(no.readonly=TRUE)\n  … plotting commands …\n> par(oldpar)\n\n\n12.4.2 Temporary changes: Arguments to graphics functions\nGraphics parameters may also be passed to (almost) any graphics function as named arguments. This has the same effect as passing the arguments to the par() function, except that the changes only last for the duration of the function call. For example:\n> plot(x, y, pch=\"+\")\nproduces a scatterplot using a plus sign as the plotting character, without changing the default plotting character for future plots.\nUnfortunately, this is not implemented entirely consistently and it is sometimes necessary to set and reset graphics parameters using par()."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-graphics-parameters-list",
    "href": "content/R/r-manuals/test.html#sec-graphics-parameters-list",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.5 Graphics parameters list",
    "text": "12.5 Graphics parameters list\nThe following sections detail many of the commonly-used graphical parameters. The R help documentation for the par() function provides a more concise summary; this is provided as a somewhat more detailed alternative.\nGraphics parameters will be presented in the following form:\n\nname=``value\n\nA description of the parameter’s effect. name is the name of the parameter, that is, the argument name to use in calls to par() or a graphics function. value is a typical value you might use when setting the parameter.\n\n\nNote that axes is not a graphics parameter but an argument to a few plot methods: see xaxt and yaxt.\n\n12.5.1 Graphical elements\nR plots are made up of points, lines, text and polygons (filled regions.) Graphical parameters exist which control how these graphical elements are drawn, as follows:\n\npch=\"+\"\n\nCharacter to be used for plotting points. The default varies with graphics drivers, but it is usually a circle. Plotted points tend to appear slightly above or below the appropriate position unless you use \".\" as the plotting character, which produces centered points.\n\npch=4\n\nWhen pch is given as an integer between 0 and 25 inclusive, a specialized plotting symbol is produced. To see what the symbols are, use the command\n> legend(locator(1), as.character(0:25), pch = 0:25)\nThose from 21 to 25 may appear to duplicate earlier symbols, but can be coloured in different ways: see the help on points and its examples.\nIn addition, pch can be a character or a number in the range 32:255 representing a character in the current font.\n\nlty=2\n\nLine types. Alternative line styles are not supported on all graphics devices (and vary on those that do) but line type 1 is always a solid line, line type 0 is always invisible, and line types 2 and onwards are dotted or dashed lines, or some combination of both.\n\nlwd=2\n\nLine widths. Desired width of lines, in multiples of the “standard” line width. Affects axis lines as well as lines drawn with lines(), etc. Not all devices support this, and some have restrictions on the widths that can be used.\n\ncol=2\n\nColors to be used for points, lines, text, filled regions and images. A number from the current palette (see ?palette) or a named colour.\n\n\ncol.axis\ncol.lab\ncol.main\ncol.sub\n: The color to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\nfont=2\n\nAn integer which specifies which font to use for text. If possible, device drivers arrange so that 1 corresponds to plain text, 2 to bold face, 3 to italic, 4 to bold italic and 5 to a symbol font (which include Greek letters).\n\n\nfont.axis\nfont.lab\nfont.main\nfont.sub\n: The font to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\nadj=-0.1\n\nJustification of text relative to the plotting position. 0 means left justify, 1 means right justify and 0.5 means to center horizontally about the plotting position. The actual value is the proportion of text that appears to the left of the plotting position, so a value of -0.1 leaves a gap of 10% of the text width between the text and the plotting position.\n\ncex=1.5\n\nCharacter expansion. The value is the desired size of text characters (including plotting characters) relative to the default text size.\n\n\ncex.axis\ncex.lab\ncex.main\ncex.sub\n: The character expansion to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\n\n12.5.2 Axes and tick marks\nMany of R’s high-level plots have axes, and you can construct axes yourself with the low-level axis() graphics function. Axes have three main components: the axis line (line style controlled by the lty graphics parameter), the tick marks (which mark off unit divisions along the axis line) and the tick labels (which mark the units.) These components can be customized with the following graphics parameters.\n\nlab=c(5, 7, 12)\n\nThe first two numbers are the desired number of tick intervals on the x and y axes respectively. The third number is the desired length of axis labels, in characters (including the decimal point.) Choosing a too-small value for this parameter may result in all tick labels being rounded to the same number!\n\nlas=1\n\nOrientation of axis labels. 0 means always parallel to axis, 1 means always horizontal, and 2 means always perpendicular to the axis.\n\nmgp=c(3, 1, 0)\n\nPositions of axis components. The first component is the distance from the axis label to the axis position, in text lines. The second component is the distance to the tick labels, and the final component is the distance from the axis position to the axis line (usually zero). Positive numbers measure outside the plot region, negative numbers inside.\n\ntck=0.01\n\nLength of tick marks, as a fraction of the size of the plotting region. When tck is small (less than 0.5) the tick marks on the x and y axes are forced to be the same size. A value of 1 gives grid lines. Negative values give tick marks outside the plotting region. Use tck=0.01 and mgp=c(1,-1.5,0) for internal tick marks.\n\n\nxaxs=\"r\"\nyaxs=\"i\"\n: Axis styles for the x and y axes, respectively. With styles \"i\" (internal) and \"r\" (the default) tick marks always fall within the range of the data, however style \"r\" leaves a small amount of space at the edges.\n\n\n12.5.3 Figure margins\nA single plot in R is known as a figure and comprises a plot region surrounded by margins (possibly containing axis labels, titles, etc.) and (usually) bounded by the axes themselves.\nA typical figure is\n\n\n\nimages/fig11\n\n\nGraphics parameters controlling figure layout include:\n\nmai=c(1, 0.5, 0.5, 0)\n\nWidths of the bottom, left, top and right margins, respectively, measured in inches.\n\nmar=c(4, 2, 2, 1)\n\nSimilar to mai, except the measurement unit is text lines.\n\n\nmar and mai are equivalent in the sense that setting one changes the value of the other. The default values chosen for this parameter are often too large; the right-hand margin is rarely needed, and neither is the top margin if no title is being used. The bottom and left margins must be large enough to accommodate the axis and tick labels. Furthermore, the default is chosen without regard to the size of the device surface: for example, using the postscript() driver with the height=4 argument will result in a plot which is about 50% margin unless mar or mai are set explicitly. When multiple figures are in use (see below) the margins are reduced, however this may not be enough when many figures share the same page.\n\n\n12.5.4 Multiple figure environment\nR allows you to create an n by m array of figures on a single page. Each figure has its own margins, and the array of figures is optionally surrounded by an outer margin, as shown in the following figure.\n\n\n\nimages/fig12\n\n\nThe graphical parameters relating to multiple figures are as follows:\nmfcol=c(3, 2)\nmfrow=c(2, 4)\n: Set the size of a multiple figure array. The first value is the number of rows; the second is the number of columns. The only difference between these two parameters is that setting mfcol causes figures to be filled by column; mfrow fills by rows.\nThe layout in the Figure could have been created by setting\n`mfrow=c(3,2)`; the figure shows the page after four plots have been\ndrawn.\n\nSetting either of these can reduce the base size of symbols and text\n(controlled by `par(\"cex\")` and the pointsize of the device). In a\nlayout with exactly two rows and columns the base size is reduced by\na factor of 0.83: if there are three or more of either rows or\ncolumns, the reduction factor is 0.66.\n\nmfg=c(2, 2, 3, 2)\n\nPosition of the current figure in a multiple figure environment. The first two numbers are the row and column of the current figure; the last two are the number of rows and columns in the multiple figure array. Set this parameter to jump between figures in the array. You can even use different values for the last two numbers than the true values for unequally-sized figures on the same page.\n\nfig=c(4, 9, 1, 4)/10\n\nPosition of the current figure on the page. Values are the positions of the left, right, bottom and top edges respectively, as a percentage of the page measured from the bottom left corner. The example value would be for a figure in the bottom right of the page. Set this parameter for arbitrary positioning of figures within a page. If you want to add a figure to a current page, use new=TRUE as well (unlike S).\n\n\noma=c(2, 0, 3, 0)\nomi=c(0, 0, 0.8, 0)\n: Size of outer margins. Like mar and mai, the first measures in text lines and the second in inches, starting with the bottom margin and working clockwise.\nOuter margins are particularly useful for page-wise titles, etc. Text can be added to the outer margins with the mtext() function with argument outer=TRUE. There are no outer margins by default, however, so you must create them explicitly using oma or omi.\nMore complicated arrangements of multiple figures can be produced by the split.screen() and layout() functions, as well as by the grid and lattice packages."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-device-drivers",
    "href": "content/R/r-manuals/test.html#sec-device-drivers",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.6 Device drivers",
    "text": "12.6 Device drivers\nR can generate graphics (of varying levels of quality) on almost any type of display or printing device. Before this can begin, however, R needs to be informed what type of device it is dealing with. This is done by starting a device driver. The purpose of a device driver is to convert graphical instructions from R (“draw a line,” for example) into a form that the particular device can understand.\nDevice drivers are started by calling a device driver function. There is one such function for every device driver: type help(Devices) for a list of them all. For example, issuing the command\n> postscript()\ncauses all future graphics output to be sent to the printer in PostScript format. Some commonly-used device drivers are:\n\nX11()\n\n\nFor use with the X11 window system on Unix-alikes\n\nwindows()\n\n\nFor use on Windows\n\nquartz()\n\n\nFor use on macOS\n\npostscript()\n\n\nFor printing on PostScript printers, or creating PostScript graphics files.\n\npdf()\n\n\nProduces a PDF file, which can also be included into PDF files.\n\npng()\n\n\nProduces a bitmap PNG file. (Not always available: see its help page.)\n\njpeg()\n\n\nProduces a bitmap JPEG file, best used for image plots. (Not always available: see its help page.)\n\n\nWhen you have finished with a device, be sure to terminate the device driver by issuing the command\n> dev.off()\nThis ensures that the device finishes cleanly; for example in the case of hardcopy devices this ensures that every page is completed and has been sent to the printer. (This will happen automatically at the normal end of a session.)\n\n12.6.1 PostScript diagrams for typeset documents\nBy passing the file argument to the postscript() device driver function, you may store the graphics in PostScript format in a file of your choice. The plot will be in landscape orientation unless the horizontal=FALSE argument is given, and you can control the size of the graphic with the width and height arguments (the plot will be scaled as appropriate to fit these dimensions.) For example, the command\n> postscript(\"file.ps\", horizontal=FALSE, height=5, pointsize=10)\nwill produce a file containing PostScript code for a figure five inches high, perhaps for inclusion in a document. It is important to note that if the file named in the command already exists, it will be overwritten. This is the case even if the file was only created earlier in the same R session.\nMany usages of PostScript output will be to incorporate the figure in another document. This works best when encapsulated PostScript is produced: R always produces conformant output, but only marks the output as such when the onefile=FALSE argument is supplied. This unusual notation stems from S-compatibility: it really means that the output will be a single page (which is part of the EPSF specification). Thus to produce a plot for inclusion use something like\n> postscript(\"plot1.eps\", horizontal=FALSE, onefile=FALSE,\n             height=8, width=6, pointsize=10)\n\n\n12.6.2 Multiple graphics devices\nIn advanced use of R it is often useful to have several graphics devices in use at the same time. Of course only one graphics device can accept graphics commands at any one time, and this is known as the current device. When multiple devices are open, they form a numbered sequence with names giving the kind of device at any position.\nThe main commands used for operating with multiple devices, and their meanings are as follows:\n\nX11()\n\n[UNIX]\n\n\nwindows()\nwin.printer()\nwin.metafile()\n: [Windows]\n\nquartz()\n\n[macOS]\n\n\npostscript()\npdf()\npng()\njpeg()\ntiff()\nbitmap()\n…\n: Each new call to a device driver function opens a new graphics device, thus extending by one the device list. This device becomes the current device, to which graphics output will be sent.\n\ndev.list()\n\n\nReturns the number and name of all active devices. The device at position 1 on the list is always the null device which does not accept graphics commands at all.\n\n\ndev.next()\ndev.prev()\n: \nReturns the number and name of the graphics device next to, or\nprevious to the current device, respectively.\n\ndev.set(which=``k)\n\n\nCan be used to change the current graphics device to the one at position k of the device list. Returns the number and label of the device.\n\ndev.off(``k)\n\n\nTerminate the graphics device at point k of the device list. For some devices, such as postscript devices, this will either print the file immediately or correctly complete the file for later printing, depending on how the device was initiated.\n\n\ndev.copy(device, …, which=``k)\ndev.print(device, …, which=``k)\n: Make a copy of the device k. Here device is a device function, such as postscript, with extra arguments, if needed, specified by ‘…’. dev.print is similar, but the copied device is immediately closed, so that end actions, such as printing hardcopies, are immediately performed.\n\ngraphics.off()\n\nTerminate all graphics devices on the list, except the null device."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-dynamic-graphics",
    "href": "content/R/r-manuals/test.html#sec-dynamic-graphics",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.7 Dynamic graphics",
    "text": "12.7 Dynamic graphics\nR does not have builtin capabilities for dynamic or interactive graphics, e.g. rotating point clouds or to “brushing” (interactively highlighting) points. However, extensive dynamic graphics facilities are available in the system GGobi by Swayne, Cook and Buja available from\n\nhttp://ggobi.org/\n\nand these can be accessed from R via the package rggobi, described at http://ggobi.org/rggobi.html.\nAlso, package rgl provides ways to interact with 3D plots, for example of surfaces."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-standard-packages",
    "href": "content/R/r-manuals/test.html#sec-standard-packages",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.1 Standard packages",
    "text": "13.1 Standard packages\nThe standard (or base) packages are considered part of the R source code. They contain the basic functions that allow R to work, and the datasets and standard statistical and graphical functions that are described in this manual. They should be automatically available in any R installation. See R packages in R FAQ, for a complete list."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-contributed-packages-and-cran",
    "href": "content/R/r-manuals/test.html#sec-contributed-packages-and-cran",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.2 Contributed packages and CRAN",
    "text": "13.2 Contributed packages and CRAN\nThere are thousands of contributed packages for R, written by many different authors. Some of these packages implement specialized statistical methods, others give access to data or hardware, and others are designed to complement textbooks. Some (the recommended packages) are distributed with every binary distribution of R. Most are available for download from CRAN (https://CRAN.R-project.org/ and its mirrors) and other repositories such as Bioconductor (https://www.bioconductor.org/). The R FAQ contains a list of CRAN packages current at the time of release, but the collection of available packages changes very frequently."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-namespaces",
    "href": "content/R/r-manuals/test.html#sec-namespaces",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.3 Namespaces",
    "text": "13.3 Namespaces\nPackages have namespaces, which do three things: they allow the package writer to hide functions and data that are meant only for internal use, they prevent functions from breaking when a user (or other package writer) picks a name that clashes with one in the package, and they provide a way to refer to an object within a particular package.\nFor example, t() is the transpose function in R, but users might define their own function named t. Namespaces prevent the user’s definition from taking precedence, and breaking every function that tries to transpose a matrix.\nThere are two operators that work with namespaces. The double-colon operator :: selects definitions from a particular namespace. In the example above, the transpose function will always be available as base::t, because it is defined in the base package. Only functions that are exported from the package can be retrieved in this way.\nThe triple-colon operator ::: may be seen in a few places in R code: it acts like the double-colon operator but also allows access to hidden objects. Users are more likely to use the getAnywhere() function, which searches multiple packages.\nPackages are often inter-dependent, and loading one may cause others to be automatically loaded. The colon operators described above will also cause automatic loading of the associated package. When packages with namespaces are loaded automatically they are not added to the search list."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-files-and-directories",
    "href": "content/R/r-manuals/test.html#sec-files-and-directories",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.1 Files and directories",
    "text": "14.1 Files and directories\nThere are many functions to manipulate files and directories. Here are pointers to some of the more commonly used ones.\nTo create an (empty) file or directory, use file.create or dir.create. (These are the analogues of the POSIX utilities touch and mkdir.) For temporary files and directories in the R session directory see tempfile.\nFiles can be removed by either file.remove or unlink: the latter can remove directory trees.\nFor directory listings use list.files (also available as dir) or list.dirs. These can select files using a regular expression: to select by wildcards use Sys.glob.\nMany types of information on a filepath (including for example if it is a file or directory) can be found by file.info.\nThere are several ways to find out if a file ‘exists’ (a file can exist on the filesystem and not be visible to the current user). There are functions file.exists, file.access and file_test with various versions of this test: file_test is a version of the POSIX test command for those familiar with shell scripting.\nFunction file.copy is the R analogue of the POSIX command cp.\nChoosing files can be done interactively by file.choose: the Windows port has the more versatile functions choose.files and choose.dir and there are similar functions in the tcltk package: tk_choose.files and tk_choose.dir.\nFunctions file.show and file.edit will display and edit one or more files in a way appropriate to the R port, using the facilities of a console (such as RGui on Windows or R.app on macOS) if one is in use.\nThere is some support for links in the filesystem: see functions file.link and Sys.readlink."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-filepaths",
    "href": "content/R/r-manuals/test.html#sec-filepaths",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.2 Filepaths",
    "text": "14.2 Filepaths\nWith a few exceptions, R relies on the underlying OS functions to manipulate filepaths. Some aspects of this are allowed to depend on the OS, and do, even down to the version of the OS. There are POSIX standards for how OSes should interpret filepaths and many R users assume POSIX compliance: but Windows does not claim to be compliant and other OSes may be less than completely compliant.\nThe following are some issues which have been encountered with filepaths.\n\nPOSIX filesystems are case-sensitive, so foo.png and Foo.PNG are different files. However, the defaults on Windows and macOS are to be case-insensitive, and FAT filesystems (commonly used on removable storage) are not normally case-sensitive (and all filepaths may be mapped to lower case).\nAlmost all the Windows’ OS services support the use of slash or backslash as the filepath separator, and R converts the known exceptions to the form required by Windows.\nThe behaviour of filepaths with a trailing slash is OS-dependent. Such paths are not valid on Windows and should not be expected to work. POSIX-2008 requires such paths to match only directories, but earlier versions allowed them to also match files. So they are best avoided.\nMultiple slashes in filepaths such as /abc//def are valid on POSIX filesystems and treated as if there was only one slash. They are usually accepted by Windows’ OS functions. However, leading double slashes may have a different meaning.\nWindows’ UNC filepaths (such as \\\\server\\dir1\\dir2\\file and \\\\?\\UNC\\server\\dir1\\dir2\\file) are not supported, but they may work in some R functions. POSIX filesystems are allowed to treat a leading double slash specially.\nWindows allows filepaths containing drives and relative to the current directory on a drive, e.g. d:foo/bar refers to d:/a/b/c/foo/bar if the current directory on drive d: is /a/b/c. It is intended that these work, but the use of absolute paths is safer.\n\nFunctions basename and dirname select parts of a file path: the recommended way to assemble a file path from components is file.path. Function pathexpand does ‘tilde expansion’, substituting values for home directories (the current user’s, and perhaps those of other users).\nOn filesystems with links, a single file can be referred to by many filepaths. Function normalizePath will find a canonical filepath.\nWindows has the concepts of short (‘8.3’) and long file names: normalizePath will return an absolute path using long file names and shortPathName will return a version using short names. The latter does not contain spaces and uses backslash as the separator, so is sometimes useful for exporting names from R.\nFile permissions are a related topic. R has support for the POSIX concepts of read/write/execute permission for owner/group/all but this may be only partially supported on the filesystem, so for example on Windows only read-only files (for the account running the R session) are recognized. Access Control Lists (ACLs) are employed on several filesystems, but do not have an agreed standard and R has no facilities to control them. Use Sys.chmod to change permissions."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-system-commands",
    "href": "content/R/r-manuals/test.html#sec-system-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.3 System commands",
    "text": "14.3 System commands\nFunctions system and system2 are used to invoke a system command and optionally collect its output. system2 is a little more general but its main advantage is that it is easier to write cross-platform code using it.\nsystem behaves differently on Windows from other OSes (because the API C call of that name does). Elsewhere it invokes a shell to run the command: the Windows port of R has a function shell to do that.\nTo find out if the OS includes a command, use Sys.which, which attempts to do this in a cross-platform way (unfortunately it is not a standard OS service).\nFunction shQuote will quote filepaths as needed for commands in the current OS."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-compression-and-archives",
    "href": "content/R/r-manuals/test.html#sec-compression-and-archives",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.4 Compression and Archives",
    "text": "14.4 Compression and Archives\nRecent versions of R have extensive facilities to read and write compressed files, often transparently. Reading of files in R is to a very large extent done by connections, and the file function which is used to open a connection to a file (or a URL) and is able to identify the compression used from the ‘magic’ header of the file.\nThe type of compression which has been supported for longest is gzip compression, and that remains a good general compromise. Files compressed by the earlier Unix compress utility can also be read, but these are becoming rare. Two other forms of compression, those of the bzip2 and xz utilities are also available. These generally achieve higher rates of compression (depending on the file, much higher) at the expense of slower decompression and much slower compression.\nThere is some confusion between xz and lzma compression (see https://en.wikipedia.org/wiki/Xz and https://en.wikipedia.org/wiki/LZMA): R can read files compressed by most versions of either.\nFile archives are single files which contain a collection of files, the most common ones being ‘tarballs’ and zip files as used to distribute R packages. R can list and unpack both (see functions untar and unzip) and create both (for zip with the help of an external program)."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-b.1-invoking-r-from-the-command-line",
    "href": "content/R/r-manuals/test.html#sec-b.1-invoking-r-from-the-command-line",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.5 B.1 Invoking R from the command line",
    "text": "14.5 B.1 Invoking R from the command line\nWhen working at a command line on UNIX or Windows, the command ‘R’ can be used both for starting the main R program in the form\n\nR [options] [<infile] [>outfile],\n\nor, via the R CMD interface, as a wrapper to various R tools (e.g., for processing files in R documentation format or manipulating add-on packages) which are not intended to be called “directly”.\nAt the Windows command-line, Rterm.exe is preferred to R.\nYou need to ensure that either the environment variable TMPDIR is unset or it points to a valid place to create temporary files and directories.\nMost options control what happens at the beginning and at the end of an R session. The startup mechanism is as follows (see also the on-line help for topic ‘Startup’ for more information, and the section below for some Windows-specific details).\n\nUnless --no-environ was given, R searches for user and site files to process for setting environment variables. The name of the site file is the one pointed to by the environment variable R_ENVIRON; if this is unset, R_HOME/etc/Renviron.site is used (if it exists). The user file is the one pointed to by the environment variable R_ENVIRON_USER if this is set; otherwise, files .Renviron in the current or in the user’s home directory (in that order) are searched for. These files should contain lines of the form ‘name=``value’. (See help(\"Startup\") for a precise description.) Variables you might want to set include R_PAPERSIZE (the default paper size), R_PRINTCMD (the default print command) and R_LIBS (specifies the list of R library trees searched for add-on packages).\nThen R searches for the site-wide startup profile unless the command line option --no-site-file was given. The name of this file is taken from the value of the R_PROFILE environment variable. If that variable is unset, the default R_HOME/etc/Rprofile.site is used if this exists.\nThen, unless --no-init-file was given, R searches for a user profile and sources it. The name of this file is taken from the environment variable R_PROFILE_USER; if unset, a file called .Rprofile in the current directory or in the user’s home directory (in that order) is searched for.\nIt also loads a saved workspace from file .RData in the current directory if there is one (unless --no-restore or --no-restore-data was specified).\nFinally, if a function .First() exists, it is executed. This function (as well as .Last() which is executed at the end of the R session) can be defined in the appropriate startup profiles, or reside in .RData.\n\nIn addition, there are options for controlling the memory available to the R process (see the on-line help for topic ‘Memory’ for more information). Users will not normally need to use these unless they are trying to limit the amount of memory used by R.\nR accepts the following command-line options.\n--help\n-h\n: Print short help message to standard output and exit successfully.\n\n--version\n\nPrint version information to standard output and exit successfully.\n\n--encoding=``enc\n\nSpecify the encoding to be assumed for input from the console or stdin. This needs to be an encoding known to iconv: see its help page. (--encoding ``enc is also accepted.) The input is re-encoded to the locale R is running in and needs to be representable in the latter’s encoding (so e.g. you cannot re-encode Greek text in a French locale unless that locale uses the UTF-8 encoding).\n\nRHOME\n\nPrint the path to the R “home directory” to standard output and exit successfully. Apart from the front-end shell script and the man page, R installation puts everything (executables, packages, etc.) into this directory.\n\n\n--save\n--no-save\n: Control whether data sets should be saved or not at the end of the R session. If neither is given in an interactive session, the user is asked for the desired behavior when ending the session with q(); in non-interactive use one of these must be specified or implied by some other option (see below).\n\n--no-environ\n\nDo not read any user file to set environment variables.\n\n--no-site-file\n\nDo not read the site-wide profile at startup.\n\n--no-init-file\n\nDo not read the user’s profile at startup.\n\n\n--restore\n--no-restore\n--no-restore-data\n: Control whether saved images (file .RData in the directory where R was started) should be restored at startup or not. The default is to restore. (--no-restore implies all the specific --no-restore-* options.)\n\n--no-restore-history\n\nControl whether the history file (normally file .Rhistory in the directory where R was started, but can be set by the environment variable R_HISTFILE) should be restored at startup or not. The default is to restore.\n\n--no-Rconsole\n\n(Windows only) Prevent loading the Rconsole file at startup.\n\n--vanilla\n\nCombine --no-save, --no-environ, --no-site-file, --no-init-file and --no-restore. Under Windows, this also includes --no-Rconsole.\n\n\n-f ``file\n--file=``file\n: (not Rgui.exe) Take input from file: ‘-’ means stdin. Implies --no-save unless --save has been set. On a Unix-alike, shell metacharacters should be avoided in file (but spaces are allowed).\n\n-e ``expression\n\n(not Rgui.exe) Use expression as an input line. One or more -e options can be used, but not together with -f or --file. Implies --no-save unless --save has been set. (There is a limit of 10,000 bytes on the total length of expressions used in this way. Expressions containing spaces or shell metacharacters will need to be quoted.)\n\n--no-readline\n\n(UNIX only) Turn off command-line editing via readline. This is useful when running R from within Emacs using the ESS (“Emacs Speaks Statistics”) package. See Section 17 , for more information. Command-line editing is enabled for default interactive use (see --interactive). This option also affects tilde-expansion: see the help for path.expand.\n\n\n--min-vsize=``N\n--min-nsize=``N\n: For expert use only: set the initial trigger sizes for garbage collection of vector heap (in bytes) and cons cells (number) respectively. Suffix ‘M’ specifies megabytes or millions of cells respectively. The defaults are 6Mb and 350k respectively and can also be set by environment variables R_NSIZE and R_VSIZE.\n\n--max-ppsize=``N\n\nSpecify the maximum size of the pointer protection stack as N locations. This defaults to 10000, but can be increased to allow large and complicated calculations to be done. Currently the maximum value accepted is 100000.\n\n\n--quiet\n--silent\n-q\n: Do not print out the initial copyright and welcome messages.\n\n--no-echo\n\nMake R run as quietly as possible. This option is intended to support programs which use R to compute results for them. It implies --quiet and --no-save.\n\n--interactive\n\n(UNIX only) Assert that R really is being run interactively even if input has been redirected: use if input is from a FIFO or pipe and fed from an interactive program. (The default is to deduce that R is being run interactively if and only if stdin is connected to a terminal or pty.) Using -e, -f or --file asserts non-interactive use even if --interactive is given.\nNote that this does not turn on command-line editing.\n\n--ess\n\n(Windows only) Set Rterm up for use by R-inferior-mode in ESS, including asserting interactive use (without the command-line editor) and no buffering of stdout.\n\n--verbose\n\nPrint more information about progress, and in particular set R’s option verbose to TRUE. R code uses this option to control the printing of diagnostic messages.\n\n\n--debugger=``name\n-d ``name\n: (UNIX only) Run R through debugger name. For most debuggers (the exceptions are valgrind and recent versions of gdb), further command line options are disregarded, and should instead be given when starting the R executable from inside the debugger.\n--gui=``type\n-g ``type\n: (UNIX only) Use type as graphical user interface (note that this also includes interactive graphics). Currently, possible values for type are ‘X11’ (the default) and, provided that ‘Tcl/Tk’ support is available, ‘Tk’. (For back-compatibility, ‘x11’ and ‘tk’ are accepted.)\n\n--arch=``name\n\n(UNIX only) Run the specified sub-architecture.\n\n--args\n\nThis flag does nothing except cause the rest of the command line to be skipped: this can be useful to retrieve values from it with commandArgs(TRUE).\n\n\nNote that input and output can be redirected in the usual way (using ‘<’ and ‘>’), but the line length limit of 4095 bytes still applies. Warning and error messages are sent to the error channel (stderr).\nThe command R CMD allows the invocation of various tools which are useful in conjunction with R, but not intended to be called “directly”. The general form is\nR CMD command args\nwhere command is the name of the tool and args the arguments passed on to it.\nCurrently, the following tools are available.\n\nBATCH\n\nRun R in batch mode. Runs R --restore --save with possibly further options (see ?BATCH).\n\nCOMPILE\n\n(UNIX only) Compile C, C++, Fortran … files for use with R.\n\nSHLIB\n\nBuild shared library for dynamic loading.\n\nINSTALL\n\nInstall add-on packages.\n\nREMOVE\n\nRemove add-on packages.\n\nbuild\n\nBuild (that is, package) add-on packages.\n\ncheck\n\nCheck add-on packages.\n\nLINK\n\n(UNIX only) Front-end for creating executable programs.\n\nRprof\n\nPost-process R profiling files.\n\n\nRdconv\nRd2txt\n: Convert Rd format to various other formats, including HTML, LaTeX, plain text, and extracting the examples. Rd2txt can be used as shorthand for Rd2conv -t txt.\n\nRd2pdf\n\nConvert Rd format to PDF.\n\nStangle\n\nExtract S/R code from Sweave or other vignette documentation\n\nSweave\n\nProcess Sweave or other vignette documentation\n\nRdiff\n\nDiff R output ignoring headers etc\n\nconfig\n\nObtain configuration information\n\njavareconf\n\n(Unix only) Update the Java configuration variables\n\nrtags\n\n(Unix only) Create Emacs-style tag files from C, R, and Rd files\n\nopen\n\n(Windows only) Open a file via Windows’ file associations\n\ntexify\n\n(Windows only) Process (La)TeX files with R’s style files\n\n\nUse\nR CMD command --help\nto obtain usage information for each of the tools accessible via the R CMD interface.\nIn addition, you can use options --arch=, --no-environ, --no-init-file, --no-site-file and --vanilla between R and CMD: these affect any R processes run by the tools. (Here --vanilla is equivalent to --no-environ --no-site-file --no-init-file.) However, note that R CMD does not of itself use any R startup files (in particular, neither user nor site Renviron files), and all of the R processes run by these tools (except BATCH) use --no-restore. Most use --vanilla and so invoke no R startup files: the current exceptions are INSTALL, REMOVE, Sweave and SHLIB (which uses --no-site-file --no-init-file).\nR CMD cmd args\nfor any other executable cmd on the path or given by an absolute filepath: this is useful to have the same environment as R or the specific commands run under, for example to run ldd or pdflatex. Under Windows cmd can be an executable or a batch file, or if it has extension .sh or .pl the appropriate interpreter (if available) is called to run it."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-b.2-invoking-r-under-windows",
    "href": "content/R/r-manuals/test.html#sec-b.2-invoking-r-under-windows",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.6 B.2 Invoking R under Windows",
    "text": "14.6 B.2 Invoking R under Windows\nThere are two ways to run R under Windows. Within a terminal window (e.g. cmd.exe or a more capable shell), the methods described in the previous section may be used, invoking by R.exe or more directly by Rterm.exe. For interactive use, there is a console-based GUI (Rgui.exe).\nThe startup procedure under Windows is very similar to that under UNIX, but references to the ‘home directory’ need to be clarified, as this is not always defined on Windows. If the environment variable R_USER is defined, that gives the home directory. Next, if the environment variable HOME is defined, that gives the home directory. After those two user-controllable settings, R tries to find system defined home directories. It first tries to use the Windows \"personal\" directory (typically My Documents in recent versions of Windows). If that fails, and environment variables HOMEDRIVE and HOMEPATH are defined (and they normally are) these define the home directory. Failing all those, the home directory is taken to be the starting directory.\nYou need to ensure that either the environment variables TMPDIR, TMP and TEMP are either unset or one of them points to a valid place to create temporary files and directories.\nEnvironment variables can be supplied as ‘name=``value’ pairs on the command line.\nIf there is an argument ending .RData (in any case) it is interpreted as the path to the workspace to be restored: it implies --restore and sets the working directory to the parent of the named file. (This mechanism is used for drag-and-drop and file association with RGui.exe, but also works for Rterm.exe. If the named file does not exist it sets the working directory if the parent directory exists.)\nThe following additional command-line options are available when invoking RGui.exe.\n--mdi\n--sdi\n--no-mdi\n: Control whether Rgui will operate as an MDI program (with multiple child windows within one main window) or an SDI application (with multiple top-level windows for the console, graphics and pager). The command-line setting overrides the setting in the user’s Rconsole file.\n\n--debug\n\nEnable the “Break to debugger” menu item in Rgui, and trigger a break to the debugger during command line processing.\n\n\nUnder Windows with R CMD you may also specify your own .bat, .exe, .sh or .pl file. It will be run under the appropriate interpreter (Perl for .pl) with several environment variables set appropriately, including R_HOME, R_OSTYPE, PATH, BSTINPUTS and TEXINPUTS. For example, if you already have latex.exe on your path, then\nR CMD latex.exe mydoc\nwill run LaTeX on mydoc.tex, with the path to R’s share/texmf macros appended to TEXINPUTS. (Unfortunately, this does not help with the MiKTeX build of LaTeX, but R CMD texify mydoc will work in that case.)"
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-b.3-invoking-r-under-macos",
    "href": "content/R/r-manuals/test.html#sec-b.3-invoking-r-under-macos",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.7 B.3 Invoking R under macOS",
    "text": "14.7 B.3 Invoking R under macOS\nThere are two ways to run R under macOS. Within a Terminal.app window by invoking R, the methods described in the first subsection apply. There is also console-based GUI (R.app) that by default is installed in the Applications folder on your system. It is a standard double-clickable macOS application.\nThe startup procedure under macOS is very similar to that under UNIX, but R.app does not make use of command-line arguments. The ‘home directory’ is the one inside the R.framework, but the startup and current working directory are set as the user’s home directory unless a different startup directory is given in the Preferences window accessible from within the GUI."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-b.4-scripting-with-r",
    "href": "content/R/r-manuals/test.html#sec-b.4-scripting-with-r",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.8 B.4 Scripting with R",
    "text": "14.8 B.4 Scripting with R\nIf you just want to run a file foo.R of R commands, the recommended way is to use R CMD BATCH foo.R. If you want to run this in the background or as a batch job use OS-specific facilities to do so: for example in most shells on Unix-alike OSes R CMD BATCH foo.R & runs a background job.\nYou can pass parameters to scripts via additional arguments on the command line: for example (where the exact quoting needed will depend on the shell in use)\nR CMD BATCH \"--args arg1 arg2\" foo.R &\nwill pass arguments to a script which can be retrieved as a character vector by\nargs <- commandArgs(TRUE)\nThis is made simpler by the alternative front-end Rscript, which can be invoked by\nRscript foo.R arg1 arg2\nand this can also be used to write executable script files like (at least on Unix-alikes, and in some Windows shells)\n#! /path/to/Rscript\nargs <- commandArgs(TRUE)\n...\nq(status=<exit status code>)\nIf this is entered into a text file runfoo and this is made executable (by chmod 755 runfoo), it can be invoked for different arguments by\nrunfoo arg1 arg2\nFor further options see help(\"Rscript\"). This writes R output to stdout and stderr, and this can be redirected in the usual way for the shell running the command.\nIf you do not wish to hardcode the path to Rscript but have it in your path (which is normally the case for an installed R except on Windows, but e.g. macOS users may need to add /usr/local/bin to their path), use\n#! /usr/bin/env Rscript\n...\nAt least in Bourne and bash shells, the #! mechanism does not allow extra arguments like #! /usr/bin/env Rscript --vanilla.\nOne thing to consider is what stdin() refers to. It is commonplace to write R scripts with segments like\nchem <- scan(n=24)\n2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20\n5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70\nand stdin() refers to the script file to allow such traditional usage. If you want to refer to the process’s stdin, use \"stdin\" as a file connection, e.g. scan(\"stdin\", ...).\nAnother way to write executable script files (suggested by François Pinard) is to use a here document like\n#!/bin/sh\n[environment variables can be set here]\nR --no-echo [other options] <<EOF\n\n   R program goes here...\n\nEOF\nbut here stdin() refers to the program source and \"stdin\" will not be usable.\nShort scripts can be passed to Rscript on the command-line via the -e flag. (Empty scripts are not accepted.)\nNote that on a Unix-alike the input filename (such as foo.R) should not contain spaces nor shell metacharacters."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-c.1-preliminaries",
    "href": "content/R/r-manuals/test.html#sec-c.1-preliminaries",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.1 Preliminaries",
    "text": "17.1 Preliminaries\nWhen the GNU readline library is available at the time R is configured for compilation under UNIX, an inbuilt command line editor allowing recall, editing and re-submission of prior commands is used. Note that other versions of readline exist and may be used by the inbuilt command line editor: this is most common on macOS. You can find out which version (if any) is available by running extSoftVersion() in an R session.\nIt can be disabled (useful for usage with ESS 25) using the startup option --no-readline.\nWindows versions of R have somewhat simpler command-line editing: see ‘Console’ under the ‘Help’ menu of the GUI, and the file README.Rterm for command-line editing under Rterm.exe.\nWhen using R with GNU26 readline capabilities, the functions described below are available, as well as others (probably) documented in man readline or info readline on your system.\nMany of these use either Control or Meta characters. Control characters, such as Control-m, are obtained by holding the CTRL down while you press the m key, and are written as C-m below. Meta characters, such as Meta-b, are typed by holding down META27 and pressing b, and written as M-b in the following. If your terminal does not have a META key enabled, you can still type Meta characters using two-character sequences starting with ESC. Thus, to enter M-b, you could type ESCb. The ESC character sequences are also allowed on terminals with real Meta keys. Note that case is significant for Meta characters.\nSome but not all versions28 of readline will recognize resizing of the terminal window so this is best avoided."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-c.2-editing-actions",
    "href": "content/R/r-manuals/test.html#sec-c.2-editing-actions",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.2 Editing actions",
    "text": "17.2 Editing actions\nThe R program keeps a history of the command lines you type, including the erroneous lines, and commands in your history may be recalled, changed if necessary, and re-submitted as new commands. In Emacs-style command-line editing any straight typing you do while in this editing phase causes the characters to be inserted in the command you are editing, displacing any characters to the right of the cursor. In vi mode character insertion mode is started by M-i or M-a, characters are typed and insertion mode is finished by typing a further ESC. (The default is Emacs-style, and only that is described here: for vi mode see the readline documentation.)\nPressing the RET command at any time causes the command to be re-submitted.\nOther editing actions are summarized in the following table."
  },
  {
    "objectID": "content/R/r-manuals/test.html#sec-c.3-command-line-editor-summary",
    "href": "content/R/r-manuals/test.html#sec-c.3-command-line-editor-summary",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.3 Command-line editor summary",
    "text": "17.3 Command-line editor summary\n\n17.3.1 Command recall and vertical motion\n\nC-p\n\nGo to the previous command (backwards in the history).\n\nC-n\n\nGo to the next command (forwards in the history).\n\nC-r text\n\nFind the last command with the text string in it. This can be cancelled by C-g (and on some versions of R by C-c).\n\n\nOn most terminals, you can also use the up and down arrow keys instead of C-p and C-n, respectively.\n\n\n17.3.2 Horizontal motion of the cursor\n\nC-a\n\nGo to the beginning of the command.\n\nC-e\n\nGo to the end of the line.\n\nM-b\n\nGo back one word.\n\nM-f\n\nGo forward one word.\n\nC-b\n\nGo back one character.\n\nC-f\n\nGo forward one character.\n\n\nOn most terminals, you can also use the left and right arrow keys instead of C-b and C-f, respectively.\n\n\n17.3.3 Editing and re-submission\n\ntext\n\nInsert text at the cursor.\n\nC-f text\n\nAppend text after the cursor.\n\nDEL\n\nDelete the previous character (left of the cursor).\n\nC-d\n\nDelete the character under the cursor.\n\nM-d\n\nDelete the rest of the word under the cursor, and “save” it.\n\nC-k\n\nDelete from cursor to end of command, and “save” it.\n\nC-y\n\nInsert (yank) the last “saved” text here.\n\nC-t\n\nTranspose the character under the cursor with the next.\n\nM-l\n\nChange the rest of the word to lower case.\n\nM-c\n\nChange the rest of the word to upper case.\n\nRET\n\nRe-submit the command to R.\n\n\nThe final RET terminates the command line editing sequence.\nThe readline key bindings can be customized in the usual way via a ~/.inputrc file. These customizations can be conditioned on application R, that is by including a section like\n$if R\n  \"\\C-xd\": \"q('no')\\n\"\n$endif"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html",
    "href": "content/R/topics/01_basics/01_programming_beginner.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Short Description\nMaster the basics of data analysis by manipulating common data structures such as vectors, matrices, and data frames.\nLong Description\nIn Introduction to R, you will master the basics of this widely used open source language, including factors, lists, and data frames. With the knowledge gained in this course, you will be ready to undertake your first very own data analysis. Oracle estimated over 2 million R users worldwide in 2012, cementing R as a leading programming language in statistics and data science. Every year, the number of R users grows by about 40%, and an increasing number of organizations are using it in their day-to-day activities. Begin your journey to learn R with us today!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#how-it-works",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#how-it-works",
    "title": "Introduction to R",
    "section": "How it works",
    "text": "How it works\nIn the editor on the right you should type R code to solve the exercises. When you hit the ‘Submit Answer’ button, every line of code is interpreted and executed by R and you get a message whether or not your code was correct. The output of your R code is shown in the console in the lower right corner.\nR makes use of the # sign to add comments, so that you and others can understand what the R code is about. Just like Twitter! Comments are not run as R code, so they will not influence your result. For example, Calculate 3 + 4 in the editor on the right is a comment.\nYou can also execute R commands straight in the console. This is a good way to experiment with R code, as your submission is not checked for correctness.\nSteps\n\nIn the editor on the right there is already some sample code. Can you see which lines are actual R code and which are comments?\nAdd a line of code that calculates the sum of 6 and 12, and hit the ‘Submit Answer’ button.\n\n\n## Sample: Calculate 3 + 4\n3 + 4\n#> [1] 7\n\n## Instruction: Calculate 6 + 12\n6 + 12\n#> [1] 18\n\nCreated on 2022-01-17 by the reprex package (v2.0.1)\nAwesome! See how the console shows the result of the R code you submitted? Now that you’re familiar with the interface, let’s get down to R business!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#arithmetic-with-r",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#arithmetic-with-r",
    "title": "Introduction to R",
    "section": "Arithmetic with R",
    "text": "Arithmetic with R\nIn its most basic form, R can be used as a simple calculator. Consider the following arithmetic operators:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nExponentiation: ^\nModulo: %%\n\nThe last two might need some explaining:\n\nThe ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9.\nThe modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.\n\nWith this knowledge, follow the instructions to complete the exercise.\nSteps\n\nType 2^5 in the editor to calculate 2 to the power 5.\nType 28 %% 6 to calculate 28 modulo 6.\nSubmit the answer and have a look at the R output in the console.\nNote how the # symbol is used to add comments on the R code.\n\n\n## An addition\n5 + 5 \n#> [1] 10\n\n## A subtraction\n5 - 5 \n#> [1] 0\n\n## A multiplication\n3 * 5\n#> [1] 15\n\n## A division\n(5 + 5) / 2 \n#> [1] 5\n\n## Exponentiation\n2^5\n#> [1] 32\n\n## Modulo\n28%%6\n#> [1] 4\n\nCreated on 2022-01-17 by the reprex package (v2.0.1)"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment",
    "title": "Introduction to R",
    "section": "Variable assignment",
    "text": "Variable assignment\nA basic concept in (statistical) programming is called a variable.\nA variable allows you to store a value (e.g. 4) or an object (e.g. a function description) in R. You can then later use this variable’s name to easily access the value or the object that is stored within this variable.\nYou can assign a value 4 to a variable my_var with the command\nSteps\n\nOver to you: complete the code in the editor such that it assigns the value 42 to the variable x in the editor. Submit the answer. Notice that when you ask R to print x, the value 42 appears.\n\n\n## Assign the value 42 to x\nx <- 42\n\n## Print out the value of the variable x\nx\n#> [1] 42\n\nCreated on 2022-01-17 by the reprex package (v2.0.1)\nGood job! Have you noticed that R does not print the value of a variable to the console when you did the assignment? x <- 42 did not generate any output, because R assumes that you will be needing this variable in the future. Otherwise you wouldn’t have stored the value in a variable in the first place, right? Proceed to the next exercise!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment-2",
    "title": "Introduction to R",
    "section": "Variable assignment (2)",
    "text": "Variable assignment (2)\nSuppose you have a fruit basket with five apples. As a data analyst in training, you want to store the number of apples in a variable with the name my_apples.\nSteps\n\nType the following code in the editor: `my_apples \nType: my_apples below the second comment. This will print out the value of my_apples.\nSubmit your answer, and look at the output: you see that the number 5 is printed. So R now links the variable my_apples to the value 5.\n\n\n## Assign the value 5 to the variable my_apples\nmy_apples <- 5\n\n## Print out the value of the variable my_apples\nmy_apples\n#> [1] 5\n\nCreated on 2022-01-17 by the reprex package (v2.0.1)"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment-3",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#variable-assignment-3",
    "title": "Introduction to R",
    "section": "Variable assignment (3)",
    "text": "Variable assignment (3)\nEvery tasty fruit basket needs oranges, so you decide to add six oranges. As a data analyst, your reflex is to immediately create the variable my_oranges and assign the value 6 to it. Next, you want to calculate how many pieces of fruit you have in total. Since you have given meaningful names to these values, you can now code this in a clear way: \nSteps\n\nAssign to my_oranges the value 6.\nAdd the variables my_apples and my_oranges and have R simply print the result.\nAssign the result of adding my_apples and my_oranges to a new variable my_fruit.\n\n\n## Assign a value to the variables my_apples and my_oranges\nmy_apples  <- 5\nmy_oranges <- 6\n\n## Add these two variables together\nmy_apples + my_oranges\n\n## Create the variable my_fruit\nmy_fruit <- my_apples + my_oranges\n\nNice one! The great advantage of doing calculations with variables is reusability. If you just change my_apples to equal 12 instead of 5 and rerun the script, my_fruit will automatically update as well. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#apples-and-oranges",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#apples-and-oranges",
    "title": "Introduction to R",
    "section": "Apples and oranges",
    "text": "Apples and oranges\nCommon knowledge tells you not to add apples and oranges. But hey, that is what you just did, no :-)? The my_apples and my_oranges variables both contained a number in the previous exercise. The + operator works with numeric variables in R. If you really tried to add “apples” and “oranges”, and assigned a text value to the variable my_oranges (see the editor), you would be trying to assign the addition of a numeric and a character variable to the variable my_fruit. This is not possible.\nSteps\n\nSubmit the answer and read the error message. Make sure to understand why this did not work.\nAdjust the code so that R knows you have 6 oranges and thus a fruit basket with 11 pieces of fruit.\n\n\n## Assign a value to the variable my_apples\nmy_apples  <- 5 \n\n## Fix the assignment of my_oranges\nmy_oranges <- 6\n\n## Create the variable my_fruit and print it out\nmy_fruit <- my_apples + my_oranges \nmy_fruit\n\n[1] 11"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#basic-data-types-in-r",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#basic-data-types-in-r",
    "title": "Introduction to R",
    "section": "Basic data types in R",
    "text": "Basic data types in R\nR works with numerous data types. Some of the most basic types to get started are:\n\nDecimal values like 4.5 are called numerics.\nWhole numbers like 4 are called integers. Integers are also numerics.\nBoolean values (TRUE or FALSE) are called logical.\nText (or string) values are called characters.\n\nNote how the quotation marks in the editor indicate that \"some text\" is a string.\nSteps\n\nChange the value of the:\n\nmy_numeric variable to 42.\nmy_character variable to \"universe\". Note that the quotation marks indicate that \"universe\" is a character.\nmy_logical variable to FALSE.\n\n\nNote that R is case sensitive!\n\n## Change my_numeric to be 42\nmy_numeric   <- 42\n\n## Change my_character to be \"universe\"\nmy_character <- \"universe\"\n\n## Change my_logical to be FALSE\nmy_logical   <- FALSE"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-that-data-type",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-that-data-type",
    "title": "Introduction to R",
    "section": "What’s that data type?",
    "text": "What’s that data type?\nDo you remember that when you added 5 + \"six\", you got an error due to a mismatch in data types? You can avoid such embarrassing situations by checking the data type of a variable beforehand. You can do this with the class() function, as the code in the editor shows.\nSteps\n\nComplete the code in the editor and also print out the classes of my_character and my_logical.\n\n\n## Declare variables of different types\nmy_numeric   <- 42\nmy_character <- \"universe\"\nmy_logical   <- FALSE \n\n## Check class of my_numeric\nclass(my_numeric)\n#> [1] \"numeric\"\n\n## Check class of my_character\nclass(my_character)\n#> [1] \"character\"\n\n## Check class of my_logical\nclass(my_logical)\n#> [1] \"logical\"\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector",
    "title": "Introduction to R",
    "section": "Create a vector",
    "text": "Create a vector\nFeeling lucky? You better, because this chapter takes you on a trip to the City of Sins, also known as Statisticians Paradise!\nThanks to R and your new data-analytical skills, you will learn how to uplift your performance at the tables and fire off your career as a professional gambler. This chapter will show how you can easily keep track of your betting progress and how you can do some simple analyses on past actions. Next stop, Vegas Baby… VEGAS!!\nSteps\n\nDo you still remember what you have learned in the first chapter? Assign the value \"Go!\" to the variable vegas. Remember: R is case sensitive!\n\n\n## Define the variable vegas\nvegas <- \"Go!\""
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector-2",
    "title": "Introduction to R",
    "section": "Create a vector (2)",
    "text": "Create a vector (2)\nLet us focus first!\nOn your way from rags to riches, you will make extensive use of vectors. Vectors are one-dimension arrays that can hold numeric data, character data, or logical data. In other words, a vector is a simple tool to store data. For example, you can store your daily gains and losses in the casinos.\nIn R, you create a vector with the combine function c(). You place the vector elements separated by a comma between the parentheses. For example:\n\nnumeric_vector   <- c(1, 2, 3)\ncharacter_vector <- c(\"a\", \"b\", \"c\")\n\nOnce you have created these vectors in R, you can use them to do calculations.\nSteps\n\nComplete the code such that boolean_vector contains the three elements: TRUE, FALSE and TRUE (in that order).\n\n\nnumeric_vector   <- c(1, 10, 49)\ncharacter_vector <- c(\"a\", \"b\", \"c\")\n\n## Complete the code for boolean_vector\nboolean_vector   <- c(TRUE, FALSE, TRUE)\n\nPerfect! Notice that adding a space behind the commas in the c() function improves the readability of your code. Let’s practice some more with vector creation in the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector-3",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#create-a-vector-3",
    "title": "Introduction to R",
    "section": "Create a vector (3)",
    "text": "Create a vector (3)\nAfter one week in Las Vegas and still zero Ferraris in your garage, you decide that it is time to start using your data analytical superpowers.\nBefore doing a first analysis, you decide to first collect all the winnings and losses for the last week:\nFor poker_vector:\n\nOn Monday you won $140\nTuesday you lost $50\nWednesday you won $20\nThursday you lost $120\nFriday you won $240\n\nFor roulette_vector:\n\nOn Monday you lost $24\nTuesday you lost $50\nWednesday you won $100\nThursday you lost $350\nFriday you won $10\n\nYou only played poker and roulette, since there was a delegation of mediums that occupied the craps tables. To be able to use this data in R, you decide to create the variables poker_vector and roulette_vector.\nSteps\n\nAssign the winnings/losses for roulette to the variable roulette_vector. You lost $24, then lost $50, won $100, lost $350, and won $10.\n\n\n## Poker winnings from Monday to Friday\npoker_vector    <- c(140, -50, 20, -120, 240)\n\n## Roulette winnings from Monday to Friday\nroulette_vector <-  c(-24, -50, 100, -350, 10)\n\nVery good! To check out the contents of your vectors, remember that you can always simply type the variable in the console and hit Enter. Proceed to the next exercise!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-vector",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-vector",
    "title": "Introduction to R",
    "section": "Naming a vector",
    "text": "Naming a vector\nAs a data analyst, it is important to have a clear view on the data that you are using. Understanding what each element refers to is therefore essential.\nIn the previous exercise, we created a vector with your winnings over the week. Each vector element refers to a day of the week but it is hard to tell which element belongs to which day. It would be nice if you could show that in the vector itself.\nYou can give a name to the elements of a vector with the names() function. Have a look at this example:\n\nsome_vector        <- c(\"John Doe\", \"poker player\")\nnames(some_vector) <- c(\"Name\", \"Profession\")\n\nThis code first creates a vector some_vector and then gives the two elements a name. The first element is assigned the name Name, while the second element is labeled Profession. Printing the contents to the console yields following output:\n\n#>           Name     Profession \n#>     \"John Doe\" \"poker player\"\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\nSteps\n\nThe code in the editor names the elements in poker_vector with the days of the week. Add code to do the same thing for roulette_vector.\n\n\n## Assign days as names of poker_vector\nnames(poker_vector)    <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n## Assign days as names of roulette_vectors\nnames(roulette_vector) <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-vector-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-vector-2",
    "title": "Introduction to R",
    "section": "Naming a vector (2)",
    "text": "Naming a vector (2)\nIf you want to become a good statistician, you have to become lazy. (If you are already lazy, chances are high you are one of those exceptional, natural-born statistical talents.)\nIn the previous exercises you probably experienced that it is boring and frustrating to type and retype information such as the days of the week. However, when you look at it from a higher perspective, there is a more efficient way to do this, namely, to assign the days of the week vector to a variable!\nJust like you did with your poker and roulette returns, you can also create a variable that contains the days of the week. This way you can use and re-use it.\nSteps\n\nA variable days_vector that contains the days of the week has already been created for you.\nUse days_vector to set the names of poker_vector and roulette_vector.\n\n\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n \n## Assign the names of the day to roulette_vector and poker_vector\nnames(poker_vector)    <- days_vector \nnames(roulette_vector) <- days_vector\n\nNice one! A word of advice: try to avoid code duplication at all times. Continue to the next exercise and learn how to do arithmetic with vectors!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings",
    "title": "Introduction to R",
    "section": "Calculating total winnings",
    "text": "Calculating total winnings\nNow that you have the poker and roulette winnings nicely as named vectors, you can start doing some data analytical magic.\nYou want to find out the following type of information:\n\nHow much has been your overall profit or loss per day of the week?\nHave you lost money over the week in total?\nAre you winning/losing money on poker or on roulette?\n\nTo get the answers, you have to do arithmetic calculations on vectors.\nIt is important to know that if you sum two vectors in R, it takes the element-wise sum. For example, the following three statements are completely equivalent:\n\nc(1, 2, 3) + c(4, 5, 6)\nc(1 + 4, 2 + 5, 3 + 6)\nc(5, 7, 9)\n\nYou can also do the calculations with variables that represent vectors:\n\na <- c(1, 2, 3) \nb <- c(4, 5, 6)\nc <- a + b\n\nSteps\n\nTake the sum of the variables A_vector and B_vector and assign it to total_vector.\nInspect the result by printing out total_vector.\n\n\nA_vector <- c(1, 2, 3)\nB_vector <- c(4, 5, 6)\n\n## Take the sum of A_vector and B_vector\ntotal_vector <- A_vector + B_vector\n  \n## Print out total_vector\ntotal_vector\n\n[1] 5 7 9"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings-2",
    "title": "Introduction to R",
    "section": "Calculating total winnings (2)",
    "text": "Calculating total winnings (2)\nNow you understand how R does arithmetic with vectors, it is time to get those Ferraris in your garage! First, you need to understand what the overall profit or loss per day of the week was. The total daily profit is the sum of the profit/loss you realized on poker per day, and the profit/loss you realized on roulette per day.\nIn R, this is just the sum of roulette_vector and poker_vector.\nSteps\n\nAssign to the variable total_daily how much you won or lost on each day in total (poker and roulette combined).\n\n\n## Assign to total_daily how much you won/lost on each day\ntotal_daily <- poker_vector + roulette_vector"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings-3",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#calculating-total-winnings-3",
    "title": "Introduction to R",
    "section": "Calculating total winnings (3)",
    "text": "Calculating total winnings (3)\nBased on the previous analysis, it looks like you had a mix of good and bad days. This is not what your ego expected, and you wonder if there may be a very tiny chance you have lost money over the week in total?\nA function that helps you to answer this question is sum(). It calculates the sum of all elements of a vector. For example, to calculate the total amount of money you have lost/won with poker you do:\n\ntotal_poker <- sum(poker_vector)\n\nSteps\n\nCalculate the total amount of money that you have won/lost with roulette and assign to the variable total_roulette.\nNow that you have the totals for roulette and poker, you can easily calculate total_week (which is the sum of all gains and losses of the week).\nPrint out total_week.\n\n\n## Total winnings with poker\ntotal_poker    <- sum(poker_vector)\n\n## Total winnings with roulette\ntotal_roulette <- sum(roulette_vector) \n\n## Total winnings overall\ntotal_week     <- total_roulette + total_poker\n\n## Print out total_week\ntotal_week\n\n[1] -84"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#comparing-total-winnings",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#comparing-total-winnings",
    "title": "Introduction to R",
    "section": "Comparing total winnings",
    "text": "Comparing total winnings\nOops, it seems like you are losing money. Time to rethink and adapt your strategy! This will require some deeper analysis…\nAfter a short brainstorm in your hotel’s jacuzzi, you realize that a possible explanation might be that your skills in roulette are not as well developed as your skills in poker. So maybe your total gains in poker are higher (or > ) than in roulette.\nSteps\n\nCalculate total_poker and total_roulette as in the previous exercise. Use the sum() function twice.\nCheck if your total gains in poker are higher than for roulette by using a comparison. Simply print out the result of this comparison. What do you conclude, should you focus on roulette or on poker?\n\n\n## Check if you realized higher total gains in poker than in roulette \ntotal_poker > total_roulette\n\n[1] TRUE"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times",
    "title": "Introduction to R",
    "section": "Vector selection: the good times",
    "text": "Vector selection: the good times\nYour hunch seemed to be right. It appears that the poker game is more your cup of tea than roulette.\nAnother possible route for investigation is your performance at the beginning of the working week compared to the end of it. You did have a couple of Margarita cocktails at the end of the week…\nTo answer that question, you only want to focus on a selection of the total_vector. In other words, our goal is to select specific elements of the vector. To select elements of a vector (and later matrices, data frames, …), you can use square brackets. Between the square brackets, you indicate what elements to select. For example, to select the first element of the vector, you type poker_vector[1]. To select the second element of the vector, you type poker_vector[2], etc. Notice that the first element in a vector has index 1, not 0 as in many other programming languages.\nSteps\n\nAssign the poker results of Wednesday to the variable poker_wednesday.\n\n\n## Define a new variable based on a selection\npoker_wednesday <- poker_vector[3]\n\nGreat! R also makes it possible to select multiple elements from a vector at once. Learn how in the next exercise!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-2",
    "title": "Introduction to R",
    "section": "Vector selection: the good times (2)",
    "text": "Vector selection: the good times (2)\nHow about analyzing your midweek results?\nTo select multiple elements from a vector, you can add square brackets at the end of it. You can indicate between the brackets what elements should be selected. For example: suppose you want to select the first and the fifth day of the week: use the vector c(1, 5) between the square brackets. For example, the code below selects the first and fifth element of poker_vector:\n\npoker_vector[c(1, 5)]\n\nSteps\n\nAssign the poker results of Tuesday, Wednesday and Thursday to the variable poker_midweek.\n\n\n## Define a new variable based on a selection\npoker_midweek <- poker_vector[c(2,3,4)]\n\nWell done! Continue to the next exercise to specialize in vector selection some more!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-3",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-3",
    "title": "Introduction to R",
    "section": "Vector selection: the good times (3)",
    "text": "Vector selection: the good times (3)\nSelecting multiple elements of poker_vector with c(2, 3, 4) is not very convenient. Many statisticians are lazy people by nature, so they created an easier way to do this: c(2, 3, 4) can be abbreviated to2:4, which generates a vector with all natural numbers from 2 up to 4.\nSo, another way to find the mid-week results is poker_vector[2:4]. Notice how the vector 2:4 is placed between the square brackets to select element 2 up to 4.\nSteps\n\nAssign to roulette_selection_vector the roulette results from Tuesday up to Friday; make use of : if it makes things easier for you.\n\n\n## Define a new variable based on a selection\nroulette_selection_vector <- roulette_vector[2:5]\n\nAwesome! The colon operator is extremely useful and very often used in R programming, so remember it well. Proceed to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-4",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#vector-selection-the-good-times-4",
    "title": "Introduction to R",
    "section": "Vector selection: the good times (4)",
    "text": "Vector selection: the good times (4)\nAnother way to tackle the previous exercise is by using the names of the vector elements (Monday, Tuesday, …) instead of their numeric positions. For example,\n\npoker_vector[\"Monday\"]\n\nwill select the first element of poker_vector since \"Monday\" is the name of that first element.\nJust like you did in the previous exercise with numerics, you can also use the element names to select multiple elements, for example:\n\npoker_vector[c(\"Monday\",\"Tuesday\")]\n\nSteps\n\nSelect the first three elements in poker_vector by using their names: \"Monday\", \"Tuesday\" and \"Wednesday\". Assign the result of the selection to poker_start.\nCalculate the average of the values in poker_start with the mean() function. Simply print out the result so you can inspect it.\n\n\n## Select poker results for Monday, Tuesday and Wednesday\npoker_start <- poker_vector[c(\"Monday\", \"Tuesday\", \"Wednesday\")]\n  \n## Calculate the average of the elements in poker_start\nmean(poker_start)\n\n[1] 36.66667\n\n\nGood job! Apart from subsetting vectors by index or by name, you can also subset vectors by comparison. The next exercises will show you how!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selection-by-comparison---step-1",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selection-by-comparison---step-1",
    "title": "Introduction to R",
    "section": "Selection by comparison - Step 1",
    "text": "Selection by comparison - Step 1\nBy making use of comparison operators, we can approach the previous question in a more proactive way.  The (logical) comparison operators known to R are:\n\n< for less than\n> for greater than\n<= for less than or equal to\n>= for greater than or equal to\n== for equal to each other\n!= not equal to each other\n\nAs seen in the previous chapter, stating 6 &gt; 5 returns TRUE. The nice thing about R is that you can use these comparison operators also on vectors. For example:\n\nc(4, 5, 6) > 5\n#> [1] FALSE FALSE  TRUE\n\nCreated on 2022-01-17 by the reprex package (v2.0.1)\nThis command tests for every element of the vector if the condition stated by the comparison operator is TRUE or FALSE.\nSteps\n\nCheck which elements in poker_vector are positive (i.e. > 0) and assign this to selection_vector.\nPrint out selection_vector so you can inspect it. The printout tells you whether you won (TRUE) or lost (FALSE) any money for each day.\n\n\n## Which days did you make money on poker?\nselection_vector <- poker_vector > 0\n  \n## Print out selection_vector\nselection_vector\n\n   Monday   Tuesday Wednesday  Thursday    Friday \n     TRUE     FALSE      TRUE     FALSE      TRUE"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selection-by-comparison---step-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selection-by-comparison---step-2",
    "title": "Introduction to R",
    "section": "Selection by comparison - Step 2",
    "text": "Selection by comparison - Step 2\nWorking with comparisons will make your data analytical life easier. Instead of selecting a subset of days to investigate yourself (like before), you can simply ask R to return only those days where you realized a positive return for poker.\nIn the previous exercises you used selection_vector <- poker_vector > 0 to find the days on which you had a positive poker return. Now, you would like to know not only the days on which you won, but also how much you won on those days.\nYou can select the desired elements, by putting selection_vector between the square brackets that follow poker_vector:\n\npoker_vector[selection_vector]\n\nR knows what to do when you pass a logical vector in square brackets: it will only select the elements that correspond to TRUE in selection_vector.\nSteps\n\nUse selection_vector in square brackets to assign the amounts that you won on the profitable days to the variable poker_winning_days.\n\n\n## Select from poker_vector these days\npoker_winning_days <- poker_vector[selection_vector]"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#advanced-selection",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#advanced-selection",
    "title": "Introduction to R",
    "section": "Advanced selection",
    "text": "Advanced selection\nJust like you did for poker, you also want to know those days where you realized a positive return for roulette.\nSteps\n\nCreate the variable selection_vector, this time to see if you made profit with roulette for different days.\nAssign the amounts that you made on the days that you ended positively for roulette to the variable roulette_winning_days. This vector thus contains the positive winnings of roulette_vector.\n\n\n## Which days did you make money on roulette?\nselection_vector      <- roulette_vector > 0\n\n## Select from roulette_vector these days\nroulette_winning_days <- roulette_vector[selection_vector]\n\nGreat! This exercise concludes the chapter on vectors. The next chapter will introduce you to the two-dimensional version of vectors: matrices."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-matrix",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-matrix",
    "title": "Introduction to R",
    "section": "What’s a matrix?",
    "text": "What’s a matrix?\nIn R, a matrix is a collection of elements of the same data type (numeric, character, or logical) arranged into a fixed number of rows and columns. Since you are only working with rows and columns, a matrix is called two-dimensional.\nYou can construct a matrix in R with the matrix() function. Consider the following example:\n\nmatrix(1:9, byrow = TRUE, nrow = 3)\n\nIn the matrix() function:\n\nThe first argument is the collection of elements that R will arrange into the rows and columns of the matrix. Here, we use 1:9 which is a shortcut for c(1, 2, 3, 4, 5, 6, 7, 8, 9).\nThe argument byrow indicates that the matrix is filled by the rows. If we want the matrix to be filled by the columns, we just place byrow = FALSE.\nThe third argument nrow indicates that the matrix should have three rows.\n\nSteps\n\nConstruct a matrix with 3 rows containing the numbers 1 up to 9, filled row-wise.\n\n\n## Construct a matrix with 3 rows that contain the numbers 1 up to 9\nmatrix(1:9, byrow = TRUE, nrow = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#analyze-matrices-you-shall",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#analyze-matrices-you-shall",
    "title": "Introduction to R",
    "section": "Analyze matrices, you shall",
    "text": "Analyze matrices, you shall\nIt is now time to get your hands dirty. In the following exercises you will analyze the box office numbers of the Star Wars franchise. May the force be with you!\nIn the editor, three vectors are defined. Each one represents the box office numbers from the first three Star Wars movies. The first element of each vector indicates the US box office revenue, the second element refers to the Non-US box office (source: Wikipedia).\nIn this exercise, you’ll combine all these figures into a single vector. Next, you’ll build a matrix from this vector.\nSteps\n\nUse c(new_hope, empire_strikes, return_jedi) to combine the three vectors into one vector. Call this vector box_office.\nConstruct a matrix with 3 rows, where each row represents a movie. Use the matrix() function to do this. The first argument is the vector box_office, containing all box office figures. Next, you’ll have to specify nrow = 3 and byrow = TRUE. Name the resulting matrix star_wars_matrix.\n\n\n## Box office Star Wars (in millions!)\nnew_hope         <- c(460.998, 314.4)\nempire_strikes   <- c(290.475, 247.900)\nreturn_jedi      <- c(309.306, 165.8)\n\n## Create box_office\nbox_office       <- c(new_hope, empire_strikes, return_jedi)\n\n## Construct star_wars_matrix\nstar_wars_matrix <- matrix(box_office, byrow=TRUE, nrow=3)\nstar_wars_matrix\n\n        [,1]  [,2]\n[1,] 460.998 314.4\n[2,] 290.475 247.9\n[3,] 309.306 165.8"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-matrix",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#naming-a-matrix",
    "title": "Introduction to R",
    "section": "Naming a matrix",
    "text": "Naming a matrix\nTo help you remember what is stored in star_wars_matrix, you would like to add the names of the movies for the rows. Not only does this help you to read the data, but it is also useful to select certain elements from the matrix.\nSimilar to vectors, you can add names for the rows and the columns of a matrix\n\nrownames(my_matrix) <- row_names_vector\ncolnames(my_matrix) <- col_names_vector\n\nWe went ahead and prepared two vectors for you: region, and titles. You will need these vectors to name the columns and rows of star_wars_matrix, respectively.\nSteps\n\nUse colnames() to name the columns of star_wars_matrix with the region vector.\nUse rownames() to name the rows of star_wars_matrix with the titles vector.\nPrint out star_wars_matrix to see the result of your work.\n\n\n## Vectors region and titles, used for naming\nregion <- c(\"US\", \"non-US\")\ntitles <- c(\"A New Hope\", \"The Empire Strikes Back\", \"Return of the Jedi\")\n\n## Name the columns with region\ncolnames(star_wars_matrix) <- region\n\n## Name the rows with titles\nrownames(star_wars_matrix) <- titles\n\n## Print out star_wars_matrix\nstar_wars_matrix\n\n                             US non-US\nA New Hope              460.998  314.4\nThe Empire Strikes Back 290.475  247.9\nReturn of the Jedi      309.306  165.8"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#calculating-the-worldwide-box-office",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#calculating-the-worldwide-box-office",
    "title": "Introduction to R",
    "section": "Calculating the worldwide box office",
    "text": "Calculating the worldwide box office\nThe single most important thing for a movie in order to become an instant legend in Tinseltown is its worldwide box office figures.\nTo calculate the total box office revenue for the three Star Wars movies, you have to take the sum of the US revenue column and the non-US revenue column.\nIn R, the function rowSums() conveniently calculates the totals for each row of a matrix. This function creates a new vector:\n\nrowSums(my_matrix)\n\nSteps\n\nCalculate the worldwide box office figures for the three movies and put these in the vector named worldwide_vector.\n\n\n## Calculate worldwide box office figures\nworldwide_vector <- rowSums(star_wars_matrix)\nworldwide_vector\n\n             A New Hope The Empire Strikes Back      Return of the Jedi \n                775.398                 538.375                 475.106"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#adding-a-column-for-the-worldwide-box-office",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#adding-a-column-for-the-worldwide-box-office",
    "title": "Introduction to R",
    "section": "Adding a column for the Worldwide box office",
    "text": "Adding a column for the Worldwide box office\nIn the previous exercise you calculated the vector that contained the worldwide box office receipt for each of the three Star Wars movies. However, this vector is not yet part of star_wars_matrix.\nYou can add a column or multiple columns to a matrix with the cbind() function, which merges matrices and/or vectors together by column. For example:\n\nbig_matrix <- cbind(matrix1, matrix2, vector1, ...)\n\nSteps\n\nAdd worldwide_vector as a new column to the star_wars_matrix and assign the result to all_wars_matrix. Use the cbind() function.\n\n\n## Bind the new variable worldwide_vector as a column to star_wars_matrix\nall_wars_matrix <- cbind(star_wars_matrix, worldwide_vector)\nall_wars_matrix\n\n                             US non-US worldwide_vector\nA New Hope              460.998  314.4          775.398\nThe Empire Strikes Back 290.475  247.9          538.375\nReturn of the Jedi      309.306  165.8          475.106\n\n\nNice job! After adding column to a matrix, the logical next step is adding rows. Learn how in the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#adding-a-row",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#adding-a-row",
    "title": "Introduction to R",
    "section": "Adding a row",
    "text": "Adding a row\nJust like every action has a reaction, every cbind() has an rbind(). (We admit, we are pretty bad with metaphors.)\nYour R workspace, where all variables you defined ‘live’ (check out what a workspace is), has already been initialized and contains two matrices:\n\nstar_wars_matrix that we have used all along, with data on the original trilogy,\nstar_wars_matrix2, with similar data for the prequels trilogy.\n\nExplore these matrices in the console if you want to have a closer look. If you want to check out the contents of the workspace, you can type ls() in the console.\nSteps\n\nUse rbind() to paste together star_wars_matrix and star_wars_matrix2, in this order. Assign the resulting matrix to all_wars_matrix.\n\n\n## star_wars_matrix and star_wars_matrix2 are available in your workspace\nbox_office2       <- c(474.5, 552.5, 310.7, 338.7, 380.3, 468.5)\nstar_wars_matrix2 <- matrix(box_office2, nrow = 3, byrow = TRUE,\n                           dimnames = list(c(\"The Phantom Menace\", \"Attack of the Clones\", \"Revenge of the Sith\"), \n                                           c(\"US\", \"non-US\")))\n\n## Combine both Star Wars trilogies in one matrix\nall_wars_matrix <- rbind(star_wars_matrix, star_wars_matrix2)\nall_wars_matrix\n\n                             US non-US\nA New Hope              460.998  314.4\nThe Empire Strikes Back 290.475  247.9\nReturn of the Jedi      309.306  165.8\nThe Phantom Menace      474.500  552.5\nAttack of the Clones    310.700  338.7\nRevenge of the Sith     380.300  468.5\n\n\nWonderful! Continue with the next exercise and see how you can combine the results of the rbind() function with the colSums() function!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#the-total-box-office-revenue-for-the-entire-saga",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#the-total-box-office-revenue-for-the-entire-saga",
    "title": "Introduction to R",
    "section": "The total box office revenue for the entire saga",
    "text": "The total box office revenue for the entire saga\nJust like cbind() has rbind(), colSums() has rowSums(). Your R workspace already contains the all_wars_matrix that you constructed in the previous exercise; type all_wars_matrix to have another look. Let’s now calculate the total box office revenue for the entire saga.\nSteps\n\nCalculate the total revenue for the US and the non-US region and assign total_revenue_vector. You can use the colSums() function.\nPrint out total_revenue_vector to have a look at the results.\n\n\n## all_wars_matrix is available in your workspace\nall_wars_matrix\n\n                             US non-US\nA New Hope              460.998  314.4\nThe Empire Strikes Back 290.475  247.9\nReturn of the Jedi      309.306  165.8\nThe Phantom Menace      474.500  552.5\nAttack of the Clones    310.700  338.7\nRevenge of the Sith     380.300  468.5\n\n## Total revenue for US and non-US\ntotal_revenue_vector <- colSums(all_wars_matrix)\n  \n## Print out total_revenue_vector\ntotal_revenue_vector\n\n      US   non-US \n2226.279 2087.800 \n\n\nBellissimo! Head over to the next exercise to learn matrix subsetting."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-matrix-elements",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-matrix-elements",
    "title": "Introduction to R",
    "section": "Selection of matrix elements",
    "text": "Selection of matrix elements\nSimilar to vectors, you can use the square brackets [ ] to select one or multiple elements from a matrix. Whereas vectors have one dimension, matrices have two dimensions. You should therefore use a comma to separate the rows you want to select from the columns. For example:\n\nmy_matrix[1,2] selects the element at the first row and second column.\nmy_matrix[1:3,2:4] results in a matrix with the data on the rows 1, 2, 3 and columns 2, 3, 4.\n\nIf you want to select all elements of a row or a column, no number is needed before or after the comma, respectively:\n\nmy_matrix[,1] selects all elements of the first column.\nmy_matrix[1,] selects all elements of the first row.\n\nBack to Star Wars with this newly acquired knowledge! As in the previous exercise, all_wars_matrix is already available in your workspace.\nSteps\n\nSelect the non-US revenue for all movies (the entire second column of all_wars_matrix), store the result as non_us_all.\nUse mean() on non_us_all to calculate the average non-US revenue for all movies. Simply print out the result.\nThis time, select the non-US revenue for the first two movies in all_wars_matrix. Store the result as non_us_some.\nUse mean() again to print out the average of the values in non_us_some.\n\n\n## Select the non-US revenue for all movies\nnon_us_all  <- all_wars_matrix[,2]\n  \n## Average non-US revenue\nmean(non_us_all)\n\n[1] 347.9667\n\n## Select the non-US revenue for first two movies\nnon_us_some <- all_wars_matrix[1:2,2]\n  \n## Average non-US revenue for first two movies\nmean(non_us_some)\n\n[1] 281.15"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#a-little-arithmetic-with-matrices",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#a-little-arithmetic-with-matrices",
    "title": "Introduction to R",
    "section": "A little arithmetic with matrices",
    "text": "A little arithmetic with matrices\nSimilar to what you have learned with vectors, the standard operators like +, -, /, *, etc. work in an element-wise way on matrices in R.\nFor example, 2 * my_matrix multiplies each element of my_matrix by two.\nAs a newly-hired data analyst for Lucasfilm, it is your job to find out how many visitors went to each movie for each geographical area. You already have the total revenue figures in all_wars_matrix. Assume that the price of a ticket was 5 dollars. Simply dividing the box office numbers by this ticket price gives you the number of visitors.\nSteps\n\nDivide all_wars_matrix by 5, giving you the number of visitors in millions. Assign the resulting matrix to visitors.\nPrint out visitors so you can have a look.\n\n\n## all_wars_matrix is available in your workspace\nall_wars_matrix\n\n                             US non-US\nA New Hope              460.998  314.4\nThe Empire Strikes Back 290.475  247.9\nReturn of the Jedi      309.306  165.8\nThe Phantom Menace      474.500  552.5\nAttack of the Clones    310.700  338.7\nRevenge of the Sith     380.300  468.5\n\n## Estimate the visitors\nvisitors <- all_wars_matrix / 5\n  \n## Print the estimate to the console\nvisitors\n\n                             US non-US\nA New Hope              92.1996  62.88\nThe Empire Strikes Back 58.0950  49.58\nReturn of the Jedi      61.8612  33.16\nThe Phantom Menace      94.9000 110.50\nAttack of the Clones    62.1400  67.74\nRevenge of the Sith     76.0600  93.70\n\n\nGreat! What do these results tell you? A staggering 92 million people went to see A New Hope in US theaters! Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#a-little-arithmetic-with-matrices-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#a-little-arithmetic-with-matrices-2",
    "title": "Introduction to R",
    "section": "A little arithmetic with matrices (2)",
    "text": "A little arithmetic with matrices (2)\nJust like 2 * my_matrix multiplied every element of my_matrix by two, my_matrix1 * my_matrix2 creates a matrix where each element is the product of the corresponding elements in my_matrix1 and my_matrix2.\nAfter looking at the result of the previous exercise, big boss Lucas points out that the ticket prices went up over time. He asks to redo the analysis based on the prices you can find in ticket_prices_matrix (source: imagination).\nThose who are familiar with matrices should note that this is not the standard matrix multiplication for which you should use %% in R.\nSteps\n\nDivide all_wars_matrix by ticket_prices_matrix to get the estimated number of US and non-US visitors for the six movies. Assign the result to visitors.\nFrom the visitors matrix, select the entire first column, representing the number of visitors in the US. Store this selection as us_visitors.\nCalculate the average number of US visitors; print out the result.\n\n\nticket_prices        <- c(5.0,5.0,6.0,6.0,7.0,7.0,4.0,4.0,4.5,4.5,4.9,4.9)\nticket_prices_matrix <- matrix(ticket_prices, nrow = 6, byrow = TRUE,\n                               dimnames = list(c(\"A New Hope\", \"The Empire Strikes Back\", \"Return of the Jedi\", \"The Phantom Menace\", \"Attack of the Clones\", \"Revenge of the Sith\"), \n                                               c(\"US\", \"non-US\")))\n\n## Estimated number of visitors\nvisitors <- all_wars_matrix / ticket_prices_matrix\n\n## US visitors\nus_visitors <- visitors[,1]\n\n## Average number of US visitors\nmean(us_visitors)\n\n[1] 75.01339"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it",
    "title": "Introduction to R",
    "section": "What’s a factor and why would you use it?",
    "text": "What’s a factor and why would you use it?\nIn this chapter you dive into the wonderful world of factors.\nThe term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable can belong to a limited number of categories. A continuous variable, on the other hand, can correspond to an infinite number of values.\nIt is important that R knows whether it is dealing with a continuous or a categorical variable, as the statistical models you will develop in the future treat both types differently. (You will see later why this is the case.)\nA good example of a categorical variable is sex. In many circumstances you can limit the sex categories to “Male” or “Female”. (Sometimes you may need different categories. For example, you may need to consider chromosomal variation, hermaphroditic animals, or different cultural norms, but you will always have a finite number of categories.)\nSteps\n\nAssign to variable theory the value \"factors\".\n\n\n## Assign to the variable theory what this chapter is about!\ntheory <- \"factors for categorical variables\""
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it-2",
    "title": "Introduction to R",
    "section": "What’s a factor and why would you use it? (2)",
    "text": "What’s a factor and why would you use it? (2)\nTo create factors in R, you make use of the function factor(). First thing that you have to do is create a vector that contains all the observations that belong to a limited number of categories. For example, sex_vector contains the sex of 5 different individuals:\n\nsex_vector <- c(\"Male\",\"Female\",\"Female\",\"Male\",\"Male\")\n\nIt is clear that there are two categories, or in R-terms ‘factor levels’, at work here: “Male” and “Female”.\nThe function factor() will encode the vector as a factor:\n\nfactor_sex_vector <- factor(sex_vector)\n\nSteps\n\nConvert the character vector sex_vector to a factor with factor() and assign the result to factor_sex_vector\nPrint out factor_sex_vector and assert that R prints out the factor levels below the actual values.\n\n\n## Sex vector\nsex_vector        <- c(\"Male\", \"Female\", \"Female\", \"Male\", \"Male\")\n\n## Convert sex_vector to a factor\nfactor_sex_vector <- factor(sex_vector)\n\n## Print out factor_sex_vector\nfactor_sex_vector\n\n[1] Male   Female Female Male   Male  \nLevels: Female Male\n\n\nGreat! If you want to find out more about the factor() function, do not hesitate to type ?factor in the console. This will open up a help page. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it-3",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-factor-and-why-would-you-use-it-3",
    "title": "Introduction to R",
    "section": "What’s a factor and why would you use it? (3)",
    "text": "What’s a factor and why would you use it? (3)\nThere are two types of categorical variables: a nominal categorical variable and an ordinal categorical variable.\nA nominal variable is a categorical variable without an implied order. This means that it is impossible to say that ‘one is worth more than the other’. For example, think of the categorical variable animals_vector with the categories \"Elephant\", \"Giraffe\", \"Donkey\" and \"Horse\". Here, it is impossible to say that one stands above or below the other. (Note that some of you might disagree ;-) ).\nIn contrast, ordinal variables do have a natural ordering. Consider for example the categorical variable temperature_vector with the categories: \"Low\", \"Medium\" and \"High\". Here it is obvious that \"Medium\" stands above \"Low\", and \"High\" stands above \"Medium\".\nSteps\n\nSubmit the answer to check how R constructs and prints nominal and ordinal variables. Do not worry if you do not understand all the code just yet, we will get to that.\n\n\n## Animals\nanimals_vector        <- c(\"Elephant\", \"Giraffe\", \"Donkey\", \"Horse\")\nfactor_animals_vector <- factor(animals_vector)\nfactor_animals_vector\n\n[1] Elephant Giraffe  Donkey   Horse   \nLevels: Donkey Elephant Giraffe Horse\n\n## Temperature\ntemperature_vector        <- c(\"High\", \"Low\", \"High\",\"Low\", \"Medium\")\nfactor_temperature_vector <- factor(temperature_vector, order = TRUE, levels = c(\"Low\", \"Medium\", \"High\"))\nfactor_temperature_vector\n\n[1] High   Low    High   Low    Medium\nLevels: Low < Medium < High\n\n\nCan you already tell what’s happening in this exercise? Awesome! Continue to the next exercise and get into the details of factor levels."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#factor-levels",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#factor-levels",
    "title": "Introduction to R",
    "section": "Factor levels",
    "text": "Factor levels\nWhen you first get a dataset, you will often notice that it contains factors with specific factor levels. However, sometimes you will want to change the names of these levels for clarity or other reasons. R allows you to do this with the function levels():\n\nlevels(factor_vector) <- c(\"name1\", \"name2\",...)\n\nA good illustration is the raw data that is provided to you by a survey. A common question for every questionnaire is the sex of the respondent. Here, for simplicity, just two categories were recorded, \"M\" and \"F\". (You usually need more categories for survey data; either way, you use a factor to store the categorical data.)\n\nsurvey_vector <- c(\"M\", \"F\", \"F\", \"M\", \"M\")\n\nRecording the sex with the abbreviations \"M\" and \"F\" can be convenient if you are collecting data with pen and paper, but it can introduce confusion when analyzing the data. At that point, you will often want to change the factor levels to \"Male\" and \"Female\" instead of \"M\" and \"F\" for clarity.\nWatch out: the order with which you assign the levels is important. If you type levels(factor_survey_vector), you’ll see that it outputs [1] \"F\" \"M\". If you don’t specify the levels of the factor when creating the vector, R will automatically assign them alphabetically. To correctly map \"F\" to \"Female\" and \"M\" to \"Male\", the levels should be set to c(\"Female\", \"Male\"), in this order.\nSteps\n\nCheck out the code that builds a factor vector from survey_vector. You should use factor_survey_vector in the next instruction.\nChange the factor levels of factor_survey_vector to c(\"Female\", \"Male\"). Mind the order of the vector elements here.\n\n\n## Code to build factor_survey_vector\nsurvey_vector        <- c(\"M\", \"F\", \"F\", \"M\", \"M\")\nfactor_survey_vector <- factor(survey_vector)\n\n## Specify the levels of factor_survey_vector\nlevels(factor_survey_vector) <- c(\"Female\", \"Male\")\n\nfactor_survey_vector\n\n[1] Male   Female Female Male   Male  \nLevels: Female Male"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#summarizing-a-factor",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#summarizing-a-factor",
    "title": "Introduction to R",
    "section": "Summarizing a factor",
    "text": "Summarizing a factor\nAfter finishing this course, one of your favorite functions in R will be summary(). This will give you a quick overview of the contents of a variable:\n\nsummary(my_var)\n\nGoing back to our survey, you would like to know how many \"Male\" responses you have in your study, and how many \"Female\" responses. The summary() function gives you the answer to this question.\nSteps\n\nAsk a summary() of the survey_vector and factor_survey_vector. Interpret the results of both vectors. Are they both equally useful in this case?\n\n\n## Generate summary for survey_vector\nsummary(survey_vector)\n#>    Length     Class      Mode \n#>         5 character character\n\n## Generate summary for factor_survey_vector\nsummary(factor_survey_vector)\n#> Female   Male \n#>      2      3\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\nNice! Have a look at the output. The fact that you identified \"Male\" and \"Female\" as factor levels in factor_survey_vector enables R to show the number of elements for each category."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#battle-of-the-sexes",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#battle-of-the-sexes",
    "title": "Introduction to R",
    "section": "Battle of the sexes",
    "text": "Battle of the sexes\nYou might wonder what happens when you try to compare elements of a factor. In factor_survey_vector you have a factor with two levels: \"Male\" and \"Female\". But how does R value these relative to each other?\nSteps\n\nRead the code in the editor and submit the answer to test if male is greater than (&gt;) female.\n\n\n## Male\nmale <- factor_survey_vector[1]\n\n## Female\nfemale <- factor_survey_vector[2]\n\n## Battle of the sexes: Male 'larger' than female?\nmale > female\n\nWarning in Ops.factor(male, female): '>' ist nicht sinnvoll für Faktoren\n\n\n[1] NA\n\n\nHow interesting! By default, R returns NA when you try to compare values in a factor, since the idea doesn’t make sense. Next you’ll learn about ordered factors, where more meaningful comparisons are possible."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#ordered-factors",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#ordered-factors",
    "title": "Introduction to R",
    "section": "Ordered factors",
    "text": "Ordered factors\nSince \"Male\" and \"Female\" are unordered (or nominal) factor levels, R returns a warning message, telling you that the greater than operator is not meaningful. As seen before, R attaches an equal value to the levels for such factors.\nBut this is not always the case! Sometimes you will also deal with factors that do have a natural ordering between its categories. If this is the case, we have to make sure that we pass this information to R…\nLet us say that you are leading a research team of five data analysts and that you want to evaluate their performance. To do this, you track their speed, evaluate each analyst as \"slow\", \"medium\" or \"fast\", and save the results in speed_vector.\nSteps\n\nAs a first step, assign speed_vector a vector with 5 entries, one for each analyst. Each entry should be either \"slow\", \"medium\", or \"fast\". Use the list below:\n\nAnalyst 1 is medium,\nAnalyst 2 is slow,\nAnalyst 3 is slow,\nAnalyst 4 is medium and\nAnalyst 5 is fast.\n\n\nNo need to specify these are factors yet.\n\n## Create speed_vector\nspeed_vector <- c(\"medium\", \"slow\", \"slow\", \"medium\", \"fast\")"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#ordered-factors-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#ordered-factors-2",
    "title": "Introduction to R",
    "section": "Ordered factors (2)",
    "text": "Ordered factors (2)\nspeed_vector should be converted to an ordinal factor since its categories have a natural ordering. By default, the function factor() transforms speed_vector into an unordered factor. To create an ordered factor, you have to add two additional arguments: ordered and levels.\n\nfactor(some_vector,\n       ordered = TRUE,\n       levels = c(\"lev1\", \"lev2\", ...))\n\nBy setting the argument ordered to TRUE in the function factor(), you indicate that the factor is ordered. With the argument levels you give the values of the factor in the correct order.\nSteps\n\nFrom speed_vector, create an ordered factor vector: factor_speed_vector. Set ordered to TRUE, and set levels to c(\"slow\", \"medium\", \"fast\").\n\n\n## Convert speed_vector to ordered factor vector\nfactor_speed_vector <- factor(speed_vector, ordered = TRUE, levels =c(\"slow\", \"medium\", \"fast\"))\n\n## Print factor_speed_vector\nfactor_speed_vector\n#> [1] medium slow   slow   medium fast  \n#> Levels: slow < medium < fast\nsummary(factor_speed_vector)\n#>   slow medium   fast \n#>      2      2      1\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\nGreat! Have a look at the console. It is now indicated that the Levels indeed have an order associated, with the < sign. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#comparing-ordered-factors",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#comparing-ordered-factors",
    "title": "Introduction to R",
    "section": "Comparing ordered factors",
    "text": "Comparing ordered factors\nHaving a bad day at work, ‘data analyst number two’ enters your office and starts complaining that ‘data analyst number five’ is slowing down the entire project. Since you know that ‘data analyst number two’ has the reputation of being a smarty-pants, you first decide to check if his statement is true.\nThe fact that factor_speed_vector is now ordered enables us to compare different elements (the data analysts in this case). You can simply do this by using the well-known operators.\nSteps\n\nUse [2] to select from factor_speed_vector the factor value for the second data analyst. Store it as da2.\nUse [5] to select the factor_speed_vector factor value for the fifth data analyst. Store it as da5.\nCheck if da2 is greater than da5; simply print out the result. Remember that you can use the > operator to check whether one element is larger than the other.\n\n\n## Factor value for second data analyst\nda2 <- factor_speed_vector[2]\n\n## Factor value for fifth data analyst\nda5 <- factor_speed_vector[5]\n\n## Is data analyst 2 faster than data analyst 5?\nda2 > da5\n#> [1] FALSE\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\nBellissimo! What does the result tell you? Data analyst two is complaining about the data analyst five while in fact they are the one slowing everything down! This concludes the chapter on factors. With a solid basis in vectors, matrices and factors, you’re ready to dive into the wonderful world of data frames, a very important data structure in R!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-data-frame",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#whats-a-data-frame",
    "title": "Introduction to R",
    "section": "What’s a data frame?",
    "text": "What’s a data frame?\nYou may remember from the chapter about matrices that all the elements that you put in a matrix should be of the same type. Back then, your dataset on Star Wars only contained numeric elements.\nWhen doing a market research survey, however, you often have questions such as:\n\n‘Are you married?’ or ‘yes/no’ questions (logical)\n‘How old are you?’ (numeric)\n‘What is your opinion on this product?’ or other ‘open-ended’ questions (character)\n…\n\nThe output, namely the respondents’ answers to the questions formulated above, is a dataset of different data types. You will often find yourself working with datasets that contain different data types instead of only one.\nA data frame has the variables of a dataset as columns and the observations as rows. This will be a familiar concept for those coming from different statistical software packages such as SAS or SPSS.\nSteps\n\nSubmit the answer. The data from the built-in example data frame mtcars will be printed to the console.\n\n\n## Print out built-in R data frame\nmtcars \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\nDuster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\nMerc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\nMerc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\nMerc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n\n\nMerc 280C\n17.8\n6\n167.6\n123\n3.92\n3.440\n18.90\n1\n0\n4\n4\n\n\nMerc 450SE\n16.4\n8\n275.8\n180\n3.07\n4.070\n17.40\n0\n0\n3\n3\n\n\nMerc 450SL\n17.3\n8\n275.8\n180\n3.07\n3.730\n17.60\n0\n0\n3\n3\n\n\nMerc 450SLC\n15.2\n8\n275.8\n180\n3.07\n3.780\n18.00\n0\n0\n3\n3\n\n\nCadillac Fleetwood\n10.4\n8\n472.0\n205\n2.93\n5.250\n17.98\n0\n0\n3\n4\n\n\nLincoln Continental\n10.4\n8\n460.0\n215\n3.00\n5.424\n17.82\n0\n0\n3\n4\n\n\nChrysler Imperial\n14.7\n8\n440.0\n230\n3.23\n5.345\n17.42\n0\n0\n3\n4\n\n\nFiat 128\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n\n\nHonda Civic\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n\n\nToyota Corolla\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n\n\nToyota Corona\n21.5\n4\n120.1\n97\n3.70\n2.465\n20.01\n1\n0\n3\n1\n\n\nDodge Challenger\n15.5\n8\n318.0\n150\n2.76\n3.520\n16.87\n0\n0\n3\n2\n\n\nAMC Javelin\n15.2\n8\n304.0\n150\n3.15\n3.435\n17.30\n0\n0\n3\n2\n\n\nCamaro Z28\n13.3\n8\n350.0\n245\n3.73\n3.840\n15.41\n0\n0\n3\n4\n\n\nPontiac Firebird\n19.2\n8\n400.0\n175\n3.08\n3.845\n17.05\n0\n0\n3\n2\n\n\nFiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\nFord Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n\n\nFerrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\nMaserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n\n\nVolvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#quick-have-a-look-at-your-dataset",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#quick-have-a-look-at-your-dataset",
    "title": "Introduction to R",
    "section": "Quick, have a look at your dataset",
    "text": "Quick, have a look at your dataset\nWow, that is a lot of cars!\nWorking with large datasets is not uncommon in data analysis. When you work with (extremely) large datasets and data frames, your first task as a data analyst is to develop a clear understanding of its structure and main elements. Therefore, it is often useful to show only a small part of the entire dataset.\nSo how to do this in R? Well, the function head() enables you to show the first observations of a data frame. Similarly, the function tail() prints out the last observations in your dataset.\nBoth head() and tail() print a top line called the ‘header’, which contains the names of the different variables in your dataset.\nSteps\n\nCall head() on the mtcars dataset to have a look at the header and the first observations.\n\n\n## Call head() on mtcars\nhead(mtcars)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n\n\n\n\nWonderful! So, what do we have in this dataset? For example, hp represents the car’s horsepower; the Datsun has the lowest horse power of the 6 cars that are displayed. For a full overview of the variables’ meaning, type ?mtcars in the console and read the help page. Continue to the next exercise!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#have-a-look-at-the-structure",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#have-a-look-at-the-structure",
    "title": "Introduction to R",
    "section": "Have a look at the structure",
    "text": "Have a look at the structure\nAnother method that is often used to get a rapid overview of your data is the function str(). The function str() shows you the structure of your dataset. For a data frame it tells you:\n\nThe total number of observations (e.g. 32 car types)\nThe total number of variables (e.g. 11 car features)\nA full list of the variables names (e.g. mpg, cyl … )\nThe data type of each variable (e.g. num)\nThe first observations\n\nApplying the str() function will often be the first thing that you do when receiving a new dataset or data frame. It is a great way to get more insight in your dataset before diving into the real analysis.\nSteps\n\nInvestigate the structure of mtcars. Make sure that you see the same numbers, variables and data types as mentioned above.\n\n\n## Investigate the structure of mtcars\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\nNice work! You can find lots of information by viewing the str() of a dataset. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-data-frame",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-data-frame",
    "title": "Introduction to R",
    "section": "Creating a data frame",
    "text": "Creating a data frame\nSince using built-in datasets is not even half the fun of creating your own datasets, the rest of this chapter is based on your personally developed dataset. Put your jet pack on because it is time for some space exploration!\nAs a first goal, you want to construct a data frame that describes the main characteristics of eight planets in our solar system. According to your good friend Buzz, the main features of a planet are:\n\nThe type of planet (Terrestrial or Gas Giant).\nThe planet’s diameter relative to the diameter of the Earth.\nThe planet’s rotation across the sun relative to that of the Earth.\nIf the planet has rings or not (TRUE or FALSE).\n\nAfter doing some high-quality research on Wikipedia, you feel confident enough to create the necessary vectors: name, type, diameter, rotation and rings; these vectors have already been coded up in the editor. The first element in each of these vectors correspond to the first observation.\nYou construct a data frame with the data.frame() function. As arguments, you pass the vectors from before: they will become the different columns of your data frame. Because every column has the same length, the vectors you pass should also have the same length. But don’t forget that it is possible (and likely) that they contain different types of data.\nSteps\n\nUse the function data.frame() to construct a data frame. Pass the vectors name, type, diameter, rotation and rings as arguments to data.frame(), in this order. Call the resulting data frame planets_df.\n\n\n## Definition of vectors\nname <- c(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\ntype <- c(\"Terrestrial planet\", \"Terrestrial planet\", \"Terrestrial planet\", \n          \"Terrestrial planet\", \"Gas giant\", \"Gas giant\", \"Gas giant\", \"Gas giant\")\ndiameter <- c(0.382, 0.949, 1, 0.532, 11.209, 9.449, 4.007, 3.883)\nrotation <- c(58.64, -243.02, 1, 1.03, 0.41, 0.43, -0.72, 0.67)\nrings    <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)\n\n## Create a data frame from the vectors\nplanets_df <- data.frame(name, type, diameter, rotation, rings)\nplanets_df\n\n\n\n\n\nname\ntype\ndiameter\nrotation\nrings\n\n\n\n\nMercury\nTerrestrial planet\n0.382\n58.64\nFALSE\n\n\nVenus\nTerrestrial planet\n0.949\n-243.02\nFALSE\n\n\nEarth\nTerrestrial planet\n1.000\n1.00\nFALSE\n\n\nMars\nTerrestrial planet\n0.532\n1.03\nFALSE\n\n\nJupiter\nGas giant\n11.209\n0.41\nTRUE\n\n\nSaturn\nGas giant\n9.449\n0.43\nTRUE\n\n\nUranus\nGas giant\n4.007\n-0.72\nTRUE\n\n\nNeptune\nGas giant\n3.883\n0.67\nTRUE"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-data-frame-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-data-frame-2",
    "title": "Introduction to R",
    "section": "Creating a data frame (2)",
    "text": "Creating a data frame (2)\nThe planets_df data frame should have 8 observations and 5 variables. It has been made available in the workspace, so you can directly use it.\nSteps\n\nUse str() to investigate the structure of the new planets_df variable.\n\n\n## Check the structure of planets_df\nstr(planets_df)\n\n'data.frame':   8 obs. of  5 variables:\n $ name    : chr  \"Mercury\" \"Venus\" \"Earth\" \"Mars\" ...\n $ type    : chr  \"Terrestrial planet\" \"Terrestrial planet\" \"Terrestrial planet\" \"Terrestrial planet\" ...\n $ diameter: num  0.382 0.949 1 0.532 11.209 ...\n $ rotation: num  58.64 -243.02 1 1.03 0.41 ...\n $ rings   : logi  FALSE FALSE FALSE FALSE TRUE TRUE ...\n\n\nAwesome! Now that you have a clear understanding of the planets_df dataset, it’s time to see how you can select elements from it. Learn all about in the next exercises!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-data-frame-elements",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-data-frame-elements",
    "title": "Introduction to R",
    "section": "Selection of data frame elements",
    "text": "Selection of data frame elements\nSimilar to vectors and matrices, you select elements from a data frame with the help of square brackets [ ]. By using a comma, you can indicate what to select from the rows and the columns respectively. For example:\n\nmy_df[1,2] selects the value at the first row and second column in my_df.\nmy_df[1:3,2:4] selects rows 1, 2, 3 and columns 2, 3, 4 in my_df.\n\nSometimes you want to select all elements of a row or column. For example, my_df[1, ] selects all elements of the first row. Let us now apply this technique on planets_df!\nSteps\n\nFrom planets_df, select the diameter of Mercury: this is the value at the first row and the third column. Simply print out the result.\nFrom planets_df, select all data on Mars (the fourth row). Simply print out the result.\n\n\n## The planets_df data frame from the previous exercise is pre-loaded\n\n## Print out diameter of Mercury (row 1, column 3)\nplanets_df[1,3]\n\n[1] 0.382\n\n## Print out data for Mars (entire fourth row)\nplanets_df[4,]\n\n\n\n\n\n\nname\ntype\ndiameter\nrotation\nrings\n\n\n\n\n4\nMars\nTerrestrial planet\n0.532\n1.03\nFALSE\n\n\n\n\n\n\nGreat! Apart from selecting elements from your data frame by index, you can also use the column names. To learn how, head over to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-data-frame-elements-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selection-of-data-frame-elements-2",
    "title": "Introduction to R",
    "section": "Selection of data frame elements (2)",
    "text": "Selection of data frame elements (2)\nInstead of using numerics to select elements of a data frame, you can also use the variable names to select columns of a data frame. Suppose you want to select the first three elements of the type column. One way to do this is\n\nplanets_df[1:3,2]\n\nA possible disadvantage of this approach is that you have to know (or look up) the column number of type, which gets hard if you have a lot of variables. It is often easier to just make use of the variable name:\n\nplanets_df[1:3,\"type\"]\n\nSteps\n\nSelect and print out the first 5 values in the \"diameter\" column of planets_df.\n\n\n## Select first 5 values of diameter column\nplanets_df[1:5, \"diameter\"]\n\n[1]  0.382  0.949  1.000  0.532 11.209"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings",
    "title": "Introduction to R",
    "section": "Only planets with rings",
    "text": "Only planets with rings\nYou will often want to select an entire column, namely one specific variable from a data frame. If you want to select all elements of the variable diameter, for example, both of these will do the trick:\n\nplanets_df[,3]\nplanets_df[,\"diameter\"]\n\nHowever, there is a short-cut. If your columns have names, you can use the $ sign:\n\nplanets_df$diameter\n\nSteps\n\nUse the $ sign to select the rings variable from planets_df. Store the vector that results as rings_vector.\nPrint out rings_vector to see if you got it right.\n\n\n## Select the rings variable from planets_df\nrings_vector <- planets_df$rings\n  \n## Print out rings_vector\nrings_vector\n\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nGreat! Continue to the next exercise and discover yet another way of subsetting!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings-2",
    "title": "Introduction to R",
    "section": "Only planets with rings (2)",
    "text": "Only planets with rings (2)\nYou probably remember from high school that some planets in our solar system have rings and others do not. Unfortunately you can not recall their names. Could R help you out?\nIf you type rings_vector in the console, you get:\n\n#> [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nThis means that the first four observations (or planets) do not have a ring (FALSE), but the other four do (TRUE). However, you do not get a nice overview of the names of these planets, their diameter, etc. Let’s try to use rings_vector to select the data for the four planets with rings.\nSteps\n\nThe code in the editor selects the name column of all planets that have rings. Adapt the code so that instead of only the name column, all columns for planets that have rings are selected.\n\n\n## Adapt the code to select all columns for planets with rings\nplanets_df[rings_vector,]\n\n\n\n\n\n\nname\ntype\ndiameter\nrotation\nrings\n\n\n\n\n5\nJupiter\nGas giant\n11.209\n0.41\nTRUE\n\n\n6\nSaturn\nGas giant\n9.449\n0.43\nTRUE\n\n\n7\nUranus\nGas giant\n4.007\n-0.72\nTRUE\n\n\n8\nNeptune\nGas giant\n3.883\n0.67\nTRUE\n\n\n\n\n\n\nWonderful! This is a rather tedious solution. The next exercise will teach you how to do it in a more concise way."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings-but-shorter",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#only-planets-with-rings-but-shorter",
    "title": "Introduction to R",
    "section": "Only planets with rings but shorter",
    "text": "Only planets with rings but shorter\nSo what exactly did you learn in the previous exercises? You selected a subset from a data frame (planets_df) based on whether or not a certain condition was true (rings or no rings), and you managed to pull out all relevant data. Pretty awesome! By now, NASA is probably already flirting with your CV ;-).\nNow, let us move up one level and use the function subset(). You should see the subset() function as a short-cut to do exactly the same as what you did in the previous exercises.\n\nsubset(my_df, subset = some_condition)\n\nThe first argument of subset() specifies the dataset for which you want a subset. By adding the second argument, you give R the necessary information and conditions to select the correct subset.\nThe code below will give the exact same result as you got in the previous exercise, but this time, you didn’t need the rings_vector!\n\nsubset(planets_df, subset = rings)\n\nSteps\n\nUse subset() on planets_df to select planets that have a diameter smaller than Earth. Because the diameter variable is a relative measure of the planet’s diameter w.r.t that of planet Earth, your condition is diameter < 1.\n\n\n## Select planets with diameter < 1\nsubset(planets_df, subset = diameter <1)\n\n\n\n\n\n\nname\ntype\ndiameter\nrotation\nrings\n\n\n\n\n1\nMercury\nTerrestrial planet\n0.382\n58.64\nFALSE\n\n\n2\nVenus\nTerrestrial planet\n0.949\n-243.02\nFALSE\n\n\n4\nMars\nTerrestrial planet\n0.532\n1.03\nFALSE\n\n\n\n\n\n\nGreat! Not only is the subset() function more concise, it is probably also more understandable for people who read your code. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#sorting",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#sorting",
    "title": "Introduction to R",
    "section": "Sorting",
    "text": "Sorting\nMaking and creating rankings is one of mankind’s favorite affairs. These rankings can be useful (best universities in the world), entertaining (most influential movie stars) or pointless (best 007 look-a-like).\nIn data analysis you can sort your data according to a certain variable in the dataset. In R, this is done with the help of the function order().\norder() is a function that gives you the ranked position of each element when it is applied on a variable, such as a vector for example:\n\na <- c(100, 10, 1000)\norder(a)\n#> [1] 2 1 3\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\n10, which is the second element in a, is the smallest element, so 2 comes first in the output of order(a). 100, which is the first element in a is the second smallest element, so 1 comes second in the output of order(a).\nThis means we can use the output of order(a) to reshuffle a:\n\na[order(a)]\n#> [1]   10  100 1000\n\nCreated on 2022-01-18 by the reprex package (v2.0.1)\nSteps\n\nExperiment with the order() function in the console. Submit the answer when you are ready to continue.\n\n\n## Play around with the order function in the console\nvektor1 <- c(5, 2, 8)\nvektor1\n\n[1] 5 2 8\n\nvektor1[order(vektor1)]\n\n[1] 2 5 8\n\n\nGreat! Now let’s use the order() function to sort your data frame!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#sorting-your-data-frame",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#sorting-your-data-frame",
    "title": "Introduction to R",
    "section": "Sorting your data frame",
    "text": "Sorting your data frame\nAlright, now that you understand the order() function, let us do something useful with it. You would like to rearrange your data frame such that it starts with the smallest planet and ends with the largest one. A sort on the diameter column.\nSteps\n\nCall order() on planets_df$diameter (the diameter column of planets_df). Store the result as positions.\nNow reshuffle planets_df with the positions vector as row indexes inside square brackets. Keep all columns. Simply print out the result.\n\n\n## Use order() to create positions\npositions <- order(planets_df$diameter)\n\n## Use positions to sort planets_df\nplanets_df[positions,]\n\n\n\n\n\n\nname\ntype\ndiameter\nrotation\nrings\n\n\n\n\n1\nMercury\nTerrestrial planet\n0.382\n58.64\nFALSE\n\n\n4\nMars\nTerrestrial planet\n0.532\n1.03\nFALSE\n\n\n2\nVenus\nTerrestrial planet\n0.949\n-243.02\nFALSE\n\n\n3\nEarth\nTerrestrial planet\n1.000\n1.00\nFALSE\n\n\n8\nNeptune\nGas giant\n3.883\n0.67\nTRUE\n\n\n7\nUranus\nGas giant\n4.007\n-0.72\nTRUE\n\n\n6\nSaturn\nGas giant\n9.449\n0.43\nTRUE\n\n\n5\nJupiter\nGas giant\n11.209\n0.41\nTRUE\n\n\n\n\n\n\nWonderful! This exercise concludes the chapter on data frames. Remember that data frames are extremely important in R, you will need them all the time. Another very often used data structure is the list. This will be the subject of the next chapter!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#lists-why-would-you-need-them",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#lists-why-would-you-need-them",
    "title": "Introduction to R",
    "section": "Lists, why would you need them?",
    "text": "Lists, why would you need them?\nCongratulations! At this point in the course you are already familiar with:\n\nVectors (one dimensional array): can hold numeric, character or logical values. The elements in a vector all have the same data type.\nMatrices (two dimensional array): can hold numeric, character or logical values. The elements in a matrix all have the same data type.\nData frames (two-dimensional objects): can hold numeric, character or logical values. Within a column all elements have the same data type, but different columns can be of different data type.\n\nPretty sweet for an R newbie, right? ;-)"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#lists-why-would-you-need-them-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#lists-why-would-you-need-them-2",
    "title": "Introduction to R",
    "section": "Lists, why would you need them? (2)",
    "text": "Lists, why would you need them? (2)\nA list in R is similar to your to-do list at work or school: the different items on that list most likely differ in length, characteristic, and type of activity that has to be done.  A list in R allows you to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way.\nYou could say that a list is some kind super data type: you can store practically any piece of information in it!"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-list",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-list",
    "title": "Introduction to R",
    "section": "Creating a list",
    "text": "Creating a list\nLet us create our first list! To construct a list you use the function list(): \n\nmy_list <- list(comp1, comp2, ...)\n\nThe arguments to the list function are the list components. Remember, these components can be matrices, vectors, other lists, …\nSteps\n\nConstruct a list, named my_list, that contains the variables my_vector, my_matrix and my_df as list components.\n\n\n## Vector with numerics from 1 up to 10\nmy_vector <- 1:10 \n\n## Matrix with numerics from 1 up to 9\nmy_matrix <- matrix(1:9, ncol = 3)\n\n## First 10 elements of the built-in data frame mtcars\nmy_df     <- mtcars[1:10,]\n\n## Construct list with these different elements:\nmy_list   <- list(my_vector, my_matrix, my_df)"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-named-list",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-named-list",
    "title": "Introduction to R",
    "section": "Creating a named list",
    "text": "Creating a named list\nWell done, you’re on a roll!\nJust like on your to-do list, you want to avoid not knowing or remembering what the components of your list stand for. That is why you should give names to them:\n\nmy_list <- list(name1 = your_comp1, \n                name2 = your_comp2)\n\nThis creates a list with components that are named name1, name2, and so on. If you want to name your lists after you’ve created them, you can use the names() function as you did with vectors. The following commands are fully equivalent to the assignment above:\n\nmy_list <- list(your_comp1, your_comp2)\nnames(my_list) <- c(\"name1\", \"name2\")\n\nSteps\n\nChange the code of the previous exercise (see editor) by adding names to the components. Use for my_vector the name vec, for my_matrix the name mat and for my_df the name df.\nPrint out my_list so you can inspect the output.\n\n\n## Adapt list() call to give the components names\nmy_list <- list(vec = my_vector, mat = my_matrix, df = my_df)\n\n## Print out my_list\nmy_list\n\n$vec\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$mat\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n$df\n                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n\n\nGreat! Not only do you know how to construct lists now, you can also name them; a skill that will prove most useful in practice. Continue to the next exercise."
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-named-list-2",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-named-list-2",
    "title": "Introduction to R",
    "section": "Creating a named list (2)",
    "text": "Creating a named list (2)\nBeing a huge movie fan (remember your job at LucasFilms), you decide to start storing information on good movies with the help of lists.\nStart by creating a list for the movie “The Shining”. We have already created the variables mov, act and rev in your R workspace. Feel free to check them out in the console.\nSteps\n\nComplete the code in the editor to create shining_list; it contains three elements:\n\nmoviename: a character string with the movie title (stored in mov)\nactors: a vector with the main actors’ names (stored in act)\nreviews: a data frame that contains some reviews (stored in rev)\n\n\nDo not forget to name the list components accordingly (names are moviename, actors and reviews).\n\n## The variables mov, act and rev are available\nmov <- \"The Shining\"\nact <- c(\"Jack Nicholson\",\"Shelley Duvall\",\"Danny Lloyd\",\"Scatman Crothers\",\"Barry Nelson\")\nrev <- data.frame(scores   = c(4.5,4.0,5.0),\n                  sources  = c(\"IMDB1\", \"IMDB2\", \"IMDB3\"),\n                  comments = c(\"Best Horror Film I Have Ever Seen\", \"A truly brilliant and scary film from Stanley Kubrick\", \"A masterpiece of psychological horror\"))\n\n## Finish the code to build shining_list\nshining_list <- list(moviename = mov, actors = act, reviews = rev)\n\nWonderful! You now know how to construct and name lists. As in the previous chapters, let’s look at how to select elements for lists. Head over to the next exercise"
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#selecting-elements-from-a-list",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#selecting-elements-from-a-list",
    "title": "Introduction to R",
    "section": "Selecting elements from a list",
    "text": "Selecting elements from a list\nYour list will often be built out of numerous elements and components. Therefore, getting a single element, multiple elements, or a component out of it is not always straightforward.\nOne way to select a component is using the numbered position of that component. For example, to “grab” the first component of shining_list you type\n\nshining_list[[1]]\n\nA quick way to check this out is typing it in the console. Important to remember: to select elements from vectors, you use single square brackets: [ ]. Don’t mix them up!\nYou can also refer to the names of the components, with [[ ]] or with the $ sign. Both will select the data frame representing the reviews:\n\nshining_list[[\"reviews\"]]\nshining_list$reviews\n\nBesides selecting components, you often need to select specific elements out of these components. For example, with shining_list[[2]][1] you select from the second component, actors (shining_list[[2]]), the first element ([1]). When you type this in the console, you will see the answer is Jack Nicholson.\nSteps\n\nSelect from shining_list the vector representing the actors. Simply print out this vector.\nSelect from shining_list the second element in the vector representing the actors. Do a printout like before.\n\n\n## Print out the vector representing the actors\nshining_list$actors\n\n[1] \"Jack Nicholson\"   \"Shelley Duvall\"   \"Danny Lloyd\"      \"Scatman Crothers\"\n[5] \"Barry Nelson\"    \n\n## Print the second element of the vector representing the actors\nshining_list[[2]][2]\n\n[1] \"Shelley Duvall\""
  },
  {
    "objectID": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-new-list-for-another-movie",
    "href": "content/R/topics/01_basics/01_programming_beginner.html#creating-a-new-list-for-another-movie",
    "title": "Introduction to R",
    "section": "Creating a new list for another movie",
    "text": "Creating a new list for another movie\nYou found reviews of another, more recent, Jack Nicholson movie: The Departed!\n\n\n\nScores\nComments\n\n\n\n\n4.6\nI would watch it again\n\n\n5.0\nAmazing!\n\n\n4.8\nI liked it\n\n\n5.0\nOne of the best movies\n\n\n4.2\nFascinating plot\n\n\n\nIt would be useful to collect together all the pieces of information about the movie, like the title, actors, and reviews into a single variable. Since these pieces of data are different shapes, it is natural to combine them in a list variable.\nmovie_title, containing the title of the movie, and movie_actors, containing the names of some of the actors in the movie, are available in your workspace.\nSteps\n\nCreate two vectors, called scores and comments, that contain the information from the reviews shown in the table.\nFind the average of the scores vector and save it as avg_review.\nCombine the scores and comments vectors into a data frame called reviews_df.\nCreate a list, called departed_list, that contains the movie_title, movie_actors, reviews data frame as reviews_df, and the average review score as avg_review, and print it out.\n\n\n## Use the table from the exercise to define the comments and scores vectors\nscores       <- c(4.6, 5, 4.8, 5, 4.2)\ncomments     <- c(\"I would watch it again\", \"Amazing!\", \"I liked it\", \"One of the best movies\", \"Fascinating plot\")\nmovie_title  <- \"The Departed\"\nmovie_actors <- c(\"Leonardo DiCaprio\", \"Matt Damon\", \"Jack Nicholson\", \"Mark Wahlberg\", \"Vera Farmiga\", \"Martin Sheen\")\n\n## Save the average of the scores vector as avg_review  \navg_review <- mean(scores)\n\n## Combine scores and comments into the reviews_df data frame\nreviews_df <- data.frame(scores, comments)\n\n## Create and print out a list, called departed_list\ndeparted_list <- list(movie_title, movie_actors, reviews_df, avg_review)\ndeparted_list\n\n[[1]]\n[1] \"The Departed\"\n\n[[2]]\n[1] \"Leonardo DiCaprio\" \"Matt Damon\"        \"Jack Nicholson\"   \n[4] \"Mark Wahlberg\"     \"Vera Farmiga\"      \"Martin Sheen\"     \n\n[[3]]\n  scores               comments\n1    4.6 I would watch it again\n2    5.0               Amazing!\n3    4.8             I liked it\n4    5.0 One of the best movies\n5    4.2       Fascinating plot\n\n[[4]]\n[1] 4.72\n\n\nGood work! You successfully created another list of movie information, and combined different components into a single list. Congratulations on finishing the course!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "",
    "text": "Short Description\nLearn to use facets, coordinate systems and statistics in ggplot2 to create meaningful explanatory plots.\nLong Description\nThis ggplot2 course builds on your knowledge from the introductory course to produce meaningful explanatory plots. Statistics will be calculated on the fly and you’ll see how Coordinates and Facets aid in communication. You’ll also explore details of data visualization best practices with ggplot2 to help make sure you have a sound understanding of what works and why. By the end of the course, you’ll have all the tools needed to make a custom plotting function to explore a large data set, combining statistics and excellent visuals."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-with-geoms",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-with-geoms",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Stats with geoms",
    "text": "Stats with geoms\nTheory. Coming soon …\n1. Stats with geoms\nWelcome to the second ggplot2 course on data visualization! Here, we’re going to build on the skills you learned in the first course to develop a wide variety of plots that are not only appealing, but also meaningful.\n2. ggplot2, course 2\nWe’ll examine the following three layers in detail: statistics, coordinates, and facets, plus, we’ll review some data viz tips so that you can make the most of your new skill-set.Let’s get started with the stats layer.\n3. Statistics layer\nThere are two broad categories of functions in this family: those that are called from within a geom and those that are called independently.As you may have guessed, all the statistical functions begin with “stats”, followed by an underscore. Even those called from within the geom layer can be accessed independently in this way.\n4. geom_ <-> stat_\nWe already saw a stats function when we used geom_histogram. Recall that under the hood, this called stat_bin to summarize the total count in each group.\n5. geom_ <-> stat_\nYou may also remember that when we discussed geom_bar, I mentioned that it’s default stat is set to “bin” – so we could have produced the same result if we use geom_bar!\n6. geom_ <-> stat_\nThe same thing happens with geom_bar, which just calls stat_count under the hood. If we called stat_count directly, we’d get the same plot since it would call geom_bar.\n7. The geom_/stat_ connection\nSo we can see that specific geoms and stat functions are related.\n8. stat_smooth()\nstat_smooth can accessed with geom_smooth, shown here. The standard error, which is shown as a gray ribbon behind our smooth, is by default, a 95% confidence interval.\n9. stat_smooth(se = FALSE)\nWe can remove this by setting the se argument to FALSE.We know we are calling stat_smooth because of another warning message: “geom_smooth is using method equal to loess, and formula y dependent on x”.LOESS is a non-parametric smoothing algorithm that is used when we have less than 1000 observations. It works by calculating a weighted mean by passing a sliding window along the x-axis and is a valuable tool in exploratory data analysis.\n10. geom_smooth(span = 0.4)\nThe span argument controls the degree of smoothing, which is the size of the sliding window. Smaller spans are more noisy, as we can see here.\n11. geom_smooth(method = “lm”)\nThe method argument can also define parametric models, such as “lm”, as shown here, or “glm”, “rlm” and “gam”. For groups larger than one thousand, the method defaults to gam. Notice that in both the LOESS and LM examples, the model is calculated on groups defined by color. We’ll look at how to override this in the exercises.\n12. geom_smooth(fullrange = TRUE)\nBy default, each model is bound to the limits of its own group, but for parametric methods, we can use the fullrange argument to make predictions over the entire range. Just as we’d expect, the error increases the further away from our data set we attempt to define an estimate.\n13. The geom_/stat_ connection\nWe can access smoothing using the geom smooth function or the stat smooth function.\n14. Other stat_ functions\nThere are many other stats functions which we will encounter throughout the rest of the data visualization courses, some of which are particularly useful for summarizing data, like boxplots,\n15. Other stat_ functions\nor dealing with very large data sets, such as bindot, binhex, bin2d and contour - we’ll encounter those in the next course when we consider graphics of large datasets.\n16. Other stat_ functions\nWe’ll encounter other functions throughout the exercises.In general, you won’t have to call these functions directly, but it is worth knowing about the relationship between geoms and their respective statistics. You’ll understand warning and error messages better and the help pages for the stats functions are often more informative if you need to adjust any parameters.\n17. Let’s practice!\nOK, let’s see how stat functions work in practice in the exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#smoothing",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#smoothing",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Smoothing",
    "text": "Smoothing\nTo practice on the remaining layers (statistics, coordinates and facets), we’ll continue working on several datasets.\nThe mtcars dataset contains information for 32 cars from Motor Trends magazine from 1974. This dataset is small, intuitive, and contains a variety of continuous and categorical (both nominal and ordinal) variables.\nIn the previous course you learned how to effectively use some basic geometries, such as point, bar and line. In the first chapter of this course you’ll explore statistics associated with specific geoms, for example, smoothing and lines.\nSteps\n\nLook at the structure of mtcars.\n\n\n# View the structure of mtcars\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\n\nUsing mtcars, draw a scatter plot of mpg vs. wt.\n\n\n# Using mtcars, draw a scatter plot of mpg vs. wt\nlibrary(magrittr)\nlibrary(ggplot2)\nmtcars %>% \n    ggplot(aes(wt, mpg)) +\n    geom_point()\n\n\n\n\n\nUpdate the plot to add a smooth trend line. Use the default method, which uses the LOESS model to fit the curve.\n\n\n# Amend the plot to add a smooth layer\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\nUpdate the smooth layer. Apply a linear model by setting method to \"lm\", and turn off the model’s 95% confidence interval (the ribbon) by setting se to FALSE.\n\n\n# Amend the plot. Use lin. reg. smoothing; turn off std err ribbon\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nDraw the same plot again, swapping geom_smooth() for stat_smooth().\n\n\n# Amend the plot. Swap geom_smooth() for stat_smooth().\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  stat_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nGood job! You can use either stat_smooth() or geom_smooth() to apply a linear model. Remember to always think about how the examples and concepts we discuss throughout the data viz courses can be applied to your own datasets!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#grouping-variables",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#grouping-variables",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Grouping variables",
    "text": "Grouping variables\nWe’ll continue with the previous exercise by considering the situation of looking at sub-groups in our dataset. For this we’ll encounter the invisible group aesthetic.\nmtcars has been given an extra column, fcyl, that is the cyl column converted to a proper factor variable.\nSteps\n\nUsing mtcars, plot mpg vs. wt, colored by fcyl.\n\nAdd a point layer.\nAdd a smooth stat using a linear model, and don’t show the se ribbon.\n\n\n\n# data\nlibrary(dplyr, warn.conflicts = F)\nlibrary(forcats)\nmtcars <- mtcars |> \n            mutate(fcyl = as_factor(cyl))\n\n# Using mtcars, plot mpg vs. wt, colored by fcyl\nggplot(mtcars, aes(wt, mpg, color = fcyl)) +\n  # Add a point layer\n  geom_point() +\n  # Add a smooth lin reg stat, no ribbon\n  stat_smooth(method = \"lm\", se=F)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nUpdate the plot to add a second smooth stat.\n\nAdd a dummy group aesthetic to this layer, setting the value to 1.\nUse the same method and se values as the first stat smooth layer.\n\n\n\n# Amend the plot to add another smooth layer with dummy grouping\nggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +\n  geom_point() +\n  stat_smooth(method = \"lm\", se = FALSE) +\n  stat_smooth(aes(group = 1), method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\nGood job! Notice that the color aesthetic defined an invisible group aesthetic. Defining the group aesthetic for a specific geom means we can overwrite that. Here, we use a dummy variable to calculate the smoothing model for all values."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#modifying-stat_smooth",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#modifying-stat_smooth",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Modifying stat_smooth",
    "text": "Modifying stat_smooth\nIn the previous exercise we used se = FALSE in stat_smooth() to remove the 95% Confidence Interval. Here we’ll consider another argument, span, used in LOESS smoothing, and we’ll take a look at a nice scenario of properly mapping different models.\nSteps\n\nExplore the effect of the span argument on LOESS curves. Add three smooth LOESS stats, each without the standard error ribbon.\n\nColor the 1st one \"red\"; set its span to 0.9.\nColor the 2nd one \"green\"; set its span to 0.6.\nColor the 3rd one \"blue\"; set its span to 0.3.\n\n\n\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  # Add 3 smooth LOESS stats, varying span & color\n  stat_smooth(se = F, color = \"red\", span = 0.9) +\n  stat_smooth(se = F, color = \"green\", span = 0.6) +\n  stat_smooth(se = F, color = \"blue\", span = 0.3)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\nCompare LOESS and linear regression smoothing on small regions of data.\n\nAdd a smooth LOESS stat, without the standard error ribbon.\nAdd a smooth linear regression stat, again without the standard error ribbon.\n\n\n\n# Amend the plot to color by fcyl\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  # Add a smooth LOESS stat, no ribbon\n  stat_smooth(se=F) +\n  # Add a smooth lin. reg. stat, no ribbon\n  stat_smooth(method = \"lm\", se=F)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nLOESS isn’t great on very short sections of data; compare the pieces of linear regression to LOESS over the whole thing.\n\nAmend the smooth LOESS stat to map color to a dummy variable, \"All\".\n\n\n\n# Amend the plot\nggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +\n  geom_point() +\n  # Map color to dummy variable \"All\"\n  stat_smooth(aes(color = \"All\"), se = FALSE) +\n  stat_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nSpantastic! The default span for LOESS is 0.9. A lower span will result in a better fit with more detail; but don’t overdo it or you’ll end up over-fitting!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#modifying-stat_smooth-2",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#modifying-stat_smooth-2",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Modifying stat_smooth (2)",
    "text": "Modifying stat_smooth (2)\nIn this exercise we’ll take a look at the standard error ribbons, which show the 95% confidence interval of smoothing models. ggplot2 and the Vocab data frame are already loaded for you.\nVocab has been given an extra column, year_group, splitting the dates into before and after 1995.\nSteps\n\nUsing Vocab, plot vocabulary vs. education, colored by year_group.\n\nUse geom_jitter() to add jittered points with transparency 0.25.\nAdd a smooth linear regression stat (with the standard error ribbon).\n\n\n\n# data\nlibrary(car,warn.conflicts = F, quietly = T)\ndata(Vocab)\n# Splitting the dates into before and after 1995. \nVocab <- Vocab |> \n            as_tibble() |> \n            mutate(year_group = cut(year, breaks = c(1974, 1995, 2016), dig.lab = 4, include.lowest = T))\n\n# Using Vocab, plot vocabulary vs. education, colored by year group\nggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +\n  # Add jittered points with transparency 0.25\n  geom_jitter(alpha = 0.25) +\n  # Add a smooth lin. reg. line (with ribbon)\n  stat_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nIt’s easier to read the plot if the standard error ribbons match the lines, and the lines have more emphasis.\n\nUpdate the smooth stat.\n\nMap the fill color to year_group.\nSet the line size to 2.\n\n\n\n\n# Amend the plot\nggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +\n  geom_jitter(alpha = 0.25) +\n  # Map the fill color to year_group, set the line size to 2\n  stat_smooth(aes(fill = year_group), method = \"lm\", size = 2)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nYou have a vast plotting vocabulary! Notice that since 1995, education has relatively smaller effect on increasing vocabulary."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-sum-and-quantile",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-sum-and-quantile",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Stats: sum and quantile",
    "text": "Stats: sum and quantile\nTheory. Coming soon …\n1. Stats: sum and quantile\nLet’s wrap up our discussion of stats called from within geoms by looking at two more useful functions: geom_count and geom_quantile\n2. Recall from course 1\nIn the first course we saw that over-plotting is always a concern whenever we use geom point. Every data point must be visible. We discussed four ways in which our visualizations may mislead us.\n3. Plot counts to overcome over-plotting\nWe can now add a new geom function to our solutions for low precision and integer data: geom_count plot the count at each location. In course 3, we’ll see even more elegant solutions that can be applied to all four situations.Let’s look at an example with geom_count.\n4. Low precision (& integer) data\nIn the iris data set, where we have low-precision data, jittering gives the impression that we have more precision that we actually do.\n5. Jittering may give a wrong impressions\nWe should always mention that we’ve jittered our data because of this.\n6. geom_count()\nTo avoid this problem, we can use another variant of geom_point. geom_count counts the number of observations at each location and then maps the count onto size as the point area.Our data is mapped onto the area of the circle, as opposed to its radius, since we more intuitively perceive area than radius.\n7. The geom/stat connection\nRemember that these geoms are associated with stats functions that can be called directly, as shown here.\n8. stat_sum()\nCalling the stat function gives the exact same plot.We’ll see this trick used with integer data in the exercises, which is a very common use.\n9. Over-plotting can still be a problem!\nBut be careful here, you’ll still encounter over-plotting if the points are colored according to another variable. This makes it particularly difficult to read the plot!\n10. geom_quantile()\nThe last function I want to look at in this section is geom_quantile. It’s another great tool for describing our data. This method allows us to model quantiles, which are robust, as opposed to linear models, which model the non-robust mean.We can choose any quantile we’re interested in, such as the median, which is just the second quartile. A typical case of using quantile regression would be when you have heteroscedasticity, that is the variance across the predictor variable is not consistent, in which case linear models may not be valid.\n11. Dealing with heteroscedasticity\nHere’s an example of heteroscedasticity from a dataset of economics journals from the AER package. We won’t get into the details of the data, but you can see that variance on the y axis is not consistent as we move along x axis.\n12. Using geom_quantiles\nHere, we can use geom_quantile to model the 5th and the 95th percentile as well as the median, the 50th percentile.\n13. The geom/stat connection\nJust like the previous geoms, this is also associated with a stats function that we can actually call directly.\n14. Ready for exercises!\nLet’s take these functions for a spin with some exercises!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#quantiles",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#quantiles",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Quantiles",
    "text": "Quantiles\nHere, we’ll continue with the Vocab dataset and use stat_quantile() to apply a quantile regression.\nLinear regression predicts the mean response from the explanatory variables, quantile regression predicts a quantile response (e.g. the median) from the explanatory variables. Specific quantiles can be specified with the quantiles argument.\nSpecifying many quantiles and color your models according to year can make plots too busy. We’ll explore ways of dealing with this in the next chapter.\nSteps\n\nUpdate the plot to add a quantile regression stat, at quantiles 0.05, 0.5, and 0.95.\n\n\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  geom_jitter(alpha = 0.25) +\n  # Add a quantile stat, at 0.05, 0.5, and 0.95\n  stat_quantile(quantiles = c(0.05, 0.5, 0.95))\n\nSmoothing formula not specified. Using: y ~ x\n\n\n\n\n\n\nAmend the plot to color according to year_group.\n\n\n# Amend the plot to color by year_group\nggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +\n  geom_jitter(alpha = 0.25) +\n  stat_quantile(aes(color = year_group), quantiles = c(0.05, 0.5, 0.95))\n\nSmoothing formula not specified. Using: y ~ x\nSmoothing formula not specified. Using: y ~ x\n\n\nWarning in rq.fit.br(wx, wy, tau = tau, ...): Solution may be nonunique\n\n\n\n\n\nQuick quantiles! Quantile regression is a great tool for getting a more detailed overview of a large dataset."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#using-stat_sum",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#using-stat_sum",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Using stat_sum",
    "text": "Using stat_sum\nIn the Vocab dataset, education and vocabulary are integer variables. In the first course, you saw that this is one of the four causes of overplotting. You’d get a single point at each intersection between the two variables.\nOne solution, shown in the step 1, is jittering with transparency. Another solution is to use stat_sum(), which calculates the total number of overlapping observations and maps that onto the size aesthetic.\nstat_sum() allows a special variable, ..prop.., to show the proportion of values within the dataset.\nSteps\n\nRun the code to see how jittering & transparency solves overplotting.\nReplace the jittered points with a sum stat, using stat_sum().\n\n\n# Run this, look at the plot, then update it\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  # Replace this with a sum stat\n  stat_sum(alpha = 0.25)\n\n\n\n\n\nModify the size aesthetic with the appropriate scale function.\n\nAdd a scale_size() function to set the range from 1 to 10.\n\n\n\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  stat_sum() +\n  # Add a size scale, from 1 to 10\n  scale_size(range=c(1,10))\n\n\n\n\n\nInside stat_sum(), set size to ..prop.. so circle size represents the proportion of the whole dataset.\n\n\n# Amend the stat to use proportion sizes\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  stat_sum(aes(size = ..prop..))\n\nWarning: The dot-dot notation (`..prop..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\n\nUpdate the plot to group by education, so that circle size represents the proportion of the group.\n\n\n# Amend the plot to group by education\nggplot(Vocab, aes(x = education, y = vocabulary, group = education)) +\n  stat_sum(aes(size = ..prop..))\n\n\n\n\nSuperb stat summing! If a few data points overlap, jittering is great. When you have lots of overlaps (particularly where continuous data has been rounded), using stat_sum() to count the overlaps is more useful."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-outside-geoms",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#stats-outside-geoms",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Stats outside geoms",
    "text": "Stats outside geoms\nTheory. Coming soon …\n1. Stats outside geoms\nLet’s take a look at some statistics that we call directly.\n2. Basic plot\nIn this plot of the iris dataset, sepal length is described by species.What can we do with this data?\n3. Calculating statistics\nA typical way to summarize this data would be to take the mean and standard deviation or the 95% confidence interval.We can calculate these values manually, or we can do it directly in ggplot2.Let’s see how it works.\n4. Calculating statistics\nThe function smean-dot-sdl from the Hmisc package returns the mean plus or minus one standard deviation as a named vector. By setting the mult argument to 1, we specify 1 standard deviation.In ggplot2, the function mean_sdl converts this vector to a data frame, renaming the variables to match ggplot2 aesthetics.\n5. stat_summary()\nWe call mean_sdl using the fun.data argument of the stat_summary function. By default we get geom_pointrange, which requires y, ymin and ymax, exactly what is returned by mean_sdl.\n6. stat_summary()\nFor errorbars, we can just calculate the mean and use “point” as the geom, then we can call mean_sdl using the “errorbar” geom, where we can also set the width of the error bars.\n7. stat_summary()\nBut notice that we could have also made a typical bar plot with error bars, by simply calling the bar geom - but this is NOT RECOMMENDED! We’ll learn why when we get to data viz best practices later on!\n8. 95% confidence interval\nThe 95% CI is also straight forward. mean_cl_normal returns the mean and the upper and lower bounds of the 95% confidence interval, calculated using the t-distribution.\n9. Other stat_ functions\nTwo other useful stat_layer functions are stat_function and stat_qq. These are particularly useful if we want to look at distributions.Statisticians typically use visual cues to get an idea of the distribution of their data instead of relying only on numbers.\n10. MASS::mammals\nTo see this in action let’s return to the first example we used in the first course - the mammalian body and brain weights stored in the mammals data frame. We mentioned that our linear model fitted the log10 transformed data reasonably well. What we mean is that the log transformed data appears to be normally distributed, so let’s take a look at that in detail.\n11. Normal distribution\nFor stat_function, we can specify any function and produce the theoretical probability distribution as a line. Here, we call a normal distribution, that’s dnorm, and add arguments as a list to centered it on our distribution, that’s the mean and the sd). This allows us to compare how well our data is normally distributed. The log10 mammalian body weight is described by a log normal curve very well. Notice that we have another geom here, geom_rug, which adds those little tick marks on the bottom of the plot. This is a handy way of seeing the actual values in combination with a summary distribution.An empirical density plot, would be an nice alternative to the histogram, but we’ll get to that in the next course.\n12. QQ plot\nQQ plots also allows us to compare our data to a distribution. In this case, we plot our sample against the theoretical distribution, like the normal, and draw a line intersecting the scatter plot at the first and third quartiles. The closer that our data aligns to this line, the more closely it matches the theoretical distribution in question.\n13. Your turn!\nThere are more stat_ functions which are available for you to explore during the exercises, so let’s take a look."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#preparations",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#preparations",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Preparations",
    "text": "Preparations\nIn the following exercises, we’ll aim to make the plot shown in the viewer. Here, we’ll establish our positions and base layer of the plot.\nEstablishing these items as independent objects will allow us to recycle them easily in many layers, or plots.\n\nposition_jitter() adds jittering (e.g. for points).\nposition_dodge() dodges geoms, (e.g. bar, col, boxplot, violin, errorbar, pointrange).\nposition_jitterdodge() jitters and dodges geoms, (e.g. points).\n\nAs before, we’ll use mtcars, where fcyl and fam are proper factor variables of the original cyl and am variables.\nSteps\n\nUsing these three functions, define these position objects:\n\nposn_j: will jitter with a width of 0.2.\nposn_d: will dodge with a width of 0.1.\nposn_jd will jitter and dodge with a jitter.width of 0.2 and a dodge.width of 0.1.\n\n\n\n# Define position objects\n# 1. Jitter with width 0.2\nposn_j <- position_jitter(width = 0.2)\n\n# 2. Dodge with width 0.1\nposn_d <- position_dodge(width = 0.1)   \n\n# 3. Jitter-dodge with jitter.width 0.2 and dodge.width 0.1\nposn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)\n\n\nPlot wt vs. fcyl, colored by fam. Assign this base layer to p_wt_vs_fcyl_by_fam.\n\nPlot the data using geom_point().\n\n\n\n#data\nmtcars <- mtcars |> \n            mutate(fam = as_factor(am))\n\n# Create the plot base: wt vs. fcyl, colored by fam\np_wt_vs_fcyl_by_fam <- ggplot(mtcars, aes(fcyl, wt, color = fam))\n\n# Add a point layer\np_wt_vs_fcyl_by_fam +\n  geom_point()\n\n\n\n\nPatient preparation! The default positioning of the points is highly susceptible to overplotting."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#using-position-objects",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#using-position-objects",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Using position objects",
    "text": "Using position objects\nNow that the position objects have been created, you can apply them to the base plot to see their effects. You do this by adding a point geom and setting the position argument to the position object.\nThe variables from the last exercise, posn_j, posn_d, posn_jd, and p_wt_vs_fcyl_by_fam are available in your workspace.\nSteps\n\nApply the jitter position, posn_j, to the base plot.\n\n\n# Add jittering only\np_wt_vs_fcyl_by_fam +\n  geom_point(position = posn_j) \n\n\n\n\n\nApply the dodge position, posn_d, to the base plot.\n\n\n# Add dodging only\np_wt_vs_fcyl_by_fam +\n  geom_point(position = posn_d)\n\n\n\n\n\nApply the jitter-dodge position, posn_jd, to the base plot.\n\n\n# Add jittering and dodging\np_wt_vs_fcyl_by_fam +\n  geom_point(position = posn_jd)\n\n\n\n\nPerfect positioning! Although you can set position by setting the position argument to a string (for example position = \"dodge\"), defining objects promotes consistency between layers."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#plotting-variations",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#plotting-variations",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Plotting variations",
    "text": "Plotting variations\nThe preparation is done; now let’s explore stat_summary().\nSummary statistics refers to a combination of location (mean or median) and spread (standard deviation or confidence interval).\nThese metrics are calculated in stat_summary() by passing a function to the fun.data argument. mean_sdl(), calculates multiples of the standard deviation and mean_cl_normal() calculates the t-corrected 95% CI.\nArguments to the data function are passed to stat_summary()’s fun.args argument as a list.\nThe position object, posn_d, and the plot with jittered points, p_wt_vs_fcyl_by_fam_jit, are available.\nSteps\n\nAdd error bars representing the standard deviation.\n\nSet the data function to mean_sdl (without parentheses).\nDraw 1 standard deviation each side of the mean, pass arguments to the mean_sdl() function by assigning them to fun.args in the form of a list.\nUse posn_d to set the position.\n\n\n\n# data\np_wt_vs_fcyl_by_fam_jit <- p_wt_vs_fcyl_by_fam +\n                            geom_jitter(width = 0.2)\n\np_wt_vs_fcyl_by_fam_jit +\n  # Add a summary stat of std deviation limits\n  stat_summary(\n    fun.data = mean_sdl,\n    fun.args = list(1),\n    position = posn_d\n\n  )\n\n\n\n\n\nThe default geom for stat_summary() is \"pointrange\" which is already great.\n\nUpdate the summary stat to use an \"errorbar\" geom by assigning it to the geom argument.\n\n\n\np_wt_vs_fcyl_by_fam_jit +\n  # Change the geom to be an errorbar\n  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d, geom = \"errorbar\")\n\n\n\n\n\nUpdate the plot to add a summary stat of 95% confidence limits.\n\nSet the data function to mean_cl_normal (without parentheses).\nAgain, use the dodge position.\n\n\n\np_wt_vs_fcyl_by_fam_jit +\n  # Add a summary stat of normal confidence limits\n  stat_summary(\n    fun.data = mean_cl_normal,\n    position=posn_d\n  )\n\n\n\n\nGood job! You can always assign your own function to the fun.data argument as long as the result is a data frame and the variable names match the aesthetics that you will need for the geom layer."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#coordinates-1",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#coordinates-1",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Coordinates",
    "text": "Coordinates\nTheory. Coming soon …\n1. The Coordinates Layer\nThe coord layer controls the dimensions of your plot.\n2. Coordinates layer\nThe coord layer is composed of functions named coord_. Let’s explore their propertiesThe most commonly used function is coord_cartesian, which controls the x-y Cartesian plane of your plot.\n3. Zooming in\nWe can use coord_cartesian to zoom in on a specific part of a plot. Alternatively, we could set the limits argument in scale_x_continuous or scale_y_continuous, or use an xlim or ylim function directly.\n4. Original plot\nConsider the following plot of the iris data. We’ve seen this plot in previous lessons. It plots sepal width against sepal length and draws a loess curve for each of our three iris species.\n5. scale_x_continuous()\nWhen we “zoomed in” to a small part of the x-axis using scale_x_continuous, we’re presented with some important warning messages. 95 rows have been removed. This happened because the limits we set in scale_x_continuous were a smaller range than the data and thus values were filtered out.\n6. scale_x_continuous()\nWe can see this on the new zoomed-in plot, since the LOESS model is only defined for the points shown, although there is data beyond this region. That’s also why the models look different.\n7. xlim()\nA quick and dirty alternative is to call xlim as a function itself. It has the same effect.\n8. coord_cartesian()\nContrast this to really zooming in using the coord_cartesian function. You can see the zoom because the LOESS curve continues past the data presented, and the models look the same as in the original plot.We haven’t filtered the data set, so if we did inadvertently cut off data values, it would not be clear simply from looking at the plot – unless we had some indicator such as a smoothing function.Changing the x and y limits can lead to unexpected consequences and should always be used with caution. Don’t recycle or hard code axis limits until you’ve seen the raw data.\n9. Aspect ratio\nAside from zooming in, another common role that you’ll achieve with the coordinates layer is changing the aspect ratio. When we say ‘aspect ratio’, we are referring to the height-to-width aspect ratio.Changing the aspect ratio of a plot is one of the most common ways in which people either inadvertently or purposely deceive – or are deceived – with visualizations. There is no systematic method for choosing an appropriate aspect ratio.The only rule to follow in this area is that, typically, we should use a 1:1 aspect ratio when the units of measure are the same, although there are some exceptions to this rule - for example, when the scales are the same, but their ranges differ widely.The aspect ratio is particularly important when it changes our perception or interpretation of the data.\n10. Sunspots\nIn this plot of over 250 years of sun spots data, there are three key trends. First, sun spots follow an 11-year oscillating cycle. Second, sun spot numbers also change over longer periods.However there is a third and subtle patten present in this time series, but it’s very difficult to see in this format.The aspect ratio here is 1:1, there are 250 units on the y and 265 units on the x. The physical distance for each unit in the same.\n11. Sunspots\nHowever, if we reduce the aspect ratio to something very low, like 0.055, we flatten the entire plot and notice something else.Sunspots arise more quickly than they disappear, a pattern that is more prevalent the higher the peak intensity in a given cycle is. Different trends are emphasized and the aspect ratio depends on what we are investigating or communicating.\n12. Practice time!\nOK, let’s head over to the exercises and look at coordinates in more detail."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#zooming-in",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#zooming-in",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Zooming In",
    "text": "Zooming In\nIn the video, you saw different ways of using the coordinates layer to zoom in. In this exercise, we’ll compare zooming by changing scales and by changing coordinates.\nThe big difference is that the scale functions change the underlying dataset, which affects calculations made by computed geoms (like histograms or smooth trend lines), whereas coordinate functions make no changes to the dataset.\nA scatter plot using mtcars with a LOESS smoothed trend line is provided. Take a look at this before updating it.\nSteps\n\nUpdate the plot by adding (+) a continuous x scale with limits from 3 to 6. Spoiler: this will cause a problem!\n\n\n# Run the code, view the plot, then update it\nggplot(mtcars, aes(x = wt, y = hp, color = fam)) +\n  geom_point() +\n  geom_smooth() \n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n  # Add a continuous x scale from 3 to 6\n  scale_x_continuous(limits = c(3, 6))\n\n<ScaleContinuousPosition>\n Range:  \n Limits:    3 --    6\n\n\n\nUpdate the plot by adding a Cartesian coordinate system with x limits, xlim, from 3 to 6.\n\n\nggplot(mtcars, aes(x = wt, y = hp, color = fam)) +\n  geom_point() +\n  geom_smooth() +\n  # Add Cartesian coordinates with x limits from 3 to 6\n  coord_cartesian(xlim = c(3,6))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nZesty zooming! Using the scale function to zoom in meant that there wasn’t enough data to calculate the trend line, and geom_smooth() failed. When coord_cartesian() was applied, the full dataset was used for the trend calculation."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#aspect-ratio-i-11-ratios",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#aspect-ratio-i-11-ratios",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Aspect ratio I: 1:1 ratios",
    "text": "Aspect ratio I: 1:1 ratios\nWe can set the aspect ratio of a plot with coord_fixed(), which uses ratio = 1 as a default. A 1:1 aspect ratio is most appropriate when two continuous variables are on the same scale, as with the iris dataset.\nAll variables are measured in centimeters, so it only makes sense that one unit on the plot should be the same physical distance on each axis. This gives a more truthful depiction of the relationship between the two variables since the aspect ratio can change the angle of our smoothing line. This would give an erroneous impression of the data. Of course the underlying linear models don’t change, but our perception can be influenced by the angle drawn.\nA plot using the iris dataset, of sepal width vs. sepal length colored by species, is shown in the viewer.\nSteps\n\nAdd a fixed coordinate layer to force a 1:1 aspect ratio.\n\n\nggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_jitter() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  # Fix the coordinate ratio\n  coord_fixed(ratio = 1)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nAwe-inspiring aspect alteration! A 1:1 aspect ratio is helpful when your axes show the same scales."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#aspect-ratio-ii-setting-ratios",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#aspect-ratio-ii-setting-ratios",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Aspect ratio II: setting ratios",
    "text": "Aspect ratio II: setting ratios\nWhen values are not on the same scale it can be a bit tricky to set an appropriate aspect ratio. A classic William Cleveland (inventor of dot plots) example is the sunspots data set. We have 3200 observations from 1750 to 2016.\nsun_plot is a plot without any set aspect ratio. It fills up the graphics device.\nTo make aspect ratios clear, we’ve drawn an orange box that is 75 units high and 75 years wide. Using a 1:1 aspect ratio would make the box square. That aspect ratio would make things harder to see the oscillations: it is better to force a wider ratio.\n\nsunspots <- readRDS(\"data/sunspots.rds\")\nsun_plot <- sunspots %>%\n  ggplot(aes(x = Date, y = Mean)) +\n  geom_line(color=\"skyblue\") +\n  labs(y = \"Sunspots\", x = \"Date\") +\n  geom_rect(aes(ymin = 310, ymax = 385), xmin = -40177, xmax = -12784, alpha = 0.75, colour = \"orange\", fill = NA)\nsun_plot\n\n\n\n\nREWORK NECESSARY!\nSteps\n\nFix the coordinates to a 1:1 aspect ratio.\n\n\n# Fix the aspect ratio to 1:1\nsun_plot +\n  coord_fixed()\n\n\n\n\n\nThe y axis is now unreadably small. Make it bigger!\n\nChange the aspect ratio to 20:1. This is the aspect ratio recommended by Cleveland to help make the trend among oscillations easiest to see.\n\n\n\n# Change the aspect ratio to 20:1\nsun_plot +\n  coord_fixed(ratio = 20)"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#expand-and-clip",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#expand-and-clip",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Expand and clip",
    "text": "Expand and clip\nThe coord_*() layer functions offer two useful arguments that work well together: expand and clip.\n\nexpand sets a buffer margin around the plot, so data and axes don’t overlap. Setting expand to 0 draws the axes to the limits of the data.\nclip decides whether plot elements that would lie outside the plot panel are displayed or ignored (“clipped”).\n\nWhen done properly this can make a great visual effect! We’ll use theme_classic() and modify the axis lines in this example.\nSteps\n\nAdd Cartesian coordinates with zero expansion, to remove all buffer margins on both the x and y axes.\n\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point(size = 2) +\n  # Add Cartesian coordinates with zero expansion\n  coord_cartesian(expand = 0) +\n  theme_classic()\n\n\n\n\n\nSetting expand to 0 caused points at the edge of the plot panel to be cut off.\n\nSet the clip argument to \"off\" to prevent this.\nRemove the axis lines by setting the axis.line argument to element_blank() in the theme() layer function.\n\n\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point(size = 2) +\n  # Turn clipping off\n  coord_cartesian(expand = 0, clip = \"off\") +\n  theme_classic() +\n  # Remove axis lines\n  theme(axis.line = element_blank())\n\n\n\n\nCool clipping! These arguments make clean and accurate plots by not cutting off data."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#coordinates-vs.-scales",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#coordinates-vs.-scales",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Coordinates vs. scales",
    "text": "Coordinates vs. scales\nTheory. Coming soon …\n1. Coordinates vs. scales\nIn the next set of exercises, I want to look at how to use the coordinate layer to perform transformations, and how that differs from using the scale functions.\n2. Plot the raw data\nFor these examples, I’m going to use the body weight variable from the msleep data set. I made more adjustments than what’s shown here, but this is the basic code to get this univariate plot. We can see that this variable has a strong positive skew.In the first course, we saw how we can use the scale functions to modify things like the x-axis limits and breaks.Let’s consider three ways in which we can transform our data. A common transformation for positively skewed data is a natural, base e, logarithm, or the more intuitive common, base 10, logarithm.\n3. Transform the raw data\nWe can transform the data before we begin plotting, and update the actual data frame, or we can transform the variable on-the-fly when we specify it in the aes function, as shown here. The result is the same.So far, so good! Notice that the axis labels are the log-transformed values, where zero is the log 10 of 1 kilograms, and 4 is the log 10 of 10000 kilograms.This is a very common solution, but it is a bit misleading in that the transformed scale is linear and we have to do some mental arithmetic to get back to the original values. So we’ve lost a bit of precision here.\n4. Add logtick annotation\nWe could add log annotation tick marks using the annotation_logticks function. This highlights that the data is a log transformation.However, another solution is to have the data on a log scale, and label it with the actual original body weight value.We can do this in two ways.\n**5. Use scale_*_log10()**\nThe first method uses the scale_x_log10 function. This transformed the data and then calculates any statistics needed.\n**6. Compare direct transform and scale_*_log10() output**\nThe plots are almost identical, but pay attention to the axis labeling in the second plot using the scale_x_log10 function. The labels correspond to the actual value in the data set. This is the default output, we saw how to clean up axis labels in the first course.\n7. Use coord_trans()\nAs you could imagine, we also have a function in the coordinate layer: coord_trans, which is actually more flexible in that we can apply any transformation we’d like.\n**8. Compare scale_*_log10() and coord_trans() output**\nUsing coord_trans and setting the x argument to “log10” results in the same plot as with the scale function. The default labels happen to be different, but the plot is the same.\n9. Adjusting labels\nAs a final step, we can add the actual values of the data on the axis. This is a really nice way to show the transformed values in relation to the original value on the axis labels.This may give you the impression that scale and coord functions work in the same way, but just like zooming, there are some fundamental differences under the hood when applying transformations. We’ll take a look at those in the exercises.\n10. Time for exercises\nAlright, now that you know how to use the scale and coord functions to apply transformations, let’s look at bivariate plots and see how these functions affect our statistics."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#log-transforming-scales",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#log-transforming-scales",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Log-transforming scales",
    "text": "Log-transforming scales\nUsing scale_y_log10() and scale_x_log10() is equivalent to transforming our actual dataset before getting to ggplot2.\nUsing coord_trans(), setting x = \"log10\" and/or y = \"log10\" arguments, transforms the data after statistics have been calculated. The plot will look the same as with using scale_*_log10(), but the scales will be different, meaning that we’ll see the original values on our log10 transformed axes. This can be useful since log scales can be somewhat unintuitive.\nLet’s see this in action with positively skewed data - the brain and body weight of 51 mammals from the msleep dataset.\nSteps\n\nUsing the msleep dataset, plot the raw values of brainwt against bodywt values as a scatter plot.\n\n\n# Produce a scatter plot of brainwt vs. bodywt\nggplot(msleep, aes(bodywt, brainwt)) +\n  geom_point() +\n  ggtitle(\"Raw Values\")\n\n\nAdd the scale_x_log10() and scale_y_log10() layers with default values to transform the data before plotting.\n\n\n# Add scale_*_*() functions\nggplot(msleep, aes(bodywt, brainwt)) +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_log10() +\n  ggtitle(\"Scale_ functions\")\n\nWarning: Removed 27 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nUse coord_trans() to apply a \"log10\" transformation to both the x and y scales.\n\n\n# Perform a log10 coordinate system transformation\nggplot(msleep, aes(bodywt, brainwt)) +\n  geom_point() +\n  coord_trans(\n      x = \"log10\",\n      y = \"log10\"\n  )\n\nWarning: Removed 27 rows containing missing values (`geom_point()`).\n\n\n\n\n\nTerrific transformations! Each transformation method has implications for the plot’s interpretability. Think about your audience when choosing a method for applying transformations."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#adding-stats-to-transformed-scales",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#adding-stats-to-transformed-scales",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Adding stats to transformed scales",
    "text": "Adding stats to transformed scales\nIn the last exercise, we saw the usefulness of the coord_trans() function, but be careful! Remember that statistics are calculated on the untransformed data. A linear model may end up looking not-so-linear after an axis transformation. Let’s revisit the two plots from the previous exercise and compare their linear models.\nSteps\n\nAdd log10 transformed scales to the x and y axes.\n\n\n# Plot with a scale_*_*() function:\nggplot(msleep, aes(bodywt, brainwt)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  # Add a log10 x scale\n  scale_x_log10() +\n  # Add a log10 y scale\n  scale_y_log10() +\n  ggtitle(\"Scale functions\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 27 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 27 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nAdd a log10 coordinate transformation for both the x and y axes.\n\n\n# Plot with transformed coordinates\nggplot(msleep, aes(bodywt, brainwt)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  # Add a log10 coordinate transformation for x and y axes\n  coord_trans(\n      x = \"log10\",\n      y = \"log10\"\n  )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 27 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 27 rows containing missing values (`geom_point()`).\n\n\n\n\n\nLoopy lines! The smooth trend line is calculated after scale transformations but not coordinate transformations, so the second plot doesn’t make sense. Be careful when using the coord_trans() function!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#double-and-flipped-axes",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#double-and-flipped-axes",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Double and flipped axes",
    "text": "Double and flipped axes\nTheory. Coming soon …\n1. Double and flipped axes\nSo far we’ve seen two ways in which we can modify our axes.\n2. Typical axis modifications\nFirst we saw that we can change the aspect ratio to obtain the best perspective.In the last video we saw how we can also apply appropriate transformation functions.Here, I want to take a look at two more common modifications.\n3. Typical axis modifications\nLet’s begin with having double x or y axes.Actually, having a double x or y axis is strongly discouraged. I’ll discuss when it can go wrong in chapter 4.Here, I want to give show you when double axes can actually work really well.\n4. Double axes\nWe ended the last video with this plot. It displays log10 transformed values. One problem with presenting transformed values is that we are an additional step further removed from the raw data.\n5. Adding raw and transformed axes\nTo make the plot easier to read, we can include the raw and the log10-transformed values on one plot. This is a beautiful use case since the double axis adds more information to an existing variable.\n6. Typical axis modifications\nLet’s take a look at one more typical modification. Flipping axes. This can be useful for changing the direction of dependencies, but also when we need to adjust the geometry’s orientation. We’ll look at the first case in the video and you’ll explore the second in the exercises.\n7. Flipping axes\nWe saw this plot of the iris dataset in the first video of this course. It uses geom smooth to add three linear models to a scatter plot. In this case, both sepal width and length are dependent variables. That is, they are dependent on the species, which is the independent variable. Statistically, it doesn’t really matter which is mapped to the x or y.But in some cases it does. Our models are read as “y as a function of x” since we typically map the dependent variable onto the y axis and the independent variable onto the x axis.If we ever decide that our orientation is incorrect, we can either change our code to remap our variables, or\n8. coord_flip()\nwe can use quick and easy coord flip function. In this way, we don’t need to manually adjust all our code.You can only use one coord layer function in each plot, so we don’t have the possibility to set the aspect ratio anymore.\n9. Let’s practice!\nAlright, we’ve seen four different ways in which we can modify our axes. Let’s practice with some exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#useful-double-axes",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#useful-double-axes",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Useful double axes",
    "text": "Useful double axes\nDouble x and y-axes are a contentious topic in data visualization. We’ll revisit that discussion at the end of chapter 4. Here, I want to review a great use case where double axes actually do add value to a plot.\nOur goal plot is displayed in the viewer. The two axes are the raw temperature values on a Fahrenheit scale and the transformed values on a Celsius scale.\nYou can imagine a similar scenario for Log-transformed and original values, miles and kilometers, or pounds and kilograms. A scale that is unintuitive for many people can be made easier by adding a transformation as a double axis.\nSteps\n\nBegin with a standard line plot, of Temp described by Date in the airquality dataset.\n\n\n# data\nairquality <- airquality |> \n    bind_cols(Date = seq(as.Date(\"1973-05-01\"), as.Date(\"1973-09-30\"), \"days\"))\n\n# Using airquality, plot Temp vs. Date\nggplot(airquality, aes(Date, Temp)) +\n  # Add a line layer\n  geom_line() +\n  labs(x = \"Date (1973)\", y = \"Fahrenheit\")\n\n\n\n\n\nConvert y_breaks from Fahrenheit to Celsius (subtract 32, then multiply by 5, then divide by 9).\nDefine the secondary y-axis using sec_axis(). Use the identity transformation. Set the breaks and labels to the defined objects y_breaks and y_labels, respectively.\n\n\n# Define breaks (Fahrenheit)\ny_breaks <- c(59, 68, 77, 86, 95, 104)\n\n# Convert y_breaks from Fahrenheit to Celsius\ny_labels <- (y_breaks - 32) * 5 / 9\n\n# Create a secondary x-axis\nsecondary_y_axis <- sec_axis(\n  # Use identity transformation\n  trans = identity,\n  name = \"Celsius\",\n  # Define breaks and labels as above\n  breaks = y_breaks,\n  labels = y_labels\n)\n\n# Examine the object\nsecondary_y_axis\n\n<ggproto object: Class AxisSecondary, gg>\n    axis: NULL\n    break_info: function\n    breaks: 59 68 77 86 95 104\n    create_scale: function\n    detail: 1000\n    empty: function\n    guide: waiver\n    init: function\n    labels: 15 20 25 30 35 40\n    make_title: function\n    mono_test: function\n    name: Celsius\n    trans: function\n    transform_range: function\n    super:  <ggproto object: Class AxisSecondary, gg>\n\n\n\nAdd your secondary y-axis to the sec.axis argument of scale_y_continuous().\n\n\n# Update the plot\nggplot(airquality, aes(Date, Temp)) +\n  geom_line() +\n  # Add the secondary y-axis \n  scale_y_continuous(sec.axis = secondary_y_axis) +\n  labs(x = \"Date (1973)\", y = \"Fahrenheit\")\n\n\n\n\nDazzling double axes! Double axes are most useful when you want to display the same value in two differnt units."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#flipping-axes-i",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#flipping-axes-i",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Flipping axes I",
    "text": "Flipping axes I\nFlipping axes means to reverse the variables mapped onto the x and y aesthetics. We can just change the mappings in aes(), but we can also use the coord_flip() layer function.\nThere are two reasons to use this function:\n\nWe want a vertical geom to be horizontal, or\nWe’ve completed a long series of plotting functions and want to flip it without having to rewrite all our commands.\n\nSteps\n\nCreate a side-by-side (“dodged”) bar chart of fam, filled according to fcyl.\n\n\n# Plot fcyl bars, filled by fam\nggplot(mtcars, aes(fill = fam, x = fcyl)) +\n  # Place bars side by side\n  geom_bar(position = \"dodge\")\n\n\n\n\n\nTo get horizontal bars, add a coord_flip() function.\n\n\nggplot(mtcars, aes(fcyl, fill = fam)) +\n  geom_bar(position = \"dodge\") +\n  # Flip the x and y coordinates\n  coord_flip()\n\n\n\n\n\nPartially overlapping bars are popular with “infoviz” in magazines. Update the position argument to use position_dodge() with a width of 0.5.\n\n\nggplot(mtcars, aes(fcyl, fill = fam)) +\n  # Set a dodge width of 0.5 for partially overlapping bars\n  geom_bar(position = position_dodge(width = 0.5)) +\n  coord_flip()\n\n\n\n\nFlipping fantastic! Horizontal bars are especially useful when the axis labels are long."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#flipping-axes-ii",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#flipping-axes-ii",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Flipping axes II",
    "text": "Flipping axes II\nIn this exercise, we’ll continue to use the coord_flip() layer function to reverse the variables mapped onto the x and y aesthetics.\nWithin the mtcars dataset, car is the name of the car and wt is its weight.\nSteps\n\nCreate a scatter plot of wt versus car using the mtcars dataset. We’ll flip the axes in the next step.\n\n\n# data\nmtcars <- mtcars |> tibble::rownames_to_column(var = \"car\")\n\n# Plot of wt vs. car\nggplot(mtcars, aes(car, wt)) +\n  # Add a point layer\n  geom_point() +\n  labs(x = \"car\", y = \"weight\")\n\n\n\n\n\nIt would be easier to read if car was mapped to the y axis. Flip the coordinates. Notice that the labels also get flipped!\n\n\n# Flip the axes to set car to the y axis\nggplot(mtcars, aes(car, wt)) +\n  geom_point() +\n  labs(x = \"car\", y = \"weight\") +\n  coord_flip()\n\n\n\n\nEven funkier flips! Notice how much more interpretable the plot is after flipping the axes."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#polar-coordinates",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#polar-coordinates",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Polar coordinates",
    "text": "Polar coordinates\nTheory. Coming soon …\n1. Polar coordinates\nEvery plot we’ve made so far has used a Cartesian coordinate space.\n2. Projections control perception\nFor two dimensions, this just means two orthogonal axes composed of straight lines.We can control how our data is perceived, by changing the limits of each axis and the aspect ratio, which we’ve covered already.\n3. Projections control perception\nHowever, another aspect that controls how we perceive data is the plotting projection.An example of this is with maps. We’ll cover this in detail in the next course, but it’s worth mentioning here in the context of projections.\n4. A preview of map projections\nThere are many projections that we can use to present a 3D object, such as the Earth, on a 2D space, like a map. Some projections are better than others. For example the Mercator projection, on the left, is known to engross regions at the poles and diminish regions around the equator. The Conic projection is an alternative, but still suffers from the problem of projecting a 3D object in 2D.\n5. Polar coordinates\nThe same applies to the Cartesian coordinate system. One of the most common projections is a polar transformation.\n6. coord_polar()\nWhich can be seen here. In this case, theta, the axis which will be presented around the circumference, defaults to the x axis. Imagine that we just take the x axis on the left and bend it until it loops back on itself, while expanding the top side as we go along. We’d end up with the plot on the right.\n7. coord_polar(theta = “y”)\na more common transformation is to place the y-axis on the circumference by setting theta to y.Actually, this is exactly what we’d do with a bar chart to convert it to a pie chart. As we’ll see in the exercises, a pie chart is simply a bar chart transformed onto a polar coordinate system.In the first course I mentioned how good data Visualization uses encoding elements for the data that allows the more efficient and accurate decoding by the viewer. According to that definition, polar coordinates should be used with extreme caution since they considerably distort that data. However, there are some specific use cases of polar coordinates, and we’ll explore these in the exercises.\n8. Let’s practice!\nAlright, let’s head over to the exercise and take a look at polar coordinates!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#pie-charts",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#pie-charts",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Pie charts",
    "text": "Pie charts\nThe coord_polar() function converts a planar x-y Cartesian plot to polar coordinates. This can be useful if you are producing pie charts.\nWe can imagine two forms for pie charts - the typical filled circle, or a colored ring.\nTypical pie charts omit all of the non-data ink, which we saw in the themes chapter of the last course. Pie charts are not really better than stacked bar charts, but we’ll come back to this point in the next chapter.\nA bar plot using mtcars of the number of cylinders (as a factor), fcyl, is shown in the plot viewer.\nSteps\n\nRun the code to see the stacked bar plot.\nAdd (+) a polar coordinate system, mapping the angle to the y variable by setting theta to \"y\".\n\n\n# Run the code, view the plot, then update it\nggplot(mtcars, aes(x = 1, fill = fcyl)) +\n  geom_bar() +\n  # Add a polar coordinate system\n  coord_polar(theta = \"y\")\n\n\n\n\n\nReduce the width of the bars to 0.1.\nMake it a ring plot by adding a continuous x scale with limits from 0.5 to 1.5.\n\n\nggplot(mtcars, aes(x = 1, fill = fcyl)) +\n  # Reduce the bar width to 0.1\n  geom_bar(width = 0.1) +\n  coord_polar(theta = \"y\") +\n  # Add a continuous x scale from 0.5 to 1.5\n  scale_x_continuous(\n    limits = c(0.5, 1.5)\n  )\n\n\n\n\nSuper-fly pie! Polar coordinates are particularly useful if you are dealing with a cycle, like yearly data, that you would like to see represented as such."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#wind-rose-plots",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#wind-rose-plots",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Wind rose plots",
    "text": "Wind rose plots\nPolar coordinate plots are well-suited to scales like compass direction or time of day. A popular example is the “wind rose”.\nThe wind dataset is taken from the openair package and contains hourly measurements for windspeed (ws) and direction (wd) from London in 2003. Both variables are factors.\n\nlibrary(openair)\nlibrary(dplyr)\nlibrary(forcats)\nlibrary(purrr, warn.conflicts = F)\n\ndata(\"mydata\", package = \"openair\")\nwind <- mydata |> \n            filter(lubridate::year(date) == 2003) |> \n            mutate(wsf = cut(ws, breaks         = c(seq(0,20,2), Inf), \n                                 labels         = c(seq(0,18,2) |> map_chr(function(x) { paste0(x,\" - \",x + 2) }), \"20+\"),\n                                 include.lowest = T) |> fct_rev()) |> \n            mutate(wdf = cut(wd, breaks = seq(0, 360 , by=22.5),\n                                 include.lowest = T,\n                                 labels = c(\"N\",\"NNE\",\"NE\", \"ENE\", \"E\", \"ESE\", \"SE\", \"SSE\", \n                                            \"S\", \"SSW\", \"SW\", \"WSW\", \"W\", \"WNW\", \"NW\", \"NNW\")))\n\nSteps\n\nMake a classic bar plot mapping wdf onto the x aesthetic and wsf onto fill.\nUse a geom_bar() layer, since we want to aggregate over all date values, and set the width argument to 1, to eliminate any spaces between the bars.\n\n\n# Using wind, plot wd filled by ws\nggplot(wind, aes(wdf, fill = wsf)) +\n  # Add a bar layer with width 1\n  geom_bar(width = 1)\n\n\n\n\n\nConvert the Cartesian coordinate space into a polar coordinate space with coord_polar().\n\n\n# Convert to polar coordinates:\nggplot(wind, aes(wdf, fill = wsf)) +\n  geom_bar(width = 1) +\n  coord_polar()\n\n\n\n\n\nSet the start argument to -pi/16 to position North at the top of the plot.\n\n\n# Convert to polar coordinates:\nggplot(wind, aes(wdf, fill = wsf)) +\n  geom_bar(width = 1) +\n  coord_polar(start = -pi/16)\n\n\n\n\nPerfect polar coordinates! They are not common, but polar coordinate plots are really useful."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#the-facets-layer",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#the-facets-layer",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "The facets layer",
    "text": "The facets layer\nTheory. Coming soon …\n1. The facets layer\nThe next layer we’ll take a look at is the the facets layer.\n2. Facets\nFacets are a pretty straight-forward and very useful tool in data visualization. They are based on the concept of small multiples, popularized by Edward Tufte in his 1983 book the Visualization of Quantitative Information.\n3. The idea behind facets\nThe idea is that we can split up a large, complex plot, to produce multiple smaller plots\n4. The idea behind facets\nthat have the exact same coordinate system. On each plot we present different data sets so as to compare them more easily.\n5. iris.wide\nHere we use the iris.wide data frame to produce a scatter plot. We have information on each of the species, so we can add a facet_grid layer to add another variable to our plot.\n6. iris.wide & facet_grid()\nfacet_grid has arguments for splitting plots into rows or columns according to a variable provided in the var function. Here, we’re splitting according to columns using the cols argument.\n7. Formula notation\nThe same result can be achieved by using the formula notation which you may be familiar with from defining linear models with the lm function. Everything on the left of the tilde (~) will split according to rows, and everything on the right will split according to columns.So the primary use of facets is to add another categorical variable to your plot, but they also aid in visual perception.\n8. iris.wide2\nFor example, we already saw where this is very useful in the first course, when we talked about data structure. We used the iris.wide2 data frame to produce three different plots. The issue was that each plot was drawn on a separate y-axis, and we had to use three different plotting functions to get these plots.\n9. iris.tidy\nWhen we use the iris.tidy data set, we can take advantage of the facet_grid layer to solve both of theses problems. The trick in both of these examples is to understand that facets are simply splitting up our overall data set according to the levels in a categorical factor variable. If our data is in the right format we can achieve this easily using either columns or rows.\n10. iris.tidy done wrong\nIn this case it doesn’t make sense to split according to rows because the whole point is to aid in visual perception and to make comparisons. When we split along columns, it allowed us to read our plots from left to right along a single axis.\n11. Other options\nSo the choice depends on what type of data you are using. Of course you can also split according to both columns and rows, using two different variables, and if you have many levels in your categorical variable, you can wrap the subplots into a defined number of columns.\n12. Let’s practice!\nAlright, let’s explore these details and some further subtleties in the exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-layer-basics",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-layer-basics",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Facet layer basics",
    "text": "Facet layer basics\nFaceting splits the data up into groups, according to a categorical variable, then plots each group in its own panel. For splitting the data by one or two categorical variables, facet_grid() is best.\nGiven categorical variables A and B, the code pattern is\n\nfacet_grid(rows = vars(A), cols = vars(B))\n\nThis draws a panel for each pairwise combination of the values of A and B.\nHere, we’ll use the mtcars data set to practice. Although cyl and am are not encoded as factor variables in the data set, ggplot2 will coerce variables to factors when used in facets.\nSteps\n\nFacet the plot in a grid, with each am value in its own row.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet rows by am\n  facet_grid(rows = vars(am))\n\n\nFacet the plot in a grid, with each cyl value in its own column.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet columns by cyl\n  facet_grid(cols = vars(cyl))\n\n\n\n\n\nFacet the plot in a grid, with each am value in its own row and each cyl value in its own column.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet rows by am and columns by cyl\n  facet_grid(rows = vars(am), \n             cols = vars(cyl))\n\n\n\n\nFantastic faceting! Compare the different plots that result and see which one makes most sense."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#many-variables",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#many-variables",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Many variables",
    "text": "Many variables\nIn addition to aesthetics, facets are another way of encoding factor (i.e. categorical) variables. They can be used to reduce the complexity of plots with many variables.\nOur goal is the plot in the viewer, which contains 7 variables.\nTwo variables are mapped onto the color aesthetic, using hue and lightness. To achieve this we combined fcyl and fam into a single interaction variable, fcyl_fam. This will allow us to take advantage of Color Brewer’s Paired color palette.\nSteps\n\nMap fcyl_fam onto the a color aesthetic.\nAdd a scale_color_brewer() layer and set \"Paired\" as the palette.\n\n\n# data\nmtcars <- mtcars |> \n            mutate(fcyl_fam = interaction(fcyl, fam, sep = \":\"))\n\n# See the interaction column\nmtcars$fcyl_fam\n\n [1] 6:1 6:1 4:1 6:0 8:0 6:0 8:0 4:0 4:0 6:0 6:0 8:0 8:0 8:0 8:0 8:0 8:0 4:1 4:1\n[20] 4:1 4:0 8:0 8:0 8:0 8:0 4:1 4:1 4:1 8:1 6:1 8:1 4:1\nLevels: 4:0 6:0 8:0 4:1 6:1 8:1\n\n# Color the points by fcyl_fam\nggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam)) +\n  geom_point() +\n  # Use a paired color palette\n  scale_color_brewer(palette = \"Paired\")\n\n\n\n\n\nMap disp, the displacement volume from each cylinder, onto the size aesthetic.\n\n\n# Update the plot to map disp to size\nggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam, size = disp)) +\n  geom_point() +\n  scale_color_brewer(palette = \"Paired\")\n\n\n\n\n\nAdd a facet_grid() layer, faceting the plot according to gear on rows and vs on columns.\n\n\n# Update the plot\nggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam, size = disp)) +\n  geom_point() +\n  scale_color_brewer(palette = \"Paired\") +\n  # Grid facet on gear and vs\n  facet_grid(rows = vars(gear), cols = vars(vs))\n\n\n\n\nGood job! The last plot you’ve created contains 7 variables (4 categorical, 3 continuous). Useful combinations of aesthetics and facets help to achieve this."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#formula-notation",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#formula-notation",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Formula notation",
    "text": "Formula notation\nAs well as the vars() notation for specifying which variables should be used to split the dataset into facets, there is also a traditional formula notation. The three cases are shown in the table.\n\n\n\nModern notation\nFormula notation\n\n\n\n\nfacet_grid(rows = vars(A))\nfacet_grid(A ~ .)\n\n\nfacet_grid(cols = vars(B))\nfacet_grid(. ~ B)\n\n\nfacet_grid(rows = vars(A), cols = vars(B))\nfacet_grid(A ~ B)\n\n\n\nmpg_by_wt is available again. Rework the previous plots, this time using formula notation.\nSteps\n\nFacet the plot in a grid, with each am value in its own row.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet rows by am using formula notation\n  facet_grid(am ~ .)\n\n\nFacet the plot in a grid, with each cyl value in its own column.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet columns by cyl using formula notation\n  facet_grid(. ~ cyl)\n\n\n\n\n\nFacet the plot in a grid, with each am value in its own row and each cyl value in its own column.\n\n\nggplot(mtcars, aes(wt, mpg)) + \n  geom_point() +\n  # Facet rows by am and columns by cyl using formula notation\n  facet_grid(am ~ cyl)\n\n\n\n\nFortunate formula formulation! While many ggplots still use the traditional formula notation, using vars() is now preferred."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-labels-and-order",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-labels-and-order",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Facet labels and order",
    "text": "Facet labels and order\nTheory. Coming soon …\n1. Facet labels and order\nNow that you understand how to use facets for one or more categorical variables, let’s take a look at labeling and arranging facets properly.\n2. A new dataframe\nWe’ll begin with a modified version of the msleep dataframe from ggplot2 that I’ve called msleep2. msleep2 contains the log10 transformed body and brain weights of 51 animals, which I’ve plotted as a scatterplot here.\n3. A new dataframe, with facets\nAnother variable, called vore contains information on eating behavior, which we can use to facet the plot. There are four eating habits: Herbivore, Carnivore, Insectivore and Omnivore.\n4. A new dataframe, with facets\nTo make sure you can read the labels we’ll periodically zoom in, which means that the entire plot may not be shown.\n5. Poor labels and order\nTwo typical problems with facets are that they are often poorly labeled or that they have a wrong or inappropriate order.\n6. Poor labels and order\nWe can fix up some of the labels inside ggplot2, but some things are better done on the actual data before plotting. Let’s take a look at both.\n7. The labeller argument\nThe facet layer functions have a labeller argument, which defaults to label_value.\n8. Using label_both adds the variable name\nA more useful argument is to use label_both, which puts both the name of the variable and the level value.\n9. Two variables on one side\nIn the exercises, we saw that we can use multiple variables on rows or columns, like I’ve done here with the conservation status.\n10. Using label_context avoids ambiguity\nIn this case we can use the label_context argument which will add the variable name only if the labels may be ambiguous. If each variable has a small number of labels, this works well, as we’ll see in the exercises. Unfortunately, this plot is already pretty overloaded and you can see that the labels are too long for the space given!\n11. Use rows and columns when appropriate\nLet’s switch to faceting on both rows and columns, in which case label_context defaults to label_value,\n12. Use rows and columns when appropriate\nwhich means we can just leave it out.\n13. Use rows and columns when appropriate\nHere, all the labels fit nicely inside the alloted space.Let’s take a look at the actual facet labels and positions. To change these we need to go to the data set directly.\n14. Relabeling and reordering factors\nThe forcats package in the tidyverse collection contains some really useful functions here. I like fct_recode, as shown here, for relabeling level names in a factor variable.\n15. Reinitialize plot with new labels\nIf we reinitialize our plot, we’ll see the new, informative, labels.\n16. Reinitialize plot with new labels\nNonetheless, we may still want them in a different order than alphabetical.\n17. Changing the order of levels\nThe fct_relevel function makes this really easy, as the second argument we just need to put the levels in our desired order.\n18. Reinitialize plot with new order\nNow when we reinitialize out plot, our facets are in an appropriate order.\n19. Let’s practice!\nLet’s try this out on a few exercises with the mtcars dataframe."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#labeling-facets",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#labeling-facets",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Labeling facets",
    "text": "Labeling facets\nIf your factor levels are not clear, your facet labels may be confusing. You can assign proper labels in your original data before plotting (see next exercise), or you can use the labeller argument in the facet layer.\nThe default value is\n\nlabel_value: Default, displays only the value\n\nCommon alternatives are:\n\nlabel_both: Displays both the value and the variable name\nlabel_context: Displays only the values or both the values and variables depending on whether multiple factors are faceted\n\nSteps\n\nAdd a facet_grid() layer and facet cols according to the cyl using vars(). There is no labeling.\n\n\n# Plot wt by mpg\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  # The default is label_value\n  facet_grid(cols = vars(cyl))\n\n\n\n\n\nApply label_both to the labeller argument and check the output.\n\n\n# Plot wt by mpg\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  # Displaying both the values and the variables\n  facet_grid(cols = vars(cyl), labeller = label_both)\n\n\n\n\n\nApply label_context to the labeller argument and check the output.\n\n\n# Plot wt by mpg\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  # Label context\n  facet_grid(cols     = vars(cyl), \n             labeller = label_context)\n\n\n\n\n\nIn addition to label_context, let’s facet by one more variable: vs.\n\n\n# Plot wt by mpg\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  # Two variables\n  facet_grid(cols = vars(vs, cyl), labeller = label_context)\n\n\n\n\nLovely labels! Make sure there is no ambiguity in interpreting plots by using proper labels."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#setting-order",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#setting-order",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Setting order",
    "text": "Setting order\nIf you want to change the order of your facets, it’s best to properly define your factor variables before plotting.\nLet’s see this in action with the mtcars transmission variable am. In this case, 0 = “automatic” and 1 = “manual”.\nHere, we’ll make am a factor variable and relabel the numbers to proper names. The default order is alphabetical. To rearrange them we’ll call fct_rev() from the forcats package to reverse the order.\nSteps\n\nExplicitly label the 0 and 1 values of the am column as \"automatic\" and \"manual\", respectively.\n\n\n# Make factor, set proper labels explictly\nmtcars$fam <- factor(mtcars$am, labels = c(`0` = \"automatic\",\n                                           `1` = \"manual\"))\n\n# Default order is alphabetical\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  facet_grid(cols = vars(fam))\n\n\n\n\n\nDefine a specific order using separate levels and labels arguments. Recall that 1 is \"manual\" and 0 is \"automatic\".\n\n\n# Make factor, set proper labels explictly, and\n# manually set the label order\nmtcars$fam <- factor(mtcars$am,\n                     levels = c(1, 0),\n                     labels = fct_rev(c(\"manual\", \"automatic\")))\n\n# View again\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() +\n  facet_grid(cols = vars(fam))\n\n\n\n\nOutstanding ordering! Arrange your facets in an intuitive order for your data."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-plotting-spaces",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-plotting-spaces",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Facet plotting spaces",
    "text": "Facet plotting spaces\nTheory. Coming soon …\n1. Facet plotting spaces\nThe major advantage of facets is that every plot is drawn on the same plotting space. This makes them all directly comparable.\n2. Facets and variable plotting spaces\nNonetheless, you may encounter situations in which you actually don’t want this. For example in continuous variables, if the faceted subsets have wildly different ranges you’ll just be adding a lot of white space. In the case of categorical data, it’s common that each subset may have different groups, so it may not be necessary, or even appropriate to list all groups in each of the faceted plots.\n3. Adjusting the plotting space…\nLet’s look at this with the plot we ended the last video with. We used facet_grid to create rows according to eating habit and columns according to conservation status. To adjust the plotting space, we can use the scales argument.\n4. … but not with fixed scales\nIf we set this argument to “free_x” we’ll allow each column of plot to have their own x axis. However, here we run into a typical problem. We can’t use a fixed coordinate space and have free axes as the same time.\n5. Adjusting the plotting space\nOnce we remove the fixed coordinate space, then we can adjust the x axis for each column.\n6. Adjusting the plotting space\nWe can do the same for the y axis by setting the scales argument to “free_y” instead.\n7. Adjusting the plotting space\nWe can adjust both the x and y axes by setting the scales argument to “free”. Note that each column and row has at least a common x and y axis respectively.\n8. Adjusting the plotting space\nLet’s take a look at how this works with categorical variables. Each animal has only one eating behavior, stored in the vore variable. If we plotted the bodyweight of each animal in the name variable and facet according to vore, we would repeat the full name list in each sub-plot.This occurs when a categorical variable has many levels, like the name, that are not all present in each sub-group of another variable, like vore.\n9. Adjusting the plotting space\nIf we set the scales to free_y, we’ll have only those names present in each facet, but the size of each plot is the still the same.\n10. Adjusting the plotting space\nThis behavior can be changed with the spaces argument , which works in the same way as scales: “free_x” allows different sized facets on the x-axis, “free_y” allows different sized facets on the y-axis, and “free” allows different sizes in both directions. Here, we need to use “free_y”.This plot already looks great! But there is one more thing we may want to change.\n11. Final adjustments\nWe can rearrange the data frame according to the weight and then redefine the factor levels according to the order in which they appear. This will arrange them in the same way in the plot.Thinking about the order of the names in this case makes the plot more intuitive.\n12. Let’s practice!\nGreat, let’s head over to the exercises and see this all in action."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#variable-plotting-spaces-i-continuous-variables",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#variable-plotting-spaces-i-continuous-variables",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Variable plotting spaces I: continuous variables",
    "text": "Variable plotting spaces I: continuous variables\nBy default every facet of a plot has the same axes. If the data ranges vary wildly between facets, it can be clearer if each facet has its own scale. This is achieved with the scales argument to facet_grid().\n\n\"fixed\" (default): axes are shared between facets.\nfree: each facet has its own axes.\nfree_x: each facet has its own x-axis, but the y-axis is shared.\nfree_y: each facet has its own y-axis, but the x-axis is shared.\n\nWhen faceting by columns, \"free_y\" has no effect, but we can adjust the x-axis. In contrast, when faceting by rows, \"free_x\" has no effect, but we can adjust the y-axis.\nSteps\n\nUpdate the plot to facet columns by cyl.\n\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() + \n  # Facet columns by cyl \n  facet_grid(cols = vars(cyl))\n\n\n\n\n\nUpdate the faceting to free the x-axis scales.\n\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() + \n  # Update the faceting to free the x-axis scales\n  facet_grid(cols = vars(cyl),\n            scales = \"free_x\")\n\n\n\n\n\nFacet rows by cyl (rather than columns).\nFree the y-axis scales (instead of x).\n\n\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point() + \n  # Swap cols for rows; free the y-axis scales\n  facet_grid(rows = vars(cyl), scales = \"free_y\")\n\n\n\n\nFreedom! Shared scales make it easy to compare between facets, but can be confusing if the data ranges are very different. In that case, used free scales."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#variable-plotting-spaces-ii-categorical-variables",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#variable-plotting-spaces-ii-categorical-variables",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Variable plotting spaces II: categorical variables",
    "text": "Variable plotting spaces II: categorical variables\nWhen you have a categorical variable with many levels which are not all present in each sub-group of another variable, it’s usually desirable to drop the unused levels.\nBy default, each facet of a plot is the same size. This behavior can be changed with the spaces argument, which works in the same way as scales: \"free_x\" allows different sized facets on the x-axis, \"free_y\", allows different sized facets on the y-axis, \"free\" allows different sizes in both directions.\nSteps\n\nFacet the plot by rows according to gear using vars(). Notice that every car is listed in every facet, resulting in many lines without data.\n\n\nggplot(mtcars, aes(x = mpg, y = car, color = fam)) +\n  geom_point() +\n  # Facet rows by gear\n  facet_grid(rows = vars(gear))\n\n\n\n\n\nTo remove blank lines, set the scales and space arguments in facet_grid() to free_y.\n\n\nggplot(mtcars, aes(x = mpg, y = car, color = fam)) +\n  geom_point() +\n  # Free the y scales and space\n  facet_grid(rows   = vars(gear),\n             scales = \"free_y\",\n             space  = \"free_y\")\n\n\n\n\nSuper spaces! Freeing the y-scale to remove blank lines helps focus attention on the actual data present."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-wrap-margins",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#facet-wrap-margins",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Facet wrap & margins",
    "text": "Facet wrap & margins\nTheory. Coming soon …\n1. Facet wrap & margins\nIn the last video we explored facet_grid() for splitting up a plot according to a categorical variable.\n2. Adjusting the plotting space\nWe saw that this allowed us to set a free x axis for all plots the same column and a free y axis for all plots in the same row. That’s alright, but wouldn’t it be great if each plot can also have it’s own x and y axes dependent on their data? Actually, it kind of defeats the purpose of having small multiples, but it can be useful if we have distinct ranges.To achieve this, we can take advantage of another useful function in this layer: facet_wrap\n3. Using facet_wrap()\nThere are a couple use cases for this function.First, as I just mentioned, when we want each plot to have its own plotting space, but we still want to take advantage of tidy data structure and ggplot2 to generate all those plots as facets of a larger plot, and not as individual plots.\n4. Using facet_wrap() - Scenario 1\nFor facet_wrap, we specify one or more faceting variables with a single call to the vars function. facet_wrap will automatically choose an appropriate number of columns and rows.So this gets the job done, but you can see that it is more difficult to keep track of each plot and variable compared to facet_grid, so use this with caution.\n5. Using facet_wrap()\nSecond, and what is a more typical scenario, is when our categorical variable has many groups, so that faceting along only rows or only columns is overwhelming.\n6. Using facet_wrap() - Scenario 2\nFor example, here, our 51 animals belong to 13 taxonomic orders which is nicely displayed with facet wrap. Using facet grid would produce a single row or column with 13 plots, which would be impractical.\n7. Using margin plots\nBefore we wrap up with facets, let’s look at one more adjustment we can make with this layer. We can present each facet and a composite plot with all categories together. These are called margin plots.This was our original facetted plot, but\n8. Using margin plots\nif we add the margins argument to the facet layer, we can add margin plots for both the rows and columns that display all points together. Notice that in the lower right corner, we have the complete data set in one facet.\n9. Using margin plots\nWe can also specify one one variable to produce the margin plots.\n10. Let’s practice!\nSo far so good. We’ve seen that there is a lot more to the facet layer than just splitting up your plots. Let’s explore these last concepts in the exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#wrapping-for-many-levels",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#wrapping-for-many-levels",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Wrapping for many levels",
    "text": "Wrapping for many levels\nfacet_grid() is fantastic for categorical variables with a small number of levels. Although it is possible to facet variables with many levels, the resulting plot will be very wide or very tall, which can make it difficult to view.\nThe solution is to use facet_wrap() which separates levels along one axis but wraps all the subsets across a given number of rows or columns.\nFor this plot, we’ll use the Vocab dataset that we’ve already seen. The base layer is provided.\nSince we have many years, it doesn’t make sense to use facet_grid(), so let’s try facet_wrap() instead.\nSteps\n\nAdd a facet_wrap() layer and specify:\n\nThe year variable with an argument using the vars() function,\n\n\n\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  stat_smooth(method = \"lm\", se = FALSE) +\n  # Create facets, wrapping by year, using vars()\n  facet_wrap(vars(year))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nAdd a facet_wrap() layer and specify the year variable with a formula notation (~).\n\n\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  stat_smooth(method = \"lm\", se = FALSE) +\n  # Create facets, wrapping by year, using a formula\n  facet_wrap(~ year)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nAdd a facet_wrap() layer and specify:\n\nFormula notation as before, and ncol set to 11.\n\n\n\nggplot(Vocab, aes(x = education, y = vocabulary)) +\n  stat_smooth(method = \"lm\", se = FALSE) +\n  # Update the facet layout, using 11 columns\n  facet_wrap(~ year, ncol = 11)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nIt’s a wrap! Start experimenting with facets in your own plots."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#margin-plots",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#margin-plots",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Margin plots",
    "text": "Margin plots\nFacets are great for seeing subsets in a variable, but sometimes you want to see both those subsets and all values in a variable.\nHere, the margins argument to facet_grid() is your friend.\n\nFALSE (default): no margins.\nTRUE: add margins to every variable being faceted by.\nc(\"variable1\", \"variable2\"): only add margins to the variables listed.\n\nTo make it easier to follow the facets, we’ve created two factor variables with proper labels — fam for the transmission type, and fvs for the engine type, respectively.\nZoom the graphics window to better view your plots.\nSteps\n\nUpdate the plot to facet the rows by fvs and fam, and columns by gear.\n\n\n# data\nmtcars <- mtcars |> \n           mutate(fvs = as_factor(vs))\n\n# Plot\nggplot(mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  # Facet rows by fvs and cols by fam\n  facet_grid(rows = vars(fvs, fam), \n             cols = vars(gear))\n\n\n\n\n\nAdd all possible margins to the plot.\n\n\nggplot(mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  # Update the facets to add margins\n  facet_grid(rows = vars(fvs, fam), \n             cols = vars(gear),\n             margins = T)\n\n\n\n\n\nUpdate the facets to only show margins on \"fam\".\n\n\nggplot(mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  # Update the facets to only show margins on fam\n  facet_grid(rows = vars(fvs, fam), \n             cols = vars(gear), \n             margins = \"fam\")\n\n\n\n\n\nUpdate the facets to only show margins on \"gear\" and \"fvs\".\n\n\nggplot(mtcars, aes(x = wt, y = mpg)) + \n  geom_point() +\n  # Update the facets to only show margins on gear and fvs\n  facet_grid(rows = vars(fvs, fam), cols = vars(gear), margins = c(\"gear\", \"fvs\"))\n\n\n\n\nMagic margins! It can be really helpful to show the full margin plots!"
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#best-practices-bar-plots",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#best-practices-bar-plots",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Best practices: bar plots",
    "text": "Best practices: bar plots\nTheory. Coming soon …\n1. Best practices: bar plots\nKnowing how to efficiently use ggplot is a good first step,\n2. In this chapter\nbut now we need to consider what is the best way to graphically represent our data, what are the common pitfalls and what is the best way to represent our data.\n3. Bar plots\nThere are two common types of bar plots. The first is simply showing an absolute count value. The second is a distribution, which is as terrible as it is common. Why is that?\n4. Mammalian sleep\nLet’s return to the mammalian sleep data set. We have eating habits of several mammals along with the time they spend sleeping and how much of that time is REM sleep.\n5. Dynamite plot\nWe map vore and sleep onto the x and y aesthetics, respectively, and draw the error bars as discussed in chapter one.So far so good, but we have no idea how many observations we have in each category!This plot also suggests that our data is normally distributed. If our data is not normally distributed it’s not appropriate to represent it in this way.A further perceptual problem is that our bars give the impression of having data where there is no data. There for sure are no mammals which sleep 0 hours a day! Yet the bars begin showing data at 0, plus, the region above the mean contains values but no ink! What could be a better way?\n6. Individual data points\nWell first off, we can simply show the individual data points. This is first off necessary for ourselves, to really see what our data looks like, but it may actually already be a pretty good end point! Note that here we used geom_point and set the position to jitter with the position_jitter function so that we can control the width of the jittering. alpha is also set to 0.6 in case there is any residual over plotting.ok, so now we can start to see some strange patterns in our data set! First off, it’s pretty clear that we don’t have that much data for Insectivores, and that it anyways looks pretty strange. We can’t really say much about them, but if we had to say something it looks like they are bimodal. We’d need some more data to make better conclusions. Omnivores also look pretty interesting, it appears as though this data is positively skewed. So we can start drawing conclusions that were previously impossible to see.\n7. geom_errorbar()\nOf course we could still plot both the individual data points and the summary statistics with the geom errorbar\n8. geom_pointrange()\nor the geom pointrange.\n9. Without data points\nAnd it’s obvious that we could have simply shown these summary statistics by themselves.\n10. Bars are not necessary\nNotice that the error bars with points are a much cleaner representation of the data. The bars are simply not necessary! Now, none of these summary plots are particularly useful in this specific case, mostly because we know now that the insectivore and omnivore data sets are not suitable. Nonetheless they may be perfectly good alternatives for your data, so they are worth mentioning.There are some more plotting geometries that we’ll discuss in the next course when we get into statistical plots, such as box plots and violin plots are. Here I just want to mention that they are also alternatives, in general, but not necessarily in this situation.\n11. Ready for exercises!\nOK, let’s explore these concepts in more detail in the exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-dynamite-plots",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-dynamite-plots",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Bar plots: dynamite plots",
    "text": "Bar plots: dynamite plots\nIn the video we saw many reasons why “dynamite plots” (bar plots with error bars) are not well suited for their intended purpose of depicting distributions. If you really want error bars on bar plots, you can of course get them, but you’ll need to set the positions manually. A point geom will typically serve you much better.\nNonetheless, you should know how to handle these kinds of plots, so let’s give it a try.\nSteps\n\nUsing mtcars,, plot wt versus fcyl.\nAdd a bar summary stat, aggregating the wts by their mean, filling the bars in a skyblue color.\nAdd an errorbar summary stat, aggregating the wts by mean_sdl.\n\n\n# Plot wt vs. fcyl\nggplot(mtcars, aes(x = fcyl, y = wt)) +\n  # Add a bar summary stat of means, colored skyblue\n  stat_summary(fun = mean, geom = \"bar\", fill = \"skyblue\") +\n  # Add an errorbar summary stat std deviation limits\n  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = \"errorbar\", width = 0.1)\n\n\n\n\nExcellent errors! Remember, we can specify any function in fun.data or fun.y and we can also specify any geom, as long as it’s appropriate to the data type."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-position-dodging",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-position-dodging",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Bar plots: position dodging",
    "text": "Bar plots: position dodging\nIn the previous exercise we used the mtcars dataset to draw a dynamite plot about the weight of the cars per cylinder type.\nIn this exercise we will add a distinction between transmission type, fam, for the dynamite plots and explore position dodging (where bars are side-by-side).\nSteps\n\nAdd two more aesthetics so the bars are colored and filled by fam.\n\n\n# Update the aesthetics to color and fill by fam\nggplot(mtcars, aes(x = fcyl, y = wt, color = fam, fill = fam)) +\n  stat_summary(fun = mean, geom = \"bar\") +\n  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = \"errorbar\", width = 0.1)\n\n\n\n\n\nThe stacked bars are tricky to interpret. Make them transparent and side-by-side.\n\nMake the bar summary statistic transparent by setting alpha to 0.5.\nFor each of the summary statistics, set the bars’ position to \"dodge\".\n\n\n\n# Set alpha for the first and set position for each stat summary function\nggplot(mtcars, aes(x = fcyl, y = wt, color = fam, fill = fam)) +\n  stat_summary(\n    fun = mean, \n    geom = \"bar\", \n    position = \"dodge\", \n    alpha = 0.5) +\n  stat_summary(\n    fun.data = mean_sdl, \n    fun.args = list(mult = 1), \n    geom     = \"errorbar\", \n    position = \"dodge\", \n    width    = 0.1)\n\n\n\n\n\nThe error bars are incorrectly positioned. Use a position object.\n\nDefine a dodge position object with width 0.9, assigned to posn_d.\nFor each of the summary statistics, set the bars’ position to posn_d.\n\n\n\n# Define a dodge position object with width 0.9\nposn_d <- position_dodge(width=0.9)\n\n# For each summary stat, update the position to posn_d\nggplot(mtcars, aes(x     = fcyl, \n                   y     = wt, \n                   color = fam, \n                   fill  = fam)) +\n  stat_summary(\n    fun      = mean, \n    geom     = \"bar\", \n    position = posn_d, \n    alpha    = 0.5) +\n  stat_summary(\n    fun.data = mean_sdl, \n    fun.args = list(mult = 1), \n    width    = 0.1, \n    position = posn_d, \n    geom     = \"errorbar\")\n\n\n\n\nBar plots 2.0! slightly overlapping bar plots are common in the popular press and add a bit of style to your data viz."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-using-aggregated-data",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#bar-plots-using-aggregated-data",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Bar plots: Using aggregated data",
    "text": "Bar plots: Using aggregated data\nIf it is appropriate to use bar plots (see the video!), then it nice to give an impression of the number of values in each group.\nstat_summary() doesn’t keep track of the count. stat_sum() does (that’s the whole point), but it’s difficult to access. It’s more straightforward to calculate exactly what we want to plot ourselves.\nHere, we’ve created a summary data frame called mtcars_by_cyl which contains the average (mean_wt), standard deviations (sd_wt) and count (n_wt) of car weights, for each cylinder group, cyl. It also contains the proportion (prop) of each cylinder represented in the entire dataset. Use the console to familiarize yourself with the mtcars_by_cyl data frame.\nSteps\n\nDraw a bar plot with geom_bar().\n\nUsing mtcars_by_cyl, plot mean_wt versus cyl.\nAdd a bar layer, with stat set to \"identity\" an fill-color \"skyblue\".\n\n\n\n# data\nmtcars_by_cyl <- mtcars |> \n  group_by(cyl) |> \n  summarise(mean_wt = mean(wt),\n            sd_wt   = sd(wt),\n            n_wt    = n()) |> \n  mutate(prop =  n_wt/sum(n_wt))\n\n# Using mtcars_cyl, plot mean_wt vs. cyl\nggplot(mtcars_by_cyl, aes(cyl, mean_wt)) +\n  # Add a bar layer with identity stat, filled skyblue\n  geom_bar(stat=\"identity\", fill=\"skyblue\")\n\n\n\n\n\nDraw the same plot with geom_col().\n\nReplace geom_bar() with geom_col().\nRemove the stat argument.\n\n\n\nggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +\n  # Swap geom_bar() for geom_col()\n  geom_col(fill = \"skyblue\")\n\n\n\n\n\nChange the bar widths to reflect the proportion of data they contain.\n\nAdd a width aesthetic to geom_col(), set to prop. (Ignore the warning from ggplot2.)\n\n\n\nggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +\n  # Set the width aesthetic to prop\n  geom_col(fill = \"skyblue\",\n           aes(width = prop))\n\nWarning in geom_col(fill = \"skyblue\", aes(width = prop)): Ignoring unknown\naesthetics: width\n\n\n\n\n\n\nAdd geom_errorbar().\n\nSet the ymin aesthetic to mean_wt minus sd_wt. Set the ymax aesthetic to the mean weight plus the standard deviation of the weight.\nSet the width to 0.1.\n\n\n\nggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +\n  geom_col(aes(width = prop), fill = \"skyblue\") +\n  # Add an errorbar layer\n  geom_errorbar(\n    # ... at mean weight plus or minus 1 std dev\n    aes(ymin = mean_wt - sd_wt,\n        ymax = mean_wt + sd_wt),\n    # with width 0.1\n    width = 0.1\n  )\n\nWarning in geom_col(aes(width = prop), fill = \"skyblue\"): Ignoring unknown\naesthetics: width\n\n\n\n\n\nAwesome Aggregrates! This is a good start, but it’s difficult to adjust the spacing between the bars."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heatmaps-use-case-scenario",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heatmaps-use-case-scenario",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Heatmaps use case scenario",
    "text": "Heatmaps use case scenario\nTheory. Coming soon …\n1. Heatmaps use case scenario\nI briefly mentioned before that heat maps are a poor data visualization method. It’s surprising, since they are really popular among scientists of all stripes. Let’s take a closer look.\n2. The barley dataset\nOur dataset is a classic in data visualization. We have four variables: The yield of 10 different barley varieties measured at two years and at 10 different sites.\n3. A basic heat map\nOur heat map is basically a colored table. Our three categorical variables are mapped onto x, y and fill. The continuous variable, yield, is mapped onto fill.So what’s wrong with this plot?Well, although there are some exceptions, color on a continuous scale is problematic. Color perception depends on context. Here, each color appears in a different background, which means that heat maps are not well-suited for seeing individual results. If our categories were clustered in a way the brings out overall trends, then we may make the case for a heat map, because it would at least communicate something. Often times this is not the case.Many times, heat maps look complex and try to impress the viewer with a meaningless “wow” factor.What would be a better alternative?\n4. A dot plot\nHere, we can switch the mapping of yield onto the x and year onto the color scale.Now we can ask very pointed questions, such as which variety performed best in a given year. How does a particular variety perform at a given site? To answer these questions, we use a process of slow table-look up type perception. It’s slow and time-consuming, but very useful.We can also start to see some trends. First, red, 1931, is mostly greater than blue, 1932. Second, the farms are arranged from lowest overall average, Grand Rapids, to highest, Waseca. Third, we can also notice a difference in spread among the farms. These large overall trends are discernible from this visualization, but they take a bit of time to see. How about an alternative?\n5. As a time series\nTypically, when you have a time scale, the key question is change over time. How do yields differ between the two years?This line plot shows that change for each variety over time. It has all the same information as the previous plot but it’s more difficult to answer the precise questions from before. However, it is an easier way to see the general trends in the data set. We’ve increased the speed of our perception.Notice that there are 10 colors for the 10 varieties. It’s getting pretty difficult to distinguish all the colors and we’re at the limits of visual perception. It still kind-of works, but it’s starting to push it.\n6. Using dodged error bars\nWe can aggregate all the varieties by using their mean, and focus on the farms. We saw how to do this in the stat_summary section. Here I’ve used errorbars with some dodging.\n7. Using ribbons for error\nAlternatively, we could have also used ribbons without dodging. Both dodged error bars and overlapping ribbons work for showing uncertainty, the choice depends on the density of your data and your audience.In summary, there are many good alternatives to heat maps, depending on the research question and our take-home message.\n8. Coding Time!\nLet’s explore how to produce these plots in the exercises."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heat-maps",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heat-maps",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Heat maps",
    "text": "Heat maps\nSince heat maps encode color on a continuous scale, they are difficult to accurately decode, a topic we discussed in the first course. Hence, heat maps are most useful if you have a small number of boxes and/or a clear pattern that allows you to overcome decoding difficulties.\nTo produce them, map two categorical variables onto the x and y aesthetics, along with a continuous variable onto fill. The geom_tile() layer adds the boxes.\nWe’ll produce the heat map we saw in the video (in the viewer) with the built-in barley dataset. The barley dataset is in the lattice package and has already been loaded for you. Use str() to explore the structure.\nSteps\n\nUsing barley, plot variety versus year, filled by yield.\nAdd a geom_tile() layer.\n\n\n# data\nlibrary(lattice)\n\n# Using barley, plot variety vs. year, filled by yield\nggplot(barley, aes(year, variety, fill = yield)) +\n  # Add a tile geom\n  geom_tile()\n\n\n\n\n3.. Add a facet_wrap() function with facets as vars(site) and ncol = 1. Strip names will be above the panels, not to the side (as with facet_grid()). 4. Give the heat maps a 2-color palette using scale_fill_gradient(). Set low and high to \"white\" and \"red\", respectively.\n\n# Previously defined\nggplot(barley, aes(x = year, y = variety, fill = yield)) +\n  geom_tile() + \n  # Facet, wrapping by site, with 1 column\n  facet_wrap(facets = vars(site), ncol = 1) +\n  # Add a fill scale using an 2-color gradient\n  scale_fill_gradient(low = \"white\", high = \"red\")\n\n\n\n\n\nA color palette of 9 reds, made with brewer.pal(), is provided as red_brewer_palette.\n\nUpdate the fill scale to use an n-color gradient with scale_fill_gradientn() (note the n). Set the scale colors to the red brewer palette.\n\n\n\n# A palette of 9 reds\nlibrary(RColorBrewer)\nred_brewer_palette <- brewer.pal(9, \"Reds\")\n\n# Update the plot\nggplot(barley, aes(x = year, y = variety, fill = yield)) +\n  geom_tile() + \n  facet_wrap(facets = vars(site), ncol = 1) +\n  # Update scale to use n-colors from red_brewer_palette\n  scale_fill_gradientn(colors = red_brewer_palette)\n\n\n\n\nGood job! You can continue by using breaks, limits and labels to modify the fill scale and update the theme, but this is a pretty good start."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#useful-heat-maps",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#useful-heat-maps",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Useful heat maps",
    "text": "Useful heat maps\n\nQuestion\nHeat maps are often a poor data viz solution because they typically don’t convey useful information. We saw a nice alternative in the last exercise. But sometimes they are really good. Which of the following scenarios is not one of those times?  ⬜ When data has been sorted, e.g. according to a clustering algorithm, and we can see clear trends. ⬜ When there are few groups with large differences. ✅ When we have a large data set and we want to impress our colleagues with how complex our work is! ⬜ When using explanatory plots to communicate a clear message to a non-scientific audience.\n\nYes. This is typical and it’s why many people dislike heatmaps."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heat-map-alternatives",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#heat-map-alternatives",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Heat map alternatives",
    "text": "Heat map alternatives\nThere are several alternatives to heat maps. The best choice really depends on the data and the story you want to tell with this data. If there is a time component, the most obvious choice is a line plot.\n\n# The heat map we want to replace\n# Don't remove, it's here to help you!\nggplot(barley, aes(x = year, y = variety, fill = yield)) +\n  geom_tile() +\n  facet_wrap( ~ site, ncol = 1) +\n  scale_fill_gradientn(colors = brewer.pal(9, \"Reds\"))\n\n\n\n\nSteps\n\nUsing barley, plot yield versus year, colored and grouped by variety.\nAdd a line layer.\nFacet, wrapping by site, with 1 row.\n\n\n# Using barley, plot yield vs. year, colored and grouped by variety\nggplot(barley, aes(year, yield, color = variety, group = variety)) +\n  # Add a line layer\n  geom_line() +\n  # Facet, wrapping by site, with 1 row\n  facet_wrap( ~ site, nrow = 1)\n\n\n\n\n\nDisplay only means and ribbons for spread.\n\nMap site onto color, group and fill.\nAdd a stat_summary() layer. set fun.y = mean, and geom = \"line\".\nIn the second stat_summary(), set geom = \"ribbon\", color = NA and alpha = 0.1.\n\n\n\n# Using barely, plot yield vs. year, colored, grouped, and filled by site\nggplot(barley, aes(x = year, \n                   y = yield, \n                   color = site, \n                   group = site, \n                   fill  = site)) +\n  # Add a line summary stat aggregated by mean\n  stat_summary(fun.y = mean, geom = \"line\") +\n  # Add a ribbon summary stat with 10% opacity, no color\n  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = \"ribbon\", alpha = 0.1, color = NA)\n\nWarning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.\nℹ Please use the `fun` argument instead.\n\n\n\n\n\nGood job! Whenever you see a heat map, ask yourself it it’s really necessary. Many people use them because they look fancy and complicated - signs of poor communication skills."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#when-good-data-makes-bad-plots",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#when-good-data-makes-bad-plots",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "When good data makes bad plots",
    "text": "When good data makes bad plots\nTheory. Coming soon …\n1. When good data makes bad plots\nSo far, we’ve focused on making good plots, but it’s worthwhile to be able to identify and correct bad plots.\n2. Bad plots: style\nThere are many ways in which we can have bad plots. Simple formatting errors like poor color and text choices make it difficult to read the data correctly or even make our plots look ugly. All text should also serve a purpose and be legible for our audience. Pause the video and take a minute to review the items listed here. You’ve probably seen them already in the wild.\n3. Bad plots: structure and content\nDeeper problems occur with structure and content. As the domain expert it’s your job to know if you are overloading a plot with too much information to simply impress your viewers, or if you are producing a useless plot just to fill us space.The axes, statistics and geometries must also be used effectively. It doesn’t hurt to reduce non-data ink and, finally, 3D plots should be avoided. Pause the video again and take a minute to review these topics before continuing.Let’s take a look at some common data viz pitfalls.\n4. Wrong orientation\nWe typically read the y axis of a plot as a function of x, denoted f(x). That means that the variable on the y axis is a dependent variable of the independent x axis variable. Flipping the axes is confusing.\n5. Wrong orientation?\nBut, actually, sometimes it works great! We saw this at the end of the last course,\n6. Wrong orientation?\nand in the last video. In both cases the axes were flipped to make them easier to read.\n7. Broken y-axes\nBroken y-axes are also popular. This compensates for a large range in the data set with a large gap between the high and low values.Unfortunately, the upper and lower parts are on different scales!\n8. Broken y-axes, replace with transformed data\nWe would rather transform the scales. For example using a log 10 transformation, as shown here, or,\n9. Broken y-axes, use facets\nor more typically, use facets with free scales.\n10. 3D plots, without data on the 3rd axis\nThe 3D plot is another favorite but often, the 3rd axis actually serves no purpose but to confuse the audience as to which part of the geometry should be read on the scale.\n11. 3D plots, with data on the 3rd axis\nSometimes 3D plots really do contain information in the 3rd axis, like 3D scatter plots. But can you figure out the position of each dot in this plot? It just adds to obscuring our data. Ideally we’d like to provide this as an interactive object or else as a series of two dimensional plots.\n12. Double y-axes\nDouble y-axes are also problematic but popular.Perceptual challenges in reading the data make this difficult, and it also invites suspicious activity since the scales are independent and the visual message can be manipulated to emphasis or diminish the perceived correlation by changing the range of values on the scale.If the two values are to be correlated then we should have an x-y plot that shows the correlation.\n13. Double y-axis for transformations\nWe did actually see a great example of double x and y-axes in the second chapter, when we had a raw and transformed scale.\n14. Guidelines not rules\nBut, remember, there are very few rules in data visualization, which is what makes it so interesting and difficult.Just use your common sense – if anything on your plot obscures communication it is at worst unethical and at best poor execution.I hope that by now you are also a critical consumer of data visualization and are not so easily fooled by other people’s poor judgement or purposeful misdirection.\n15. Let’s practice!\nWe’ll explore the bits that we can fix in ggplot2 in the exercises, so let’s get started."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#suppression-of-the-origin",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#suppression-of-the-origin",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Suppression of the origin",
    "text": "Suppression of the origin\n\nQuestion\nSuppression of the origin refers to not showing 0 on a continuous scale. When is it inappropriate to suppress the origin?  ✅ When the scale has a natural zero, like height or distance. ⬜ When the scale doesn’t have a natural zero, like temperature (in C or F). ⬜ When there is a large amount of whitespace between the origin and the actual data. ⬜ When it does not obscure the shape of the data.\n\nCorrect. This would be a good reason to begin at 0, but it’s not strictly necessary and not always appropriate."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#color-blindness",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#color-blindness",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Color blindness",
    "text": "Color blindness\nRed-Green color blindness is surprisingly prevalent, which means that part of your audience will not be able to ready your plot if you are relying on color aesthetics.\n\nQuestion\nWhy would it be appropriate to use red and green in a plot?  ⬜ When red and green are the actual colors in the sample (e.g. fluorescence in biological assays). ⬜ When red means stop/bad and green means go/good. ⬜ Because red and green are complimentary colors and look great together. ✅ When red and green have different intensities (e.g. light red and dark green).\n\nIf you really want to use red and green, this is a way to make them accessible to color blind people, since they sill still be able to distinguish intensity. It’s not as salient as hue, but it still works."
  },
  {
    "objectID": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#typical-problems",
    "href": "content/R/topics/04_data_visualization/data_visualization_with_ggplot2_intermediate/ggplot2_intermediate.html#typical-problems",
    "title": "Intermediate Data Visualization with ggplot2",
    "section": "Typical problems",
    "text": "Typical problems\nWhen you first encounter a data visualization, either from yourself or a colleague, you always want to critically ask if it’s obscuring the data in any way.\nLet’s take a look at the steps we could take to produce and improve the plot in the view.\nThe data comes from an experiment where the effect of two different types of vitamin C sources, orange juice or ascorbic acid, were tested on the growth of the odontoblasts (cells responsible for tooth growth) in 60 guinea pigs.\nThe data is stored in the TG data frame, which contains three variables: dose, len, and supp.\nSteps\n\nThe first plot contains purposely illegible labels. It’s a common problem that can occur when resizing plots. There is also too much non-data ink.\n\nChange theme_gray(3) to theme_classic().\n\n\n\n# data\ndata(\"ToothGrowth\")\nTG <- ToothGrowth\n\n# Initial plot\ngrowth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +\n  stat_summary(fun.data = mean_sdl,\n               fun.args = list(mult = 1),\n               position = position_dodge(0.1)) +\n  theme_classic()\n\n# View plot\ngrowth_by_dose\n\n\n\n\n\nOur previous plot still has a major problem, dose is stored as a factor variable. That’s why the spacing is off between the levels.\n\nUse as.character() wrapped in as.numeric() to convert the factor variable to real (continuous) numbers.\n\n\n\n# Change type\nTG$dose <- as.numeric(as.character(TG$dose))\n\n# Plot\ngrowth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +\n  stat_summary(fun.data = mean_sdl,\n               fun.args = list(mult = 1),\n               position = position_dodge(0.2)) +\n  theme_classic()\n\n# View plot\ngrowth_by_dose\n\n\n\n\n\nUse the appropriate geometry for the data:\n\nIn the new stat_summary() function, set fun.y to to calculate the mean and the geom to a \"line\" to connect the points at their mean values.\n\n\n\n# Change type\nTG$dose <- as.numeric(as.character(TG$dose))\n\n# Plot\ngrowth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +\n  stat_summary(fun.data = mean_sdl,\n               fun.args = list(mult = 1),\n               position = position_dodge(0.2)) +\n  # Use the right geometry\n  stat_summary(fun.y = mean,\n               geom = \"line\",\n               position = position_dodge(0.1)) +\n  theme_classic()\n\n# View plot\ngrowth_by_dose\n\n\n\n\n\nMake sure the labels are informative:\n\nAdd the units \"(mg/day)\" and \"(mean, standard deviation)\" to the x and y labels, respectively.\nUse the \"Set1\" palette.\nSet the legend labels to \"Orange juice\" and \"Ascorbic acid\".\n\n\n\n# Change type\nTG$dose <- as.numeric(as.character(TG$dose))\n\n# Plot\ngrowth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +\n  stat_summary(fun.data = mean_sdl,\n               fun.args = list(mult = 1),\n               position = position_dodge(0.2)) +\n  stat_summary(fun.y = mean,\n               geom = \"line\",\n               position = position_dodge(0.1)) +\n  theme_classic() +\n  # Adjust labels and colors:\n  labs(x = \"Dose (mg/day)\", y = \"Odontoblasts length (mean, standard deviation)\", color = \n\"Supplement\") +\n  scale_color_brewer(palette = \"Set1\", labels = c(\"Orange juice\", \"Ascorbic acid\")) +\n  scale_y_continuous(limits = c(0,35), breaks = seq(0, 35, 5), expand = c(0,0))\n\n# View plot\ngrowth_by_dose"
  },
  {
    "objectID": "content/python/01-eval-background-theory.html",
    "href": "content/python/01-eval-background-theory.html",
    "title": "Background and theory",
    "section": "",
    "text": "For your final project, you will conduct an evaluation for a social program of your choosing. In this assignment, you will explore the program’s background, history, purpose, and theory.\nIf you decide to use a different program for your final project, that’s okay! This assignment doesn’t have to be related to your final program, but it would be helpful—a more polished version of this assignment can be included as part of your final project."
  },
  {
    "objectID": "content/python/01-eval-background-theory.html#instructions",
    "href": "content/python/01-eval-background-theory.html#instructions",
    "title": "Background and theory",
    "section": "Instructions",
    "text": "Instructions\nYou need to complete the four sections listed below. Ideally you should type this in R Markdown and knit your document to HTML or Word or PDF, but you can also write in Word if you want (though your final project will need to be in R Markdown, and this would give you practice).1\nI’ve created an R Markdown template you can use here:  background-theory.zip. It’s also available on RStudio.cloud.\nYou can draw your impact theory and logic model charts by hand or with something like Diagrams.net, Lucidchart, or Creately. Export the image as a PNG, place it in the same directory as your R Markdown file, and include the image with Markdown.\nThe syntax for adding an image in Markdown is fairly simple. Importantly, it is not R code, so don’t try putting it in an R chunk. Just type this:\n![Image caption](/path/to/image.png)\nSubmit this assignment as a PDF or Word file on iCollege."
  },
  {
    "objectID": "content/python/01-eval-background-theory.html#assignment-outline",
    "href": "content/python/01-eval-background-theory.html#assignment-outline",
    "title": "Background and theory",
    "section": "Assignment outline",
    "text": "Assignment outline\n\n1: Program background and purpose\n(≈350 words)\nProvide in-depth background about the program. Include details about (1) when it was started, (2) why it was started, (3) what it was designed to address in society. If the program hasn’t started yet, explain why it’s under consideration. Make sure you cite your sources appropriately! (In the past, some students have just copied/pasted text from a program’s website; don’t do that! Describe and analyze the program’s background!)\n\n\n2: Program theory\n(≈400 words)\nExplain and explore the program’s underlying theory. Sometimes programs will explain why they exist in a mission statement, but often they don’t and you have to infer the theory from what the program looks like when implemented. What did the program designers plan on occurring? Was this theory based on existing research? If so, cite it.\nInclude a simple impact theory graph showing the program’s basic activities and outcomes. Recall from class and your reading that this is focused primarily on the theory and mechanisms, not on the implementation of the program.\n\n\n3: Logic model\nList every possible input, activity, output, and outcome for the program and provide a brief 1–2 sentence description of each.\n\nInputs\n\nSomething\nSomething else\n\n\n\nActivities\n\nSomething\nSomething else\n\n\n\nOutputs\n\nSomething\nSomething else\n\n\n\nOutcomes\n\nSomething\nSomething else\n\n\n\nDiagram\nUse flowchart software to connect the inputs, activities, outputs, and outcomes and create a complete logic model. Remember that inputs will always feed into activities, and that activities always produce outputs (that’s the whole purpose of an activity: convert an input to an output). Include this as a figure.\n\n\n\n4: Analysis\n(≈150 words)\nEvaluate how well the logic model relates to the program theory. Do the inputs, activities, and outputs have a logical, well-grounded connection to the intended outcomes? Under ideal conditions, would the components of the program lead to changes or lasting effects?"
  },
  {
    "objectID": "content/python/01-problem-set.html",
    "href": "content/python/01-problem-set.html",
    "title": "Problem set 1",
    "section": "",
    "text": "Go the the example page for this week, “Welcome to R, RStudio, and the tidyverse”, and work through the different primers and videos in the four parts of the page.\nIt seems like there’s a lot on the page, but they’re short and go fairly quickly (especially as you get the hang of the syntax). Also, I have no way of seeing what you do or what you get wrong or right, and that’s totally fine! If you get stuck and want to skip some (or if it gets too easy), go right ahead and skip them!"
  },
  {
    "objectID": "content/python/01-problem-set.html#task-2-make-an-rstudio-project",
    "href": "content/python/01-problem-set.html#task-2-make-an-rstudio-project",
    "title": "Problem set 1",
    "section": "Task 2: Make an RStudio Project",
    "text": "Task 2: Make an RStudio Project\n\nUse either RStudio.cloud or RStudio on your computer (preferably RStudio on your computer! Follow these instructions to get started!) to create a new RStudio Project. Refer to the example page you read in Task 1 for instructions\nCreate a folder named “data” in the project folder you just made.\nDownload this CSV file and place it in that folder:\n\n cars.csv\n\nIn RStudio, go to “File” > “New File…” > “R Markdown…” and click “OK” in the dialog without changing anything.\nDelete all the placeholder text in that new file and replace it with this:\n---\ntitle: \"Problem set 1\"\nauthor: \"Put your name here\"\noutput: html_document\n---\n\n\n```{r load-libraries-data, warning=FALSE, message=FALSE}\nlibrary(tidyverse)\n\ncars <- read_csv(\"data/cars.csv\")\n```\n\n\n\n# Learning R\n\nTell me that you worked through the primers and videos and examples at the example page for this week:\n\nWRITE SOMETHING HERE LIKE \"I did all the primers and had the time of my life!\" or whatever.\n\n\n# My first plots\n\nInsert a chunk below and use it to create a scatterplot (hint: `geom_point()`) with diplacement (`displ`) on the x-axis, city MPG (`cty`) on the y-axis, and with the points colored by drive (`drv`).\n\nPUT CHUNK HERE\n\nInsert a chunk below and use it to create a histogram (hint: `geom_histogram()`) with highway MPG (`hwy`) on the x-axis. Do not include anything on the y-axis (`geom_histogram()` will do that automatically for you). Choose an appropriate bin width. If you're brave, facet by drive (`drv`).\n\nPUT CHUNK HERE\n\n\n# My first data manipulation\n\nInsert a chunk below and use it to calculate the average city MPG (`cty`) by class of car (`class`). This won't be a plot---it'll be a table. Hint: use a combination of `group_by()` and `summarize()`.\n\nPUT CHUNK HERE\nSave the R Markdown file with some sort of name (without any spaces!)\nYour project folder should look something like this:"
  },
  {
    "objectID": "content/python/01-problem-set.html#task-3-work-with-r",
    "href": "content/python/01-problem-set.html#task-3-work-with-r",
    "title": "Problem set 1",
    "section": "Task 3: Work with R",
    "text": "Task 3: Work with R\n\nRemove the text that says “PUT CHUNK HERE” and insert a new R code chunk. Either type ctrl + alt + i on Windows, or ⌘ + ⌥ + i on macOS, or use the “Insert Chunk” menu:\n\n\n\n\n\n\n\n\n\n\n\nFollow the instructions for the three chunks of code.\nKnit your document as a Word file (or PDF if you’re brave and installed LaTeX). Use the “Knit” menu:\n\n\n\n\n\n\n\n\n\n\n\nUpload the knitted document to iCollege.\n🎉 Party! 🎉\n\n\n\n\n\n\n\nTip\n\n\n\nYou’ll be doing this same process for all your future problem sets. Each problem set will involve an R Markdown file. You can either create a new RStudio Project directory for all your work:\n\n\n\n\n\n\n\n\n\nOr you can create individual projects for each assignment and project:"
  },
  {
    "objectID": "content/python/02-eval-measurement.html",
    "href": "content/python/02-eval-measurement.html",
    "title": "Measurement",
    "section": "",
    "text": "For your final project, you will conduct an evaluation for a social program of your choosing. In this assignment, you will decide how to best measure two of the program’s outcomes.\nIf you decide to use a different program for your final project, that’s okay! This assignment doesn’t have to be related to your final program, but it would be extraordinarily helpful—a more polished version of this assignment can be included as part of your final project."
  },
  {
    "objectID": "content/python/02-eval-measurement.html#instructions",
    "href": "content/python/02-eval-measurement.html#instructions",
    "title": "Measurement",
    "section": "Instructions",
    "text": "Instructions\nYou need to complete the two sections listed below. Ideally you should type this in R Markdown and knit your document to HTML or Word or PDF, but you can also write in Word if you want (though your final project will need to be in R Markdown, and this would give you practice).1\nI’ve created an R Markdown template you can use here:  measurement.zip. It’s also available on RStudio.cloud.\nSubmit this assignment as a PDF or Word file on iCollege."
  },
  {
    "objectID": "content/python/02-eval-measurement.html#assignment-outline",
    "href": "content/python/02-eval-measurement.html#assignment-outline",
    "title": "Measurement",
    "section": "Assignment outline",
    "text": "Assignment outline\n\n1: Measurement and abstraction for full-day kindergarten\nRead this article about half-day vs. full-day kindergarten in Utah. The article is 10 years old, and half-day kindergarten still remains standard practice in most Utah school districts.\nPretend you are the administrator of the Optional Extended Day Kindergarten initiative. Based on the Salt Lake Tribune article (which provides hints throughout, and especially in one of the final paragraphs), and based on your own knowledge of educational outcomes, make a list of two (2) possible outcomes of the full-day kindergarten program.\nThen, for each of those two outcomes, do the following: Using the concept of the “ladder of abstraction” that we discussed in class (e.g. identifying a witch, measuring poverty, etc.), make a list of all the possible attributes of the outcome. Narrow this list down to 3–4 key attributes. Discuss how you decided to narrow the concepts and justify why you think these attributes capture the outcome. (≈100 words)\nThen, for each of those attributes, answer these questions:\n\nMeasurable definition: How would you specifically define this attribute? (i.e. if the attribute is “reduced crime”, define it as “The percent change in crime in a specific neighborhood during a certain time frame” or something similar)\nIdeal measurement: How would you measure this attribute in an ideal world?\nFeasible measurement: How would you measure this given reality and given limitations in budget, time, etc.?\nMeasurement of program effect: How would to connect this measure to people in the program? How would you check to see if the program itself had an effect?\n\n\n\n2: Measurement and abstraction for your program\nMake a list of two possible outcomes of your selected program. For each of those outcomes, make a list of all the possible attributes. Narrow this list down to 3–4 key attributes. Discuss how you decided to narrow the concepts and justify why you think these attributes capture the outcome. (≈100 words)\nThen, for each of those attributes, answer these questions:\n\nMeasurable definition: How would you specifically define this attribute? (i.e. if the attribute is “reduced crime”, define it as “The percent change in crime in a specific neighborhood during a certain time frame” or something similar)\nIdeal measurement: How would you measure this attribute in an ideal world?\nFeasible measurement: How would you measure this given reality and given limitations in budget, time, etc.?\nMeasurement of program effect: How would to connect this measure to people in the program? How would you check to see if the program itself had an effect?"
  },
  {
    "objectID": "content/python/02-problem-set.html",
    "href": "content/python/02-problem-set.html",
    "title": "Problem set 2",
    "section": "",
    "text": "Note\n\n\n\nIMPORTANT: This looks like a lot of work, but it’s mostly copying/pasting chunks of code and changing things."
  },
  {
    "objectID": "content/python/02-problem-set.html#getting-started",
    "href": "content/python/02-problem-set.html#getting-started",
    "title": "Problem set 2",
    "section": "Getting started",
    "text": "Getting started\nFor this problem set, you’ll practice running and interpreting regression models using data about penguins in Antarctica and data on food access and mortality in the US.\nYou’ll be doing all your R work in R Markdown this time (and from now on). You should use an RStudio Project to keep your files well organized (either on your computer or on RStudio.cloud). Either create a new project for this exercise only, or make a project for all your work in this class.\nYou’ll need to download these two CSV files and put them somewhere on your computer or upload them to RStudio.cloud—preferably in a folder named data in your project folder:\n\n penguins.csv\n food_health_politics.csv\n\nYou’ll also need to download this R Markdown file with a template for this problem set. Download that here and include it in your project:\n\n problem-set-2.Rmd\n\nIn the end, the structure of your project directory should look something like this:\nyour-project-name\n├── data\n│   ├── food_health_politics.csv\n│   └── penguins.csv\n├── your-project-name.Rproj\n└── your-name_problem-set-2.Rmd\nTo check that you put everything in the right places, you can download and unzip this file, which contains everything in the correct structure:\n\n problem-set-2.zip\n\nYou’ll need to make sure you have these packages installed on your computer: tidyverse and modelsummary. If you try to load one of those packages with library(tidyverse) or library(modelsummary), etc., and R gives an error that the package is missing, use the “Packages” panel in RStudio to install it.\n(Alternatively, you can open the project named “Problem Set 2” on RStudio.cloud and complete the assignment in your browser without needing to install anything. If you don’t have access to the class RStudio.cloud account, please let me know as soon as possible. This link should take you to the project—if it doesn’t, log in and look for the project named “Problem Set 2.”)\nRemember that you can run an entire chunk by clicking on the green play arrow in the top right corner of the chunk. You can also run lines of code line-by-line if you place your cursor on some R code and press ⌘ + enter (for macOS users) or ctrl + enter (for Windows users).\nMake sure you run each chunk sequentially. If you run a chunk in the middle of the document without running previous ones, it might not work, since previous chunks might do things that later chunks depend on.\nRemember, if you’re struggling, please talk to me. Work with classmates too. Don’t suffer in silence!"
  },
  {
    "objectID": "content/python/02-problem-set.html#instructions",
    "href": "content/python/02-problem-set.html#instructions",
    "title": "Problem set 2",
    "section": "Instructions",
    "text": "Instructions\nFor this problem set, we’re less interested in causal relationships and more interested in the mechanics of manipulating data and running regressions in R. We’ll start caring about identification and causal models in the next problem set. Because of this, don’t put too much causal weight into the interpretations of these different models—this is an actual case of correlation not implying causation.\nThe example for week 2 on regression will be incredibly helpful for this exercise. Reference it. Copy and paste from it liberally.\n\nRename the R Markdown file named your-name_problem-set-2.Rmd to something that matches your name and open it in RStudio.\nComplete the tasks given in the R Markdown file. Fill out code in the empty chunks provided (you can definitely copy, paste, and adapt from other code in the document or from the regression example—don’t try to write everything from scratch!), and replace text in ALL CAPS with your own. (i.e. You’ll see a bunch of TYPE YOUR ANSWER HEREs. Type your answers there.). Again, you don’t need to type your answers in all caps."
  },
  {
    "objectID": "content/python/02-problem-set.html#turning-everything-in",
    "href": "content/python/02-problem-set.html#turning-everything-in",
    "title": "Problem set 2",
    "section": "Turning everything in",
    "text": "Turning everything in\nWhen you’re all done, click on the “Knit” button at the top of the editing window and create a Word or PDF version (if you’ve installed tinytex) of your document. Upload that file to iCollege. Do not upload a knitted HTML file (they don’t on iCollege)."
  },
  {
    "objectID": "content/python/03-eval-dag.html",
    "href": "content/python/03-eval-dag.html",
    "title": "Causal model",
    "section": "",
    "text": "For your final project, you will conduct an evaluation for a social program of your choosing. In this assignment, you will decide how to model the causal effect of your program on your primary outcome.\nIf you decide to use a different program for your final project, that’s okay! This assignment doesn’t have to be related to your final program, but it would be extraordinarily helpful—a more polished version of this assignment can be included as part of your final project."
  },
  {
    "objectID": "content/python/03-eval-dag.html#instructions",
    "href": "content/python/03-eval-dag.html#instructions",
    "title": "Causal model",
    "section": "Instructions",
    "text": "Instructions\nYou need to complete the three sections listed below. Ideally you should type this in R Markdown and knit your document to HTML or Word or PDF, but you can also write in Word if you want (though your final project will need to be in R Markdown, and this would give you practice).\nI’ve created an R Markdown template you can use here:  causal-model.zip. It’s also available on RStudio.cloud.\nSubmit this assignment as a PDF or Word file on iCollege."
  },
  {
    "objectID": "content/python/03-eval-dag.html#dag-i",
    "href": "content/python/03-eval-dag.html#dag-i",
    "title": "Causal model",
    "section": "1: DAG I",
    "text": "1: DAG I\nFind a news article that makes a causal claim and interpret that claim by drawing an appropriate diagram. The article likely won’t explain all the things the researchers controlled for, so you’ll need to create an ideal DAG. What should be included in the causal process to measure the effect of X on Y?\nExport the figure from dagitty and include it in your assignment, or use this code to draw the DAG with R:\n\nlibrary(tidyverse)\nlibrary(ggdag)\n\n# Remember that you can change the variable names here--they can be basically\n# anything, but cannot include spaces. The labels can have spaces. Adjust the\n# variable names (y, x2, etc) and labels (\"Outcome\", \"Something\", etc.) as\n# necessary.\nmy_dag <- dagify(y ~ x1 + x2 + z,\n                 z ~ x1,\n                 x2 ~ x1 + z,\n                 labels = c(\"y\" = \"Outcome\",\n                            \"x1\" = \"Something\",\n                            \"x2\" = \"Something else\",\n                            \"z\" = \"Yet another thing\"),\n                 exposure = \"z\",\n                 outcome = \"y\")\n\n# If you set text = TRUE, you'll see the variable names in the DAG points\n# The `seed` argument makes it so that the random layout is the same every time\nggdag(my_dag, text = FALSE, use_labels = \"label\", seed = 1234) +\n  theme_dag()\n\n# If you want the treatment and outcomes colored differently,\n# replace ggdag() with ggdag_status()\nggdag_status(my_dag, text = FALSE, use_labels = \"label\", seed = 1234) +\n  theme_dag() +\n  theme(legend.position = \"bottom\")  # Move legend to bottom for fun\n\nSummarize the causal claim. Describe what the authors controlled for and what else you included in the DAG. Justify the inclusion of each node (point) and connection (line) in the graph. (≈150 words)\nIdentify all the frontdoor and backdoor paths between your exposure and outcome. What variables need to be controlled for / adjusted to close the backdoors? Did this happen in the study or article? (≈100 words)"
  },
  {
    "objectID": "content/python/03-eval-dag.html#dag-ii",
    "href": "content/python/03-eval-dag.html#dag-ii",
    "title": "Causal model",
    "section": "2: DAG II",
    "text": "2: DAG II\nFind a different news article with a causal claim and do the same thing as above.\nDraw and include a DAG.\nSummarize the causal claim. Describe what the authors controlled for and what else you included in the DAG. Justify the inclusion of each node (point) and connection (line) in the graph. (≈150 words)\nIdentify all the frontdoor and backdoor paths between your exposure and outcome. What variables need to be controlled for / adjusted to close the backdoors? Did this happen in the study or article? (≈100 words)"
  },
  {
    "objectID": "content/python/03-eval-dag.html#dag-for-your-program",
    "href": "content/python/03-eval-dag.html#dag-for-your-program",
    "title": "Causal model",
    "section": "3: DAG for your program",
    "text": "3: DAG for your program\nIdentify the outcome you care most about from your final project program. Draw a DAG that shows the causal effect of your program’s intervention on the outcome.\nSummarize the causal claim. Describe what needs to be controlled for and what else you included in the DAG. Justify the inclusion of each node (point) and connection (line) in the graph. (≈150 words)\nIdentify all the frontdoor and backdoor paths between your exposure and outcome. What variables need to be controlled for / adjusted to close the backdoors? How might you do this with your evaluation? (≈100 words)"
  },
  {
    "objectID": "content/python/03-problem-set.html",
    "href": "content/python/03-problem-set.html",
    "title": "Problem set 3",
    "section": "",
    "text": "Note\n\n\n\nIMPORTANT: This looks like a lot of work, but again, it’s mostly copying/pasting chunks of code and changing things.\nFor this problem set, you’ll practice analyzing RCTs and working with matching and inverse probability weighting. These two examples will be incredibly useful for you:\nYou’ll be doing all your R work in R Markdown this time (and from now on). You can download a zipped file of a pre-made project here:\nAnd as always, if you’re struggling, please talk to me. Work with classmates too (especially for this assignment!). Don’t suffer in silence!"
  },
  {
    "objectID": "content/python/03-problem-set.html#instructions",
    "href": "content/python/03-problem-set.html#instructions",
    "title": "Problem set 3",
    "section": "Instructions",
    "text": "Instructions\n\nIf you’re using R on your own computer, download this file, unzip it, and double click on the file named problem-set-3.Rproj:  problem-set-3.zip\nYou’ll need to make sure you have these packages installed on your computer: tidyverse, MatchIt, modelsummary, and patchwork. If you try to load one of those packages with library(tidyverse) or library(MatchIt), etc., and R gives an error that the package is missing, use the “Packages” panel in RStudio to install it.\n(Alternatively, you can open the project named “Problem Set 3” on RStudio.cloud and complete the assignment in your browser without needing to install anything. If you don’t have access to the class RStudio.cloud account, please let me know as soon as possible. This link should take you to the project—if it doesn’t, log in and look for the project named “Problem Set 3.”)\nRename the R Markdown file named your-name_problem-set-3.Rmd to something that matches your name and open it in RStudio.\nComplete the tasks given in the R Markdown file. There are questions marked in bold (e.g. **What is the ATE?**). Your job is to answer those questions. You don’t need to put your answers in bold, and you can remove the question text if you want.\nFill out code in the empty chunks provided (you can definitely copy, paste, and adapt from other code in the document or the example page on RCTs and the example page on matching and IPW—don’t try to write everything from scratch!).\nYou’ll need to insert your own code chunks. Rather than typing them by hand (that’s tedious!), use the “Insert” button at the top of the editing window, or press ⌥ + ⌘ + I on macOS, or ctrl + alt + I on Windows.\n\n\n\n\n\n\n\n\n\nRemember that you can run an entire chunk by clicking on the green play arrow in the top right corner of the chunk. You can also run lines of code line-by-line if you place your cursor on some R code and press ⌘ + enter (for macOS users) or ctrl + enter (for Windows users).\nMake sure you run each chunk sequentially. If you run a chunk in the middle of the document without running previous ones, it might not work, since previous chunks might do things that later chunks depend on.\nWhen you’re all done, click on the “Knit” button at the top of the editing window and create a Word or PDF version (if you’ve installed tinytex) of your document. Upload that file to iCollege. Do not upload a knitted HTML file (they don’t on iCollege)."
  },
  {
    "objectID": "content/python/final-project.html",
    "href": "content/python/final-project.html",
    "title": "Final project",
    "section": "",
    "text": "Evaluation research is tricky and costly. If you begin an intervention or launch a study prematurely, you can waste time and money—and potentially lives.\nEven if you have a well designed program with an impeccable logic model and a perfect DAG, you might discover (too late!) that you forgot to collect some critical variables or realize that your identification strategy will not work.\nFrom a more cynical perspective, you might (unethically) engage in the practice of p-hacking—running all sorts of different model specifications until you find the results you want, and then claim in your report that you had intended to run that model all along.\nOne increasingly popular method for (1) ensuring that your data and methods work before launching a study or intervention, and (2) declaring and committing to your hypotheses and methods and models before analyzing your data is to pre-register your research or evaluation. A pre-registered study contains all the background work—an introduction, literature review, theory, hypotheses, and proposed analysis—but without the actual data. Authors post their expectations and hypotheses publicly so they can be held publicly accountable for any deviations from their proposed design.1\nThe best preregistered studies use simulated data that has the same structure as the data that will be collected (i.e. same columns, sometimes the same correlations and relationships researchers expect to see in the collected data, etc.). Because there’s no data yet (or just fake data), you have more freedom when developing a preregistered study. You can experiment with different models, play with different approaches, manipulate data in different ways, and so on. If you realize that you need a new variable, or that you need to rearrange questions on a survey, or make any other kinds of changes, you can—you haven’t collected the data yet!\n(Additionally, using synthetic data is extremely useful if you’re working with proprietary or private data that you cannot make public. You can make a synthetic version of the real data instead; see this too.)\nOnce you finalize your plan and know all the data you need to collect, and once you’ve written out the different models you’ll run, all you have to do is collect the real data, plop it into your script (replacing the fake data you’d been using), and run the analysis script again to generate the actual, real results. In the results section, you get to either say “As predicted, we found…”, or “Contrary to expectations, we found that…”.\nFor your final project in this class, you will write a pre-registered analysis of a public or nonprofit social program that you’re interested in. You don’t need to worry about collecting data—you’ll create a synthetic dataset for your pre-analysis.\nYou will submit three things via iCollege:\nThis project is due by 11:59 PM on Monday, December 12, 2022.  No late work will be accepted.\nYou can either run the analysis in RStudio locally on your computer (highly recommended(!!), since you won’t have to worry about keeping all your work on RStudio’s servers), or use an RStudio.cloud project. You can make a copy of this RStudio.cloud project—it doesn’t have anything in it, but I have preinstalled all the packages we’ve used over the course of the semester, so you don’t have to."
  },
  {
    "objectID": "content/python/final-project.html#resources",
    "href": "content/python/final-project.html#resources",
    "title": "Final project",
    "section": "Resources",
    "text": "Resources\nMost importantly, do not hesitate to work with classmates. You all must choose different programs, but you can work in groups of up to 4 people on your own projects. Also, absolutely do not hesitate to ask me questions! I’m here to help!\nYou might find this evaluation (and its proposal) of a truancy program in the Provo School District in Utah helpful as an example for the first half of this assignment (program overview, theory, implementation, threats to validity, and outcomes). The PSD evaluation doesn’t have DAGs or fancy econometrics models like RCTs, diff-in-diff, RDD, IVs, or anything like that, so you can’t use it as an example of that part, but these should provide a good template for the program-specific sections. This is longer than expected for this class. I provide suggested word counts in the outline below.\n\n psd-proposal-2011\n psd-final-report-2012"
  },
  {
    "objectID": "content/python/final-project.html#suggested-outline",
    "href": "content/python/final-project.html#suggested-outline",
    "title": "Final project",
    "section": "Suggested outline",
    "text": "Suggested outline\nHere’s an outline of what you’ll need to do. You did lots of this work in your evaluation assignments. Please don’t just copy/paste those assignments as is into this final project—you’ll want to polish it up for this final report. You can download this as an RMarkdown file and change the text if you want. I’ve also included this as an RMarkdown file in the empty RStudio.cloud project.\n\n final-project-template.Rmd\n\n\n\nIntroduction\nDescribe the motivation for this evaluation, briefly describe the program to be evaluated, and explain why it matters for society. (≈150 words)\n\n\nProgram overview\nProvide in-depth background about the program. Include details about (1) when it was started, (2) why it was started, (3) what it was designed to address in society. If the program hasn’t started yet, explain why it’s under consideration. (≈300 words)\n\n\nProgram theory and implementation\n\nProgram theory and impact theory graph\nExplain and explore the program’s underlying theory. Sometimes programs will explain why they exist in a mission statement, but often they don’t and you have to infer the theory from what the program looks like when implemented. What did the program designers plan on occurring? Was this theory based on existing research? If so, cite it. (≈300 words)\nInclude a simple impact theory graph showing the program’s basic activities and outcomes. Recall from class and your reading that this is focused primarily on the theory and mechanisms, not on the implementation of the program.\n\n\nLogic model\nDescribe the program’s inputs, activities, outputs, and outcomes. Pay careful attention to how they are linked—remember that every input needs to flow into an activity and every output must flow out of an activity. (≈150 words)\nUse flowchart software to connect the inputs, activities, outputs, and outcomes and create a complete logic model. Include this as a figure.\n\n\n\nOutcome and causation\n\nMain outcome\nSelect one of the program’s outcomes to evaluate. Explain why you’ve chosen this (is it the most important? easiest to measure? has the greatest impact on society?) (≈50 words)\n\n\nMeasurement\nUsing the concept of the “ladder of abstraction” that we discussed in class (e.g. identifying a witch, measuring poverty, etc.), make a list of all the possible attributes of the outcome. Narrow this list down to 3-4 key attributes. Discuss how you decided to narrow the concepts and justify why you think these attributes capture the outcome. Then, for each of these attributes, answer these questions:\n\nMeasurable definition: How would you specifically define this attribute? (i.e. if the attribute is “reduced crime”, define it as “The percent change in crime in a specific neighborhood during a certain time frame” or something similar)\nIdeal measurement: How would you measure this attribute in an ideal world?\nFeasible measurement: How would you measure this given reality and given limitations in budget, time, etc.?\nMeasurement of program effect: How would to connect this measure to people in the program? How would you check to see if the program itself had an effect?\n\n(≈150 words in this section)\n\n\nCausal theory\nGiven your measurement approach, describe and draw a causal diagram (DAG) that shows how your program causes the outcome. Note that this is not the same thing as the logic model—you’ll likely have nodes in the DAG that aren’t related to the program at all (like socioeconomic status, gender, experience, or other factors). The logic model provides the framework for the actual implementation of your program and connects all the moving parts to the outcomes. The DAG is how you can prove causation with statistical approaches. (≈150 words)\n\n\nHypotheses\nMake predictions of your program’s effect. Declare what you think will happen. (≈50 words)\n\n\n\nData and methods\n\nIdentification strategy\nHow will you measure the actual program effect? Will you rely on an RCT? Differences-in-differences? Regression discontinuity? Instrumental variables? How does your approach account for selection bias and endogeneity? How does your approach isolate the causal effect of the program on the outcome?\nAlso briefly describe what kinds of threats to internal and external validity you face in your study.\n(≈300 words)\n\n\nData\nGiven your measurement approach, limits on feasibility, and identification strategy, describe the data you will use. Will you rely on administrative data collected by a government agency or nonprofit? Will you collect your own data? If so, what variables will you measure, and how? Will you conduct a survey or rely on outside observers or do something else? What does this data look like? What variables does it (or should it) include?\n(≈100 words)\n\n\n\nSynthetic analysis\nGenerate a synthetic (fake) dataset in R with all the variables you’ll need for the real life analysis. Analyze the data using your identification strategy. For instance:\n\nIf you’re relying on observational data, close all the backdoors with matching or inverse probability weighting, don’t adjust for colliders, and make a strong argument for isolation of the causal effect in the absence of treatment/control groups\nIf you’re doing an RCT, test the differences in means in the treatment and control groups (and follow all other best practices listed in the World Bank book, checking for balance across groups, etc.)\nIf you’re doing diff-in-diff, run a regression model with an interaction term to show the diff-in-diff\nIf you’re doing regression discontinuity, check for a jump in the outcome variable at the cutoff in the running variable\nIf you’re using instrumental variables, check the validity of your instrument and run a 2SLS model\n\nInclude robustness checks to ensure the validity of your effect (i.e. if you’re doing regression discontinuity, test different bandwidths and kernel types; etc.)\n(As many words as you need to fully describe your analysis and results)\n\n\nConclusion\nWhat would the findings from this analysis mean for your selected program? What would it mean if you found an effect? What would it mean if you didn’t find an effect? Why does any of this matter? (≈75 words)"
  },
  {
    "objectID": "content/python/index.html",
    "href": "content/python/index.html",
    "title": "Assignments",
    "section": "",
    "text": "The main goals of this class are to help you design, critique, code, and run rigorous, valid, and feasible evaluations of public sector programs. Each type of assignment in this class is designed to help you achieve one or more of these goals."
  },
  {
    "objectID": "content/python/index.html#weekly-check-in",
    "href": "content/python/index.html#weekly-check-in",
    "title": "Assignments",
    "section": "Weekly check-in",
    "text": "Weekly check-in\nEvery week, after you finish working through the content, I want to hear about what you learned and what questions you still have. Because the content in this course is flipped, these questions are crucial for our weekly in-class discussions.\nTo encourage engagement with the course content—and to allow me to collect the class’s questions each week—you’ll need to fill out a short response on iCollege. This should be ≈150 words. That’s fairly short: there are ≈250 words on a typical double-spaced page in Microsoft Word (500 when single-spaced).\nThese check-ins are due by noon on the days we have class. This is so I can look through the responses and start structuring the discussion for the evening’s class.\nYou should answer these two questions each week:\n\nWhat were the three (3) most interesting or exciting things you learned from the session? Why?\nWhat were the three (3) muddiest or unclear things from the session this week? What are you still wondering about?\n\nYou can include more than three interesting or muddiest things, but you must include at least three. There should be six easily identifiable things in each check-in: three exciting things and three questions.\nI will grade these check-ins using a check system:\n\n✔+: (11.5 points (115%) in gradebook) Response shows phenomenal thought and engagement with the course content. I will not assign these often.\n✔: (10 points (100%) in gradebook) Response is thoughtful, well-written, and shows engagement with the course content. This is the expected level of performance.\n✔−: (5 points (50%) in gradebook) Response is hastily composed, too short, and/or only cursorily engages with the course content. This grade signals that you need to improve next time. I will hopefully not assign these often.\n\nNotice that is essentially a pass/fail or completion-based system. I’m not grading your writing ability, I’m not counting the exact number of words you’re writing, and I’m not looking for encyclopedic citations of every single reading to prove that you did indeed read everything. I’m looking for thoughtful engagement, three interesting things, and three questions. That’s all. Do good work and you’ll get a ✓.\nYou will submit these check-ins via iCollege."
  },
  {
    "objectID": "content/python/index.html#problem-sets",
    "href": "content/python/index.html#problem-sets",
    "title": "Assignments",
    "section": "Problem sets",
    "text": "Problem sets\nTo practice writing R code, running inferential models, and thinking about causation, you will complete a series of problem sets.\nYou need to show that you made a good faith effort to work each question. I will not grade these in detail. The problem sets will be graded using a check system:\n\n✔+: (33 points (110%) in gradebook) Assignment is 100% completed. Every question was attempted and answered, and most answers are correct. Document is clean and easy to follow. Work is exceptional. I will not assign these often.\n✔: (30 points (100%) in gradebook) Assignment is 70–99% complete and most answers are correct. This is the expected level of performance.\n✔−: (15 points (50%) in gradebook) Assignment is less than 70% complete and/or most answers are incorrect. This indicates that you need to improve next time. I will hopefully not asisgn these often.\n\nYou may (and should!) work together on the problem sets, but you must turn in your own answers. You cannot work in groups of more than four people, and you must note who participated in the group in your assignment."
  },
  {
    "objectID": "content/python/index.html#evaluation-assignments",
    "href": "content/python/index.html#evaluation-assignments",
    "title": "Assignments",
    "section": "Evaluation assignments",
    "text": "Evaluation assignments\nFor your final project, you will conduct a pre-registered evaluation of a social program using synthetic data. To (1) give you practice with the principles of program evaluation, research design, measurement, and causal diagrams, and (2) help you with the foundation of your final project, you will complete a set of four evaluation-related assignments.\nIdeally these will become major sections of your final project. However, there is no requirement that the programs you use in these assignments must be the same as the final project. If, through these assignments, you discover that your initially chosen program is too simple, too complex, too boring, etc., you can change at any time.\nThese assignments will be graded using a check system:\n\n✔+: (33 points (110%) in gradebook) Assignment is 100% completed. Every question was attempted and answered, and most answers are correct. Document is clean and easy to follow. Work is exceptional. I will not assign these often.\n✔: (30 points (100%) in gradebook) Assignment is 70–99% complete and most answers are correct. This is the expected level of performance.\n✔−: (15 points (50%) in gradebook) Assignment is less than 70% complete and/or most answers are incorrect. This indicates that you need to improve next time. I will hopefully not asisgn these often."
  },
  {
    "objectID": "content/python/index.html#exams",
    "href": "content/python/index.html#exams",
    "title": "Assignments",
    "section": "Exams",
    "text": "Exams\nThere will be two exams covering (1) program evaluation, design, and causation, and (2) the core statistical tools of program evaluation and causal inference.\nYou will take these exams online through iCollege. The exams will have a time limit, but you can use notes and readings and the Google. You must take the exams on your own though, and not talk to anyone about them."
  },
  {
    "objectID": "content/python/index.html#final-project",
    "href": "content/python/index.html#final-project",
    "title": "Assignments",
    "section": "Final project",
    "text": "Final project\nAt the end of the course, you will demonstrate your knowledge of program evaluation and causal inference by completing a final project.\nComplete details for the final project are here.\nThere is no final exam. This project is your final exam."
  },
  {
    "objectID": "content/python/weekly-check-in.html",
    "href": "content/python/weekly-check-in.html",
    "title": "Weekly check-in",
    "section": "",
    "text": "Every week, after you finish working through the content, I want to hear about what you learned and what questions you still have. Because the content in this course is flipped, these questions are crucial for our weekly in-class discussions.\nTo encourage engagement with the course content—and to allow me to collect the class’s questions each week—you’ll need to fill out a short response on iCollege. This should be ≈150 words. That’s fairly short: there are ≈250 words on a typical double-spaced page in Microsoft Word (500 when single-spaced).\nThese check-ins are due by noon on the days we have class. This is so I can look through the responses and start structuring the discussion for the evening’s class.\nYou should answer these two questions each week:\n\nWhat were the three (3) most interesting or exciting things you learned from the session? Why?\nWhat were the three (3) muddiest or unclear things from the session this week? What are you still wondering about?\n\nYou can include more than three interesting or muddiest things, but you must include at least three. There should be six easily identifiable things in each check-in: three exciting things and three questions.\nI will grade these check-ins using a check system:\n\n✔+: (11.5 points (115%) in gradebook) Response shows phenomenal thought and engagement with the course content. I will not assign these often.\n✔: (10 points (100%) in gradebook) Response is thoughtful, well-written, and shows engagement with the course content. This is the expected level of performance.\n✔−: (5 points (50%) in gradebook) Response is hastily composed, too short, and/or only cursorily engages with the course content. This grade signals that you need to improve next time. I will hopefully not assign these often.\n\nNotice that is essentially a pass/fail or completion-based system. I’m not grading your writing ability, I’m not counting the exact number of words you’re writing, and I’m not looking for encyclopedic citations of every single reading to prove that you did indeed read everything. I’m looking for thoughtful engagement, three interesting things, and three questions. That’s all. Do good work and you’ll get a ✓.\nYou will submit these check-ins via iCollege."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Joschka Schwarz",
    "section": "",
    "text": "Joschka Schwarz is the Chief Data Scientist at Wengo Analytics. When not innovating on data platforms, Finley enjoys spending time unicycling and playing with her pet iguana."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Joschka Schwarz",
    "section": "Education",
    "text": "Education\nUniversity of California, San Diego | San Diego, CA PhD in Mathematics | Sept 2011 - June 2015\nMacalester College | St. Paul MA B.A in Economics | Sept 2007 - June 2011"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Joschka Schwarz",
    "section": "Experience",
    "text": "Experience\nWengo Analytics | Head Data Scientist | April 2018 - present\nGeoScynce | Chief Analyst | Spet 2012 - April 2018"
  },
  {
    "objectID": "resumes.html",
    "href": "resumes.html",
    "title": "Resumes",
    "section": "",
    "text": "Classic\n\n\nClassical themed CV\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpotify\n\n\nSpotify themed CV\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "resumes/classic/index.html",
    "href": "resumes/classic/index.html",
    "title": "Classic",
    "section": "",
    "text": "Put spotify cv here"
  },
  {
    "objectID": "resumes/index.html",
    "href": "resumes/index.html",
    "title": "Resumes overview",
    "section": "",
    "text": "Classic\n\n\nClassical themed CV\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpotify\n\n\nSpotify themed CV\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "resumes/spotify/index.html",
    "href": "resumes/spotify/index.html",
    "title": "Spotify",
    "section": "",
    "text": "Put spotify cv here"
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#quarto",
    "href": "revealjs/slides/2022/first/first.html#quarto",
    "title": "First",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished presentation. To learn more about Quarto presentations see https://quarto.org/docs/presentations/."
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#bullets",
    "href": "revealjs/slides/2022/first/first.html#bullets",
    "title": "First",
    "section": "Bullets",
    "text": "Bullets\nWhen you click the Render button a document will be generated that includes:\n\nContent authored with markdown\nOutput from executable code"
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#code",
    "href": "revealjs/slides/2022/first/first.html#code",
    "title": "First",
    "section": "Code",
    "text": "Code\nWhen you click the Render button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n[1] 2"
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#why",
    "href": "revealjs/slides/2022/first/first.html#why",
    "title": "First",
    "section": "Why",
    "text": "Why\nWhen you click the Render button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n[1] 2"
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#same",
    "href": "revealjs/slides/2022/first/first.html#same",
    "title": "First",
    "section": "Same",
    "text": "Same\nWhen you click the Render button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n[1] 2"
  },
  {
    "objectID": "revealjs/slides/2022/first/first.html#different",
    "href": "revealjs/slides/2022/first/first.html#different",
    "title": "First",
    "section": "Different",
    "text": "Different\nWhen you click the Render button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n\n[1] 2"
  },
  {
    "objectID": "slides/index.html",
    "href": "slides/index.html",
    "title": "Presentations overview",
    "section": "",
    "text": "Visit this section after you have finished the readings and lecture videos. It contains fully annotated R code and other supplementary information and it will be indispensable as you work on your problem sets and project.\nMany sections also contain videos of me live coding the examples so you can see what it looks like to work with R in real time. You’ll notice me make all sorts of little errors, which is totally normal—everyone does!"
  },
  {
    "objectID": "slides/random-numbers.html",
    "href": "slides/random-numbers.html",
    "title": "Generating random numbers",
    "section": "",
    "text": "In your final project, you will generate a synthetic dataset and use it to conduct an evaluation of some social program. Generating fake or simulated data is an incredibly powerful skill, but it takes some practice. Here are a bunch of helpful resources and code examples of how to use different R functions to generate random numbers that follow specific distributions (or probability shapes).\nThis example focuses primarily on distributions. Each of the columns you’ll generate will be completely independent from each other and there will be no correlation between them. The example for generating synthetic data provides code and a bunch of examples of how to build in correlations between columns.\nFirst, make sure you load the libraries we’ll use throughout the example:"
  },
  {
    "objectID": "slides/random-numbers.html#seeds",
    "href": "slides/random-numbers.html#seeds",
    "title": "Generating random numbers",
    "section": "Seeds",
    "text": "Seeds\nWhen R (or any computer program, really) generates random numbers, it uses an algorithm to simulate randomness. This algorithm always starts with an initial number, or seed. Typically it will use something like the current number of milliseconds since some date, so that every time you generate random numbers they’ll be different. Look at this, for instance:\n\n# Choose 3 numbers between 1 and 10\nsample(1:10, 3)\n\n\n# Choose 3 numbers between 1 and 10\nsample(1:10, 3)\n\nThey’re different both times.\nThat’s ordinarily totally fine, but if you care about reproducibility (like having a synthetic dataset with the same random values, or having jittered points in a plot be in the same position every time you knit), it’s a good idea to set your own seed. This ensures that the random numbers you generate are the same every time you generate them.\nDo this by feeding set.seed() some numbers. It doesn’t matter what number you use—it just has to be a whole number. People have all sorts of favorite seeds:\n\n1\n13\n42\n1234\n12345\n20201101 (i.e. the current date)\n8675309\n\nYou could even go to random.org and use atmospheric noise to generate a seed, and then use that in R.\nHere’s what happens when you generate random numbers after setting a seed:\n\n# Set a seed\nset.seed(1234)\n\n# Choose 3 numbers between 1 and 10\nsample(1:10, 3)\n\n# Set a seed\nset.seed(1234)\n\n# Choose another 3 numbers between 1 and 10\nsample(1:10, 3)\n\nThey’re the same!\nOnce you set a seed, it influences any function that does anything random, but it doesn’t reset. For instance, if you set a seed once and then run sample() twice, you’ll get different numbers the second time, but you’ll get the same different numbers every time:\n\n# Set a seed\nset.seed(1234)\n\n# Choose 3 numbers between 1 and 10\nsample(1:10, 3)\nsample(1:10, 3)  # This will be different!\n\n# Set a seed again\nset.seed(1234)\n\n# Choose 3 numbers between 1 and 10\nsample(1:10, 3)\nsample(1:10, 3)  # This will be different, but the same as before!\n\nTypically it’s easiest to just include set.seed(SOME_NUMBER) at the top of your script after you load all the libraries. Some functions have a seed argument, and it’s a good idea to use it: position_jitter(..., seed = 1234)."
  },
  {
    "objectID": "slides/random-numbers.html#distributions",
    "href": "slides/random-numbers.html#distributions",
    "title": "Generating random numbers",
    "section": "Distributions",
    "text": "Distributions\nRemember in elementary school when you’d decide on playground turns by saying “Pick a number between 1 and 10” and whoever was the closest would win? When you generate random numbers in R, you’re essentially doing the same thing, only with some fancier bells and whistles.\nWhen you ask someone to choose a number between 1 and 10, any of those numbers should be equally likely. 1 isn’t really less common than 5 or anything. In some situations, though, there are numbers that are more likely to appear than others (i.e. when you roll two dice, it’s pretty rare to get a 2, but pretty common to get a 7). These different kinds of likelihood change the shape of the distribution of possible values. There are hundreds of different distributions, but for the sake of generating data, there are only a few that you need to know.\n\nUniform distribution\nIn a uniform distribution, every number is equally likely. This is the “pick a number between 1 and 10” scenario, or rolling a single die. There are a couple ways to work with a uniform distribution in R: (1) sample() and (2) runif().\n\nsample()\nThe sample() function chooses an element from a list.\nFor instance, let’s pretend we have six possible numbers (like a die, or like 6 categories on a survey), like this:\n\npossible_answers <- c(1, 2, 3, 4, 5, 6)  # We could also write this as 1:6 instead\n\nIf we want to randomly choose from this list, you’d use sample(). The size argument defines how many numbers to choose.\n\n# Choose 1 random number\nsample(possible_answers, size = 1)\n\n# Choose 3 random numbers\nsample(possible_answers, size = 3)\n\nOne important argument you can use is replace, which essentially puts the number back into the pool of possible numbers. Imagine having a bowl full of ping pong balls with the numbers 1–6 on them. If you take the number “3” out, you can’t draw it again. If you put it back in, you can pull it out again. The replace argument puts the number back after it’s drawn:\n\n# Choose 10 random numbers, with replacement\nsample(possible_answers, size = 10, replace = TRUE)\n\nIf you don’t specify replace = TRUE, and you try to choose more numbers than are in the set, you’ll get an error:\n\n# Choose 8 numbers between 1 and 6, but don't replace them.\n# This won't work!\nsample(possible_answers, size = 8)\n\nIt’s hard to see patterns in the outcomes when generating just a handful of numbers, but easier when you do a lot. Let’s roll a die 1,000 times:\n\nset.seed(1234)\ndie <- tibble(value = sample(possible_answers,\n                             size = 1000,\n                             replace = TRUE))\ndie %>%\n  count(value)\n\nggplot(die, aes(x = value)) +\n  geom_bar() +\n  labs(title = \"1,000 rolls of a single die\")\n\nIn this case, 3 and 6 came up more often than the others, but that’s just because of randomness. If we rolled the die 100,000 times, the bars should basically be the same:\n\nset.seed(1234)\ndie <- tibble(value = sample(possible_answers,\n                             size = 100000,\n                             replace = TRUE))\n\nggplot(die, aes(x = value)) +\n  geom_bar() +\n  labs(title = \"100,000 rolls of a single die\")\n\n\n\nrunif()\nAnother way to generate uniformly distributed numbers is to use the runif() function (which is short for “random uniform”, and which took me years to realize, and for years I wondered why people used a function named “run if” when there’s no if statement anywhere??)\nrunif() will choose numbers between a minimum and a maximum. These numbers will not be whole numbers. By default, the min and max are 0 and 1:\n\nrunif(5)\n\nHere are 5 numbers between 35 and 56:\n\nrunif(5, min = 35, max = 56)\n\nSince these aren’t whole numbers, you can round them to make them look more realistic (like, if you were generating a column for age, you probably don’t want people who are 21.5800283 years old):\n\n# Generate 5 people between the ages of 18 and 35\nround(runif(5, min = 18, max = 35), 0)\n\nYou can confirm that each number has equal probability if you make a histogram. Here are 5,000 random people between 18 and 35:\n\nset.seed(1234)\nlots_of_numbers <- tibble(x = runif(5000, min = 18, max = 35))\n\nggplot(lots_of_numbers, aes(x = x)) +\n  geom_histogram(binwidth = 1, color = \"white\", boundary = 18)\n\n\n\n\nNormal distribution\nThe whole “choose a number between 1 and 10” idea of a uniform distribution is neat and conceptually makes sense, but most numbers that exist in the world tend to have higher probabilities around certain values—almost like gravity around a specific point. For instance, income in the United States is not uniformly distributed—a handful of people are really really rich, lots are very poor, and most are kind of clustered around an average.\nThe idea of having possible values clustered around an average is how the rest of these distributions work (uniform distributions don’t have any sort of central gravity point; all these others do). Each distribution is defined by different things called parameters, or values that determine the shape of the probabilities and locations of the clusters.\nA super common type of distribution is the normal distribution. This is the famous “bell curve” you learn about in earlier statistics classes. A normal distribution has two parameters:\n\nA mean (the center of the cluster)\nA standard deviation (how much spread there is around the mean).\n\nIn R, you can generate random numbers from a normal distribution with the rnorm() function. It takes three arguments: the number of numbers you want to generate, the mean, and the standard deviation. It defaults to a mean of 0 and a standard deviation of 1, which means most numbers will cluster around 0, with a lot between −1 and 1, and some going up to −2 and 2 (technically 67% of numbers will be between −1 and 1, while 95% of numbers will be between −2–2ish)\n\nrnorm(5)\n\n# Cluster around 10, with an SD of 4\nrnorm(5, mean = 10, sd = 4)\n\nWhen working with uniform distributions, it’s easy to know how high or low your random values might go, since you specify a minimum and maximum number. With a normal distribution, you don’t specify starting and ending points—you specify a middle and a spread, so it’s harder to guess the whole range. Plotting random values is thus essential. Here’s 1,000 random numbers clustered around 10 with a standard deviation of 4:\n\nset.seed(1234)\n\nplot_data <- tibble(x = rnorm(1000, mean = 10, sd = 4))\nhead(plot_data)\n\nggplot(plot_data, aes(x = x)) +\n  geom_histogram(binwidth = 1, boundary = 0, color = \"white\")\n\nNeat. Most numbers are around 10; lots are between 5 and 15; some go as high as 25 and as low as −5.\nWatch what happens if you change the standard deviation to 10 to make the spread wider:\n\nset.seed(1234)\n\nplot_data <- tibble(x = rnorm(1000, mean = 10, sd = 10))\nhead(plot_data)\n\nggplot(plot_data, aes(x = x)) +\n  geom_histogram(binwidth = 1, boundary = 0, color = \"white\")\n\nIt’s still centered around 10, but now you get values as high as 40 and as low as −20. The data is more spread out now.\nWhen simulating data, you’ll most often use a normal distribution just because it’s easy and lots of things follow that pattern in the real world. Incomes, ages, education, etc. all have a kind of gravity to them, and a normal distribution is a good way of showing that gravity. For instance, here are 1,000 simulated people with reasonable random incomes, ages, and years of education:\n\nset.seed(1234)\n\nfake_people <- tibble(income = rnorm(1000, mean = 40000, sd = 15000),\n                      age = rnorm(1000, mean = 25, sd = 8),\n                      education = rnorm(1000, mean = 16, sd = 4))\nhead(fake_people)\n\nfake_income <- ggplot(fake_people, aes(x = income)) +\n  geom_histogram(binwidth = 5000, color = \"white\", boundary = 0) +\n  labs(title = \"Simulated income\")\n\nfake_age <- ggplot(fake_people, aes(x = age)) +\n  geom_histogram(binwidth = 2, color = \"white\", boundary = 0) +\n  labs(title = \"Simulated age\")\n\nfake_education <- ggplot(fake_people, aes(x = education)) +\n  geom_histogram(binwidth = 2, color = \"white\", boundary = 0) +\n  labs(title = \"Simulated education\")\n\nfake_income + fake_age + fake_education\n\nThese three columns all have different centers and spreads. Income is centered around $45,000, going up to almost $100,000 and as low as −$10,000; age is centered around 25, going as low as 0 and as high as 50; education is centered around 16, going as low as 3 and as high as 28. Cool.\nAgain, when generating these numbers, it’s really hard to know how high or low these ranges will be, so it’s a good idea to plot them constantly. I settled on sd = 4 for education only because I tried things like 1 and 10 and got wild looking values (everyone basically at 16 with little variation, or everyone ranging from −20 to 50, which makes no sense when thinking about years of education). Really it’s just a process of trial and error until the data looks good and reasonable.\n\n\nTruncated normal distribution\nSometimes you’ll end up with negative numbers that make no sense. Look at income in the plot above, for instance. Some people are earning −$10,000 year. The rest of the distribution looks okay, but those negative values are annoying.\nTo fix this, you can use something called a truncated normal distribution, which lets you specify a mean and standard deviation, just like a regular normal distribution, but also lets you specify a minimum and/or maximum so you don’t get values that go too high or too low.\nR doesn’t have a truncated normal function built-in, but you can install the truncnorm package and use the rtruncnorm() function. A truncated normal distribution has four parameters:\n\nA mean (mean)\nA standard deviation (sd)\nA minimum (optional) (a)\nA maximum (optional) (b)\n\nFor instance, let’s pretend you have a youth program designed to target people who are between 12 and 21 years old, with most around 14. You can generate numbers with a mean of 14 and a standard deviation of 5, but you’ll create people who are too old, too young, or even negatively aged!\n\nset.seed(1234)\n\nplot_data <- tibble(fake_age = rnorm(1000, mean = 14, sd = 5))\nhead(plot_data)\n\nggplot(plot_data, aes(x = fake_age)) +\n  geom_histogram(binwidth = 2, color = \"white\", boundary = 0)\n\nTo fix this, truncate the range at 12 and 21:\n\nlibrary(truncnorm)  # For rtruncnorm()\n\nset.seed(1234)\n\nplot_data <- tibble(fake_age = rtruncnorm(1000, mean = 14, sd = 5, a = 12, b = 21))\nhead(plot_data)\n\nggplot(plot_data, aes(x = fake_age)) +\n  geom_histogram(binwidth = 1, color = \"white\", boundary = 0)\n\nAnd voila! A bunch of people between 12 and 21, with most around 14, with no invalid values.\n\n\nBeta distribution\nNormal distributions are neat, but they’re symmetrical around the mean (unless you truncate them). What if your program involves a test with a maximum of 100 points where most people score around 85, but a sizable portion score below that. In other words, it’s not centered at 85, but is skewed left.\nTo simulate this kind of distribution, we can use a Beta distribution. Beta distributions are neat because they naturally only range between 0 and 1—they’re perfect for things like percentages or proportions or or 100-based exams.\nUnlike a normal distribution, where you use the mean and standard deviation as parameters, Beta distributions take two non-intuitive parameters:\n\nshape1\nshape2\n\nWhat the heck are these shapes though?! This answer at Cross Validated does an excellent job of explaining the intuition behind Beta distributions and it’d be worth it to read it.\nBasically, Beta distributions are good at modeling probabilities of things, and shape1 and shape2 represent specific parts of a probability formula.\nLet’s say that there’s an exam with 10 points where most people score a 6/10. Another way to think about this is that an exam is a collection of correct answers and incorrect answers, and that the percent correct follows this equation:\n\\[\n\\frac{\\text{Number correct}}{\\text{Number correct} + \\text{Number incorrect}}\n\\]\nIf you scored a 6, you could write that as:\n\\[\n\\frac{6}{6 + 4}\n\\]\nTo make it more general, we can use Greek variable names: \\(\\alpha\\) for the number correct and \\(\\beta\\) for the number incorrect, leaving us with this:\n\\[\n\\frac{\\alpha}{\\alpha + \\beta}\n\\]\nNeat.\nIn a Beta distribution, the \\(\\alpha\\) and \\(\\beta\\) in that equation correspond to shape1 and shape2. If we want to generate random scores for this test where most people get 6/10, we can use rbeta():\n\nset.seed(1234)\n\nplot_data <- tibble(exam_score = rbeta(1000, shape1 = 6, shape2 = 4)) %>%\n  # rbeta() generates numbers between 0 and 1, so multiply everything by 10 to\n  # scale up the exam scores\n  mutate(exam_score = exam_score * 10)\n\nggplot(plot_data, aes(x = exam_score)) +\n  geom_histogram(binwidth = 1, color = \"white\") +\n  scale_x_continuous(breaks = 0:10)\n\nMost people score around 6, with a bunch at 5 and 7, and fewer in the tails. Importantly, it’s not centered at 6—the distribution is asymmetric.\nThe magic of—and most confusing part about—Beta distributions is that you can get all sorts of curves by just changing the shape parameters. To make this easier to see, we can make a bunch of different Beta distributions. Instead of plotting them with histograms, we’ll use density plots (and instead of generating random numbers, we’ll plot the actual full range of the distribution (that’s what dbeta and geom_function() do in all these examples)).\nHere’s what we saw before, with \\(\\alpha\\) (shape1) = 6 and \\(\\beta\\) (shape2) = 4:\n\nggplot() +\n  geom_function(fun = ~dbeta(.x, shape1 = 6, shape2 = 4))\n\nAgain, there’s a peak at 0.6 (or 6), which is what we expected.\nWe can make the distribution narrower if we scale the shapes up. Here pretty much everyone scores around 50% and 75%.\n\nggplot() +\n  geom_function(fun = ~dbeta(.x, shape1 = 60, shape2 = 40))\n\nSo far all these curves look like normal distributions, just slightly skewed. But when if most people score 90–100%? Or most fail? A Beta distribution can handle that too:\n\nggplot() +\n  geom_function(fun = ~dbeta(.x, shape1 = 9, shape2 = 1), color = \"blue\") +\n  geom_function(fun = ~dbeta(.x, shape1 = 1, shape2 = 9), color = \"red\")\n\nWith shape1 = 9 and shape2 = 1 (or \\(\\frac{9}{9 + 1}\\)) we get most around 90%, while shape1 = 1 and shape2 = 9 (or \\(\\frac{1}{1 + 9}\\)) gets us most around 10%.\nCheck out all these other shapes too:\n\nggplot() +\n  geom_function(fun = ~dbeta(.x, shape1 = 5, shape2 = 5), color = \"blue\") +\n  geom_function(fun = ~dbeta(.x, shape1 = 2, shape2 = 5), color = \"red\") +\n  geom_function(fun = ~dbeta(.x, shape1 = 80, shape2 = 23), color = \"orange\") +\n  geom_function(fun = ~dbeta(.x, shape1 = 13, shape2 = 17), color = \"brown\")\n\nIn real life, if I don’t want to figure out the math behind the \\(\\frac{\\alpha}{\\alpha + \\beta}\\) shape values, I end up just choosing different numbers until it looks like the shape I want, and then I use rbeta() with those parameter values. Like, how about we generate some numbers based on the red line above, with shape1 = 2 and shape2 = 5, which looks like it should be centered around 0.2ish (\\(\\frac{2}{2 + 5} = 0.2857\\)):\n\nset.seed(1234)\n\nplot_data <- tibble(thing = rbeta(1000, shape1 = 2, shape2 = 5)) %>%\n  mutate(thing = thing * 100)\nhead(plot_data)\n\nggplot(plot_data, aes(x = thing)) +\n  geom_histogram(binwidth = 2, color = \"white\", boundary = 0)\n\nIt worked! Most values are around 20ish, but some go up to 60–80.\n\n\nBinomial distribution\nOften you’ll want to generate a column that only has two values: yes/no, treated/untreated, before/after, big/small, red/blue, etc. You’ll also likely want to control the proportions (25% treated, 62% blue, etc.). You can do this in two different ways: (1) sample() and (2) rbinom().\n\nsample()\nWe already saw sample() when we talked about uniform distributions. To generate a binary variable with sample(), just feed it a list of two possible values:\n\nset.seed(1234)\n\n# Choose 5 random T/F values\npossible_things <- c(TRUE, FALSE)\nsample(possible_things, 5, replace = TRUE)\n\nR will choose these values with equal/uniform probability by default, but you can change that in sample() with the prob argument. For instance, pretend you want to simulate an election. According to the latest polls, one candidate has an 80% chance of winning. You want to randomly choose a winner based on that chance. Here’s how to do that with sample():\n\nset.seed(1234)\ncandidates <- c(\"Person 1\", \"Person 2\")\nsample(candidates, size = 1, prob = c(0.8, 0.2))\n\nPerson 1 wins!\nIt’s hard to see the weighted probabilities when you just choose one, so let’s pretend there are 1,000 elections:\n\nset.seed(1234)\nfake_elections <- tibble(winner = sample(candidates,\n                                         size = 1000,\n                                         prob = c(0.8, 0.2),\n                                         replace = TRUE))\nfake_elections %>%\n  count(winner)\n\nggplot(fake_elections, aes(x = winner)) +\n  geom_bar()\n\nPerson 1 won 792 of the elections. Neat.\n(This is essentially what election forecasting websites like FiveThirtyEight do! They just do it with way more sophisticated simulations.)\n\n\nrbinom()\nInstead of using sample(), you can use a formal distribution called the binomial distribution. This distribution is often used for things that might have “trials” or binary outcomes that are like success/failure or yes/no or true/false\nThe binomial distribution takes two parameters:\n\nsize: The number of “trials”, or times that an event happens\nprob: The probability of success in each trial\n\nIt’s easiest to see some examples of this. Let’s say you have a program that has a 60% success rate and it is tried on groups of 20 people 5 times. The parameters are thus size = 20 (since there are twenty people per group) and prob = 0.6 (since there is a 60% chance of success):\n\nset.seed(1234)\n\nrbinom(5, size = 20, prob = 0.6)\n\nThe results here mean that in group 1, 15/20 (75%) people had success, in group 2, 11/20 (55%) people had success, and so on. Not every group will have exactly 60%, but they’re all kind of clustered around that.\nHOWEVER, I don’t like using rbinom() like this, since this is all group-based, and when you’re generating fake people you generally want to use individuals, or groups of 1. So instead, I assume that size = 1, which means that each “group” is only one person large. This forces the generated numbers to either be 0 or 1:\n\nset.seed(1234)\n\nrbinom(5, size = 1, prob = 0.6)\n\nHere, only 1 of the 5 people were 1/TRUE/yes, which is hardly close to a 60% chance overall, but that’s because we only generated 5 numbers. If we generate lots, we can see the probability of yes emerge:\n\nset.seed(12345)\n\nplot_data <- tibble(thing = rbinom(2000, 1, prob = 0.6)) %>%\n  # Make this a factor since it's basically a yes/no categorical variable\n  mutate(thing = factor(thing))\n\nplot_data %>%\n  count(thing) %>%\n  mutate(proportion = n / sum(n))\n\nggplot(plot_data, aes(x = thing)) +\n  geom_bar()\n\n58% of the 2,000 fake people here were 1/TRUE/yes, which is close to the goal of 60%. Perfect.\n\n\n\nPoisson distribution\nOne last common distribution that you might find helpful when simulating data is the Poisson distribution (in French, “poisson” = fish, but here it’s not actually named after the animal, but after French mathematician Siméon Denis Poisson).\nA Poisson distribution is special because it generates whole numbers (i.e. nothing like 1.432) that follow a skewed pattern (i.e. more smaller values than larger values). There’s all sorts of fancy math behind it that you don’t need to worry about so much—all you need to know is that it’s good at modeling things called Poisson processes.\nFor instance, let’s say you’re sitting at the front door of a coffee shop (in pre-COVID days) and you count how many people are in each arriving group. You’ll see something like this:\n\n1 person\n1 person\n2 people\n1 person\n3 people\n2 people\n1 person\n\nLots of groups of one, some groups of two, fewer groups of three, and so on. That’s a Poisson process: a bunch of independent random events that combine into grouped events.\nThat sounds weird and esoteric (and it is!), but it reflects lots of real world phenomena, and things you’ll potentially want to measure in a program. For instance, the number of kids a family has follows a type of Poisson process. Lots of families have 1, some have 2, fewer have 3, even fewer have 4, and so on. The number of cars in traffic, the number of phone calls received by an office, arrival times in a line, and even the outbreak of wars are all examples of Poisson processes.\nYou can generate numbers from a Poisson distribution with the rpois() function in R. This distribution only takes a single parameter:\n\nlambda (\\(\\lambda\\))\n\nThe \\(\\lambda\\) value controls the rate or speed that a Poisson process increases (i.e. jumps from 1 to 2, from 2 to 3, from 3 to 4, etc.). I have absolutely zero mathematical intuition for how it works. The two shape parameters for a Beta distribution at least fit in a fraction and you can wrap your head around that, but the lambda in a Poisson distribution is just a mystery to me. So whenever I use a Poisson distribution for something, I just play with the lambda until the data looks reasonable.\nLet’s assume that the number of kids a family has follows a Poisson process. Here’s how we can use rpois() to generate that data:\n\nset.seed(123)\n\n# 10 different families\nrpois(10, lambda = 1)\n\nCool. Most families have 0–1 kids; some have 2; one has 3.\nIt’s easier to see these patterns with a plot:\n\nset.seed(1234)\n\nplot_data <- tibble(num_kids = rpois(500, lambda = 1))\nhead(plot_data)\n\nplot_data %>%\n  group_by(num_kids) %>%\n  summarize(count = n()) %>%\n  mutate(proportion = count / sum(count))\n\nggplot(plot_data, aes(x = num_kids)) +\n  geom_bar()\n\nHere 75ish% of families have 0–1 kids (36% + 37.4%), 17% have 2 kids, 6% have 3, 2% have 4, and only 0.6% have 5.\nWe can play with the \\(\\lambda\\) to increase the rate of kids per family:\n\nset.seed(1234)\n\nplot_data <- tibble(num_kids = rpois(500, lambda = 2))\nhead(plot_data)\n\nplot_data %>%\n  group_by(num_kids) %>%\n  summarize(count = n()) %>%\n  mutate(proportion = count / sum(count))\n\nggplot(plot_data, aes(x = num_kids)) +\n  geom_bar()\n\nNow most families have 1–2 kids. Cool."
  },
  {
    "objectID": "slides/random-numbers.html#rescaling-numbers",
    "href": "slides/random-numbers.html#rescaling-numbers",
    "title": "Generating random numbers",
    "section": "Rescaling numbers",
    "text": "Rescaling numbers\nAll these different distributions are good at generating general shapes:\n\nUniform: a bunch of random numbers with no central gravity\nNormal: an average ± some variation\nBeta: different shapes and skews and gravities between 0 and 1\nBinomial: yes/no outcomes that follow some probability\n\nThe shapes are great, but you also care about the values of these numbers. This can be tricky. As we saw earlier with a normal distribution, sometimes you’ll get values that go below zero or above some value you care about. We fixed that with a truncated normal distribution, but not all distributions have truncated versions. Additionally, if you’re using a Beta distribution, you’re stuck in a 0–1 scale (or 0–10 or 0–100 if you multiply the value by 10 or 100 or whatever).\nWhat if you want a fun skewed Beta shape for a variable like income or some other value that doesn’t fit within a 0–1 range? You can rescale any set of numbers after-the-fact using the rescale() function from the scales library and rescale things to whatever range you want.\nFor instance, let’s say that income isn’t normally distributed, but is right-skewed with a handful of rich people. This might look like a Beta distribution with shape1 = 2 and shape2 = 5:\n\nggplot() +\n  geom_function(fun = ~dbeta(.x, shape1 = 2, shape2 = 5))\n\nIf we generate random numbers from this distribution, they’ll all be stuck between 0 and 1:\n\nset.seed(1234)\n\nfake_people <- tibble(income = rbeta(1000, shape1 = 2, shape2 = 5))\n\nggplot(fake_people, aes(x = income)) +\n  geom_histogram(binwidth = 0.1, color = \"white\", boundary = 0)\n\nWe can take those underling 0–1 values and rescale them to some other range using the rescale() function. We can specify the minimum and maximum values in the to argument. Here we’ll scale it up so that 0 = $10,000 and 1 = $100,000. Our rescaled version follows the same skewed Beta distribution shape, but now we’re using better values!\n\nlibrary(scales)\n\nfake_people_scaled <- fake_people %>%\n  mutate(income_scaled = rescale(income, to = c(10000, 100000)))\nhead(fake_people_scaled)\n\nggplot(fake_people_scaled, aes(x = income_scaled)) +\n  geom_histogram(binwidth = 5000, color = \"white\", boundary = 0)\n\nThis works for anything, really. For instance, instead of specifying a mean and standard deviation for a normal distribution and hoping that the generated values don’t go too high or too low, you can generate a normal distribution with a mean of 0 and standard deviation of 1 and then rescale it to the range you want:\n\nset.seed(1234)\n\nfake_data <- tibble(age_not_scaled = rnorm(1000, mean = 0, sd = 1)) %>%\n  mutate(age = rescale(age_not_scaled, to = c(18, 65)))\nhead(fake_data)\n\nplot_unscaled <- ggplot(fake_data, aes(x = age_not_scaled)) +\n  geom_histogram(binwidth = 0.5, color = \"white\", boundary = 0)\n\nplot_scaled <- ggplot(fake_data, aes(x = age)) +\n  geom_histogram(binwidth = 5, color = \"white\", boundary = 0)\n\nplot_unscaled + plot_scaled\n\nThis gives you less control over the center of the distribution (here it happens to be 40 because that’s in the middle of 18 and 65), but it gives you more control over the edges of the distribution.\nRescaling things is really helpful when building in effects and interacting columns with other columns, since multiplying variables by different coefficients can make the values go way out of the normal range. You’ll see a lot more of that in the synthetic data example."
  },
  {
    "objectID": "slides/random-numbers.html#summary",
    "href": "slides/random-numbers.html#summary",
    "title": "Generating random numbers",
    "section": "Summary",
    "text": "Summary\nPhew. We covered a lot here, and we barely scratched the surface of all the distributions that exist. Here’s a helpful summary of the main distributions you should care about:"
  },
  {
    "objectID": "slides/random-numbers.html#example",
    "href": "slides/random-numbers.html#example",
    "title": "Generating random numbers",
    "section": "Example",
    "text": "Example\nAnd here’s an example dataset of 1,000 fake people and different characteristics. One shortcoming of this fake data is that each of these columns is completely independent—there’s no relationship between age and education and family size and income. You can see how to make these columns correlated (and make one cause another!) in the example for synthetic data.\n\nset.seed(1234)\n\n# Set the number of people here once so it's easier to change later\nn_people <- 1000\n\nexample_fake_people <- tibble(\n  id = 1:n_people,\n  opinion = sample(1:5, n_people, replace = TRUE),\n  age = runif(n_people, min = 18, max = 80),\n  income = rnorm(n_people, mean = 50000, sd = 10000),\n  education = rtruncnorm(n_people, mean = 16, sd = 6, a = 8, b = 24),\n  happiness = rbeta(n_people, shape1 = 2, shape2 = 1),\n  treatment = sample(c(TRUE, FALSE), n_people, replace = TRUE, prob = c(0.3, 0.7)),\n  size = rbinom(n_people, size = 1, prob = 0.5),\n  family_size = rpois(n_people, lambda = 1) + 1  # Add one so there are no 0s\n) %>%\n  # Adjust some of these columns\n  mutate(opinion = recode(opinion, \"1\" = \"Strongly disagree\",\n                          \"2\" = \"Disagree\", \"3\" = \"Neutral\",\n                          \"4\" = \"Agree\", \"5\" = \"Strongly agree\")) %>%\n  mutate(size = recode(size, \"0\" = \"Small\", \"1\" = \"Large\")) %>%\n  mutate(happiness = rescale(happiness, to = c(1, 8)))\n\nhead(example_fake_people)\n\n\nplot_opinion <- ggplot(example_fake_people, aes(x = opinion)) +\n  geom_bar() +\n  guides(fill = \"none\") +\n  labs(title = \"Opinion (uniform with sample())\")\n\nplot_age <- ggplot(example_fake_people, aes(x = age)) +\n  geom_histogram(binwidth = 5, color = \"white\", boundary = 0) +\n  labs(title = \"Age (uniform with runif())\")\n\nplot_income <- ggplot(example_fake_people, aes(x = income)) +\n  geom_histogram(binwidth = 5000, color = \"white\", boundary = 0) +\n  labs(title = \"Income (normal)\")\n\nplot_education <- ggplot(example_fake_people, aes(x = education)) +\n  geom_histogram(binwidth = 2, color = \"white\", boundary = 0) +\n  labs(title = \"Education (truncated normal)\")\n\nplot_happiness <- ggplot(example_fake_people, aes(x = happiness)) +\n  geom_histogram(binwidth = 1, color = \"white\") +\n  scale_x_continuous(breaks = 1:8) +\n  labs(title = \"Happiness (Beta, rescaled to 1-8)\")\n\nplot_treatment <- ggplot(example_fake_people, aes(x = treatment)) +\n  geom_bar() +\n  labs(title = \"Treatment (binary with sample())\")\n\nplot_size <- ggplot(example_fake_people, aes(x = size)) +\n  geom_bar() +\n  labs(title = \"Size (binary with rbinom())\")\n\nplot_family <- ggplot(example_fake_people, aes(x = family_size)) +\n  geom_bar() +\n  scale_x_continuous(breaks = 1:7) +\n  labs(title = \"Family size (Poisson)\")\n\n(plot_opinion + plot_age) / (plot_income + plot_education)\n\n\n(plot_happiness + plot_treatment) / (plot_size + plot_family)"
  },
  {
    "objectID": "slides/slides_2021.html",
    "href": "slides/slides_2021.html",
    "title": "2021",
    "section": "",
    "text": "First presentation\n\n\n\n\n\n\nSecond presentation"
  },
  {
    "objectID": "slides/slides_2022.html",
    "href": "slides/slides_2022.html",
    "title": "2022",
    "section": "",
    "text": "First presentation"
  },
  {
    "objectID": "slides/synthetic-data.html",
    "href": "slides/synthetic-data.html",
    "title": "The ultimate guide to generating synthetic data for causal inference",
    "section": "",
    "text": "In the example guide for generating random numbers, we explored how to use a bunch of different statistical distributions to create variables that had reasonable values. However, each of the columns that we generated there were completely independent of each other. In the final example, we made some data with columns like age, education, and income, but none of those were related, though in real life they would be.\nGenerating random variables is fairly easy: choose some sort of distributional shape, set parameters like a mean and standard deviation, and let randomness take over. Forcing variables to be related is a little trickier and involves a little math. But don’t worry! That math is all just regression stuff!"
  },
  {
    "objectID": "slides/synthetic-data.html#basic-example",
    "href": "slides/synthetic-data.html#basic-example",
    "title": "The ultimate guide to generating synthetic data for causal inference",
    "section": "Basic example",
    "text": "Basic example\n\nRelationships and regression\nLet’s pretend we want to predict someone’s happiness on a 10-point scale based on the number of cookies they’ve eaten and whether or not their favorite color is blue.\n\\[\n\\text{Happiness} = \\beta_0 + \\beta_1 \\text{Cookies eaten} + \\beta_2 \\text{Favorite color is blue} + \\varepsilon\n\\]\nWe can generate a fake dataset with columns for happiness (Beta distribution clustered around 7ish), cookies (Poisson distribution), and favorite color (binomial distribution for blue/not blue):\n\nset.seed(1234)\n\nn_people <- 1000\nhappiness_simple <- tibble(\n  id = 1:n_people,\n  happiness = rbeta(n_people, shape1 = 7, shape2 = 3),\n  cookies = rpois(n_people, lambda = 1),\n  color_blue = sample(c(\"Blue\", \"Not blue\"), n_people, replace = TRUE)\n) %>%\n  # Adjust some of the columns\n  mutate(happiness = round(happiness * 10, 1),\n         cookies = cookies + 1,\n         color_blue = fct_relevel(factor(color_blue), \"Not blue\"))\n\nhead(happiness_simple)\n\nWe have a neat dataset now, so let’s run a regression. Is eating more cookies or liking blue associated with greater happiness?\n\nmodel_happiness1 <- lm(happiness ~ cookies + color_blue, data = happiness_simple)\ntidy(model_happiness1)\n\nNot really. The coefficients for both cookies and color_blueBlue are basically 0 and not statistically significant. That makes sense since the three columns are completely independent of each other. If there were any significant effects, that’d be strange and solely because of random chance.\nFor the sake of your final project, you can just leave all the columns completely independent of each other if you want. None of your results will be significant and you won’t see any effects anywhere, but you can still build models, run all the pre-model diagnostics, and create graphs and tables based on this data.\nHOWEVER, it will be far more useful to you if you generate relationships. The whole goal of this class is to find causal effects in observational, non-experimental data. If you can generate synthetic non-experimental data and bake in a known causal effect, you can know if your different methods for recovering that effect are working.\nSo how do we bake in correlations and causal effects?\n\n\nExplanatory variables linked to outcome; no connection between explanatory variables\nTo help with the intuition of how to link these columns, think about the model we’re building:\n\\[\n\\text{Happiness} = \\beta_0 + \\beta_1 \\text{Cookies eaten} + \\beta_2 \\text{Favorite color is blue} + \\varepsilon\n\\]\nThis model provides estimates for all those betas. Throughout the semester, we’ve used the analogy of sliders and switches to describe regression coefficients. Here we have both:\n\n\\(\\beta_0\\): The average baseline happiness.\n\\(\\beta_1\\): The additional change in happiness that comes from eating one cookie. This is a slider: move cookies up by one and happiness changes by \\(\\beta_1\\).\n\\(\\beta_2\\): The change in happiness that comes from having your favorite color be blue. This is a switch: turn on “blue” for someone and their happiness changes by \\(\\beta_2\\).\n\nWe can invent our own coefficients and use some math to build them into the dataset. Let’s use these numbers as our targets:\n\n\\(\\beta_0\\): Average happiness is 7\n\\(\\beta_1\\): Eating one more cookie boosts happiness by 0.25 points\n\\(\\beta_2\\): People who like blue have 0.75 higher happiness\n\nWhen generating the data, we can’t just use rbeta() by itself to generate happiness, since happiness depends on both cookies and favorite color (that’s why we call it a dependent variable). To build in this effect, we can add a new column that uses math and modifies the underlying rbeta()-based happiness score:\n\nhappiness_with_effect <- happiness_simple %>%\n  # Turn the categorical favorite color column into TRUE/FALSE so we can do math with it\n  mutate(color_blue_binary = ifelse(color_blue == \"Blue\", TRUE, FALSE)) %>%\n  # Make a new happiness column that uses coefficients for cookies and favorite color\n  mutate(happiness_modified = happiness + (0.25 * cookies) + (0.75 * color_blue_binary))\nhead(happiness_with_effect)\n\nNow that we have a new happiness_modified column we can run a model using it as the outcome:\n\nmodel_happiness2 <- lm(happiness_modified ~ cookies + color_blue, data = happiness_with_effect)\ntidy(model_happiness2)\n\nWhoa! Look at those coefficients! They’re exactly what we tried to build in! The baseline happiness (intercept) is ≈7, eating one cookie is associated with a ≈0.25 increase in happiness, and liking blue is associated with a ≈0.75 increase in happiness.\nHowever, we originally said that happiness was a 0-10 point scale. After boosting it with extra happiness for cookies and liking blue, there are some people who score higher than 10:\n\n# Original scale\nggplot(happiness_with_effect, aes(x = happiness)) +\n  geom_histogram(binwidth = 1, color = \"white\") +\n  scale_x_continuous(breaks = 0:11) +\n  coord_cartesian(xlim = c(0, 11))\n\n\n# Scaled up\nggplot(happiness_with_effect, aes(x = happiness_modified)) +\n  geom_histogram(binwidth = 1, color = \"white\") +\n  scale_x_continuous(breaks = 0:11) +\n  coord_cartesian(xlim = c(0, 11))\n\nTo fix that, we can use the rescale() function from the scales package to force the new happiness_modified variable to fit back in its original range:\n\nhappiness_with_effect <- happiness_with_effect %>%\n  mutate(happiness_rescaled = rescale(happiness_modified, to = c(3, 10)))\n\nggplot(happiness_with_effect, aes(x = happiness_rescaled)) +\n  geom_histogram(binwidth = 1, color = \"white\") +\n  scale_x_continuous(breaks = 0:11) +\n  coord_cartesian(xlim = c(0, 11))\n\nEverything is back in the 3–10 range now. However, the rescaling also rescaled our built-in effects. Look what happens if we use the happiness_rescaled in the model:\n\nmodel_happiness3 <- lm(happiness_rescaled ~ cookies + color_blue, data = happiness_with_effect)\ntidy(model_happiness3)\n\nNow the baseline happiness is 6.3, the cookies effect is 0.2, and the blue effect is 0.63. These effects shrunk because we shrunk the data back down to have a maximum of 10.\nThere are probably fancy mathy ways to rescale data and keep the coefficients the same size, but rather than figure that out (who even wants to do that?!), my strategy is just to play with numbers until the results look good. Instead of using a 0.25 cookie effect and 0.75 blue effect, I make those effects bigger so that the rescaled version is roughly what I really want. There’s no systematic way to do this—I ran this chunk below a bunch of times until the numbers worked.\n\nset.seed(1234)\n\nn_people <- 1000\nhappiness_real_effect <- tibble(\n  id = 1:n_people,\n  happiness_baseline = rbeta(n_people, shape1 = 7, shape2 = 3),\n  cookies = rpois(n_people, lambda = 1),\n  color_blue = sample(c(\"Blue\", \"Not blue\"), n_people, replace = TRUE)\n) %>%\n  # Adjust some of the columns\n  mutate(happiness_baseline = round(happiness_baseline * 10, 1),\n         cookies = cookies + 1,\n         color_blue = fct_relevel(factor(color_blue), \"Not blue\")) %>%\n  # Turn the categorical favorite color column into TRUE/FALSE so we can do math with it\n  mutate(color_blue_binary = ifelse(color_blue == \"Blue\", TRUE, FALSE)) %>%\n  # Make a new happiness column that uses coefficients for cookies and favorite color\n  mutate(happiness_effect = happiness_baseline +\n           (0.31 * cookies) +  # Cookie effect\n           (0.91 * color_blue_binary)) %>%  # Blue effect\n  # Rescale to 3-10, since that's what the original happiness column looked like\n  mutate(happiness = rescale(happiness_effect, to = c(3, 10)))\n\nmodel_does_this_work_yet <- lm(happiness ~ cookies + color_blue, data = happiness_real_effect)\ntidy(model_does_this_work_yet)\n\nThere’s nothing magical about the 0.31 and 0.91 numbers I used here; I just kept changing those to different things until the regression coefficients ended up at ≈0.25 and ≈0.75. Also, I gave up on trying to make the baseline happiness 7. It’s possible to do—you’d just need to also shift the underlying Beta distribution up (like shape1 = 9, shape2 = 2 or something). But then you’d also need to change the coefficients more. You’ll end up with 3 moving parts and it can get complicated, so I don’t worry too much about it, since what we care about the most here is the effect of cookies and favorite color, not baseline levels of happiness.\nPhew. We successfully connected cookies and favorite color to happiness and we have effects that are measurable with regression! One last thing that I would do is get rid of some of the intermediate columns like color_blue_binary or happiness_effect—we only used those for the behind-the-scenes math of creating the effect. Here’s our final synthetic dataset:\n\nhappiness <- happiness_real_effect %>%\n  select(id, happiness, cookies, color_blue)\nhead(happiness)\n\nWe can save that as a CSV file with write_csv():\n\nwrite_csv(happiness, \"data/happiness_fake_data.csv\")\n\n\n\nExplanatory variables linked to outcome; connection between explanatory variables\nIn that cookie example, we assumed that both cookie consumption and favorite color are associated with happiness. We also assumed that cookie consumption and favorite color are not related to each other. But what if they are? What if people who like blue eat more cookies?\nWe’ve already used regression-based math to connect explanatory variables to outcome variables. We can use that same intuition to connect explanatory variables to each other.\nThe easiest way to think about this is with DAGs. Here’s the DAG for the model we just ran:\n\nhappiness_dag1 <- dagify(hap ~ cook + blue,\n                         coords = list(x = c(hap = 3, cook = 1, blue = 2),\n                                       y = c(hap = 1, cook = 1, blue = 2)))\n\nggdag(happiness_dag1) +\n  theme_dag()\n\nBoth cookies and favorite color cause happiness, but there’s no link between them. Notice that dagify() uses the same model syntax that lm() does: hap ~ cook + blue. If we think of this just like a regression model, we can pretend that there are coefficients there too: hap ~ 0.25*cook + 0.75*blue. We don’t actually include any coefficients in the DAG or anything, but it helps with the intuition.\nBut what if people who like blue eat more cookies on average? For whatever reason, let’s pretend that liking blue causes you to eat 0.5 more cookies, on average. Here’s the new DAG:\n\nhappiness_dag2 <- dagify(hap ~ cook + blue,\n                         cook ~ blue,\n                         coords = list(x = c(hap = 3, cook = 1, blue = 2),\n                                       y = c(hap = 1, cook = 1, blue = 2)))\n\nggdag(happiness_dag2) +\n  theme_dag()\n\nNow we have two different equations: hap ~ cook + blue and cook ~ blue. Conveniently, these both translate to models, and we know the coefficients we want!\n\nhap ~ 0.25*cook + 0.75*blue: This is what we built before—cookies boost happiness by 0.25 and liking blue boosts happiness by 0.75\ncook ~ 0.3*blue: This is what we just proposed—liking blue boosts cookies by 0.5\n\nWe can follow the same process we did when building the cookie and blue effects into happiness to also build a blue effect into cookies!\n\nset.seed(1234)\n\nn_people <- 1000\nhappiness_cookies_blue <- tibble(\n  id = 1:n_people,\n  happiness_baseline = rbeta(n_people, shape1 = 7, shape2 = 3),\n  cookies = rpois(n_people, lambda = 1),\n  color_blue = sample(c(\"Blue\", \"Not blue\"), n_people, replace = TRUE)\n) %>%\n  # Adjust some of the columns\n  mutate(happiness_baseline = round(happiness_baseline * 10, 1),\n         cookies = cookies + 1,\n         color_blue = fct_relevel(factor(color_blue), \"Not blue\")) %>%\n  # Turn the categorical favorite color column into TRUE/FALSE so we can do math with it\n  mutate(color_blue_binary = ifelse(color_blue == \"Blue\", TRUE, FALSE)) %>%\n  # Make blue have an effect on cookie consumption\n  mutate(cookies = cookies + (0.5 * color_blue_binary)) %>%\n  # Make a new happiness column that uses coefficients for cookies and favorite color\n  mutate(happiness_effect = happiness_baseline +\n           (0.31 * cookies) +  # Cookie effect\n           (0.91 * color_blue_binary)) %>%  # Blue effect\n  # Rescale to 3-10, since that's what the original happiness column looked like\n  mutate(happiness = rescale(happiness_effect, to = c(3, 10)))\nhead(happiness_cookies_blue)\n\nNotice now that people who like blue eat partial cookies, as expected. We can verify that there’s a relationship between liking blue and cookies by running a model:\n\nlm(cookies ~ color_blue, data = happiness_cookies_blue) %>%\n  tidy()\n\nYep. Liking blue is associated with 0.46 more cookies on average (it’s not quite 0.5, but that’s because of randomness).\nNow let’s do some neat DAG magic. Let’s say we’re interested in the causal effect of cookies on happiness. We could run a naive model:\n\nmodel_happiness_naive <- lm(happiness ~ cookies, data = happiness_cookies_blue)\ntidy(model_happiness_naive)\n\nBased on this, eating a cookie causes you to have 0.325 more happiness points. But that’s wrong! Liking the color blue is a confounder and opens a path between cookies and happiness. You can see the confounding both in the DAG (since blue points to both the cookie node and the happiness node) and in the math (liking blue boosts happiness + liking blue boosts cookie consumption, which boosts happiness).\nTo fix this confounding, we need to statistically adjust for liking blue and close the backdoor path. Ordinarily we’d do this with something like matching or inverse probability weighting, but here we can just include liking blue as a control variable (since it’s linearly related to both cookies and happiness):\n\nmodel_happiness_ate <- lm(happiness ~ cookies + color_blue, data = happiness_cookies_blue)\ntidy(model_happiness_ate)\n\nAfter adjusting for backdoor confounding, eating one additional cookie causes a 0.249 point increase in happiness. This is the effect we originally built into the data!\nIf you wanted, we could rescale the number of cookies just like we rescaled happiness before, since sometimes adding effects to columns changes their reasonable ranges.\nNow that we have a good working dataset, we can keep the columns we care about and save it as a CSV file for later use:\n\nhappiness <- happiness_cookies_blue %>%\n  select(id, happiness, cookies, color_blue)\nhead(happiness)\n\n\nwrite_csv(happiness, \"data/happiness_fake_data.csv\")\n\n\n\nAdding extra noise\nWe’ve got columns that follow specific distributions, and we’ve got columns that are statistically related to each other. We can add one more wrinkle to make our fake data even more fun (and even more reflective of real life). We can add some noise.\nRight now, the effects we’re finding are too perfect. When we used mutate() to add a 0.25 boost in happiness for every cookie people ate, we added exactly 0.25 happiness points. If someone ate 2 cookies, they got 0.5 more happiness; if they ate 5, they got 1.25 more.\nWhat if the cookie effect isn’t exactly 0.25, but somewhere around 0.25? For some people it’s 0.1, for others it’s 0.3, for others it’s 0.22. We can use the same ideas we talked about in the random numbers example to generate a distribution of an effect. For instance, let’s say that the average cookie effect is 0.25, but it can vary somewhat with a standard deviation of 0.15:\n\ntemp_data <- tibble(x = rnorm(10000, mean = 0.25, sd = 0.15))\n\nggplot(temp_data, aes(x = x)) +\n  geom_histogram(binwidth = 0.05, boundary = 0, color = \"white\")\n\nSometimes it can go as low as −0.25; sometimes it can go as high as 0.75; normally it’s around 0.25.\nNothing in the model explains why it’s higher or lower for some people—it’s just random noise. Remember that the model accounts for that! This random variation is what the \\(\\varepsilon\\) is for in this model equation:\n\\[\n\\text{Happiness} = \\beta_0 + \\beta_1 \\text{Cookies eaten} + \\beta_2 \\text{Favorite color is blue} + \\varepsilon\n\\]\nWe can build that uncertainty into the fake column! Instead of using 0.31 * cookies when generating happiness (which is technically 0.25, but shifted up to account for rescaling happiness back down after), we’ll make a column for the cookie effect and then multiply that by the number of cookies.\n\nset.seed(1234)\n\nn_people <- 1000\nhappiness_cookies_noisier <- tibble(\n  id = 1:n_people,\n  happiness_baseline = rbeta(n_people, shape1 = 7, shape2 = 3),\n  cookies = rpois(n_people, lambda = 1),\n  cookie_effect = rnorm(n_people, mean = 0.31, sd = 0.2),\n  color_blue = sample(c(\"Blue\", \"Not blue\"), n_people, replace = TRUE)\n) %>%\n  # Adjust some of the columns\n  mutate(happiness_baseline = round(happiness_baseline * 10, 1),\n         cookies = cookies + 1,\n         color_blue = fct_relevel(factor(color_blue), \"Not blue\")) %>%\n  # Turn the categorical favorite color column into TRUE/FALSE so we can do math with it\n  mutate(color_blue_binary = ifelse(color_blue == \"Blue\", TRUE, FALSE)) %>%\n  # Make blue have an effect on cookie consumption\n  mutate(cookies = cookies + (0.5 * color_blue_binary)) %>%\n  # Make a new happiness column that uses coefficients for cookies and favorite\n  # color. Importantly, instead of using 0.31 * cookies, we'll use the random\n  # cookie effect we generated earlier\n  mutate(happiness_effect = happiness_baseline +\n           (cookie_effect * cookies) +\n           (0.91 * color_blue_binary)) %>%\n  # Rescale to 3-10, since that's what the original happiness column looked like\n  mutate(happiness = rescale(happiness_effect, to = c(3, 10)))\nhead(happiness_cookies_noisier)\n\nNow let’s look at the cookie effect in this noisier data:\n\nmodel_noisier <- lm(happiness ~ cookies + color_blue, data = happiness_cookies_noisier)\ntidy(model_noisier)\n\nThe effect is a little smaller now because of the extra noise, so we’d need to mess with the 0.31 and 0.91 coefficients more to get those numbers back up to 0.25 and 0.75.\nWhile this didn’t influence the findings too much here, it can have consequences for other variables. For instance, in the previous section we said that the color blue influences cookie consumption. If the blue effect on cookies isn’t precisely 0.5 but follows some sort of distribution (sometimes small, sometimes big, sometimes negative, sometimes zero), that will influence cookies differently. That random effect on cookie consumption will then work together with the random effect of cookies on happiness, resulting in multiple varied values.\nFor instance, imagine the average effect of liking blue on cookies is 0.5, and the average effect of cookies on happiness is 0.25. For one person, their blue-on-cookie effect might be 0.392, which changes the number of cookies they eat. Their cookie-on-happiness effect is 0.573, which changes their happiness. Both of those random effects work together to generate the final happiness.\nIf you want more realistic-looking synthetic data, it’s a good idea to add some random noise wherever you can."
  },
  {
    "objectID": "slides/synthetic-data.html#visualizing-variables-and-relationships",
    "href": "slides/synthetic-data.html#visualizing-variables-and-relationships",
    "title": "The ultimate guide to generating synthetic data for causal inference",
    "section": "Visualizing variables and relationships",
    "text": "Visualizing variables and relationships\nGoing through this process requires a ton of trial and error. You will change all sorts of numbers to make sure the relationships you’re building work. This is especially the case if you rescale things, since that rescales your effects. There are a lot of moving parts and this is a complicated process.\nYou’ll run your data generation chunks lots and lots and lots of times, tinkering with the numbers as you go. This example makes it look easy, since it’s the final product, but I ran all these chunks over and over again until I got the causal effect and relationships just right.\nIt’s best if you also create plots and models to see what the relationships look like\n\nVisualizing one variable\nWe covered a bunch of distributions in the random number generation example, but it’s hard to think about what a standard deviation of 2 vs 10 looks like, or what happens when you mess with the shape parameters in a Beta distribution.\nIt’s best to visualize these variables. You could build the variable into your official dataset and then look at it, but I find it’s often faster to just look at what a general distribution looks like first. The easiest way to do this is generate a dataset with just one column in it and look at it, either with a histogram or a density plot.\nFor instance, what does a Beta distribution with shape1 = 3 and shape2 = 16 look like? The math says it should peak around 0.15ish (\\(\\frac{3}{3 + 16}\\)), and that looks like the case:\n\ntemp_data <- tibble(x = rbeta(10000, shape1 = 3, shape2 = 16))\n\nplot1 <- ggplot(temp_data, aes(x = x)) +\n  geom_histogram(binwidth = 0.05, boundary = 0, color = \"white\")\n\nplot2 <- ggplot(temp_data, aes(x = x)) +\n  geom_density()\n\nplot1 + plot2\n\nWhat if we want a normal distribution centered around 100, with most values range from 50 to 150. That’s range of ±50, but that doesn’t mean the sd will be 50—it’ll be much smaller than that, like 25ish. Tinker with the numbers until it looks right.\n\ntemp_data <- tibble(x = rnorm(10000, mean = 100, sd = 25))\n\nplot1 <- ggplot(temp_data, aes(x = x)) +\n  geom_histogram(binwidth = 10, boundary = 0, color = \"white\")\n\nplot2 <- ggplot(temp_data, aes(x = x)) +\n  geom_density()\n\nplot1 + plot2\n\n\n\nVisualizing two continuous variables\nIf you have two continuous/numeric columns, it’s best to use a scatterplot. For instance, let’s make two columns based on the Beta and normal distributions above, and we’ll make it so that y goes up by 0.25 for every increase in x, along with some noise:\n\nset.seed(1234)\n\ntemp_data <- tibble(\n  x = rnorm(1000, mean = 100, sd = 25)\n) %>%\n  mutate(y = rbeta(1000, shape1 = 3, shape2 = 16) +  # Baseline distribution\n           (0.25 * x) +  # Effect of x\n           rnorm(1000, mean = 0, sd = 10))  # Add some noise\n\nggplot(temp_data, aes(x = x, y = y)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\nWe can confirm the effect with a model:\n\nlm(y ~ x, data = temp_data) %>%\n  tidy()\n\n\n\nVisualizing a binary variable and a continuous variable\nIf you have one binary column and one continuous/numeric column, it’s generally best to not use a scatterplot. Instead, either look at the distribution of the continuous variable across the binary variable with a faceted histogram or overlaid density plot, or look at the average of the continuous variable across the different values of the binary variable with a point range.\nLet’s make two columns: a continuous outcome (y) and a binary treatment (x). Being in the treatment group causes an increase of 20 points, on average.\n\nset.seed(1234)\n\ntemp_data <- tibble(\n  treatment = rbinom(1000, size = 1, prob = 0.5)  # Make 1000 0/1 values with 50% chance of each\n) %>%\n  mutate(outcome = rbeta(1000, shape1 = 3, shape2 = 16) +  # Baseline distribution\n           (20 * treatment) +  # Effect of treatment\n           rnorm(1000, mean = 0, sd = 20)) %>%   # Add some noise\n  mutate(treatment = factor(treatment))  # Make treatment a factor/categorical variable\n\nWe can check the numbers with a model:\n\nlm(outcome ~ treatment, data = temp_data) %>% tidy()\n\nHere’s what that looks like as a histogram:\n\nggplot(temp_data, aes(x = outcome, fill = treatment)) +\n  geom_histogram(binwidth = 5, color = \"white\", boundary = 0) +\n  guides(fill = \"none\") +  # Turn off the fill legend since it's redundant\n  facet_wrap(vars(treatment), ncol = 1)\n\nAnd as overlapping densities:\n\nggplot(temp_data, aes(x = outcome, fill = treatment)) +\n  geom_density(alpha = 0.5)\n\nAnd with a point range:\n\n# hahaha these error bars are tiny\nggplot(temp_data, aes(x = treatment, y = outcome, color = treatment)) +\n  stat_summary(geom = \"pointrange\", fun.data = \"mean_se\") +\n  guides(color = \"none\")  # Turn off the color legend since it's redundant"
  },
  {
    "objectID": "slides/synthetic-data.html#specific-examples",
    "href": "slides/synthetic-data.html#specific-examples",
    "title": "The ultimate guide to generating synthetic data for causal inference",
    "section": "Specific examples",
    "text": "Specific examples\n\ntl;dr: The general process\nThose previous sections go into a lot of detail. In general, here’s the process you should follow when building relationships in synthetic data:\n\nDraw a DAG that maps out how all the columns you care about are related.\nSpecify how those nodes are measured.\nSpecify the relationships between the nodes based on the DAG equations.\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nVerify all relationships with plots and models.\nTry it out!\nSave the data.\n\n\n\nCreating an effect in an observational DAG\n\nDraw a DAG that maps out how all the columns you care about are related.\nHere’s a simple DAG that shows the causal effect of mosquito net usage on malaria risk. Income and health both influence and confound net use and malaria risk, and income also influences health.\n\nmosquito_dag <- dagify(mal ~ net + inc + hlth,\n                       net ~ inc + hlth,\n                       hlth ~ inc,\n                       coords = list(x = c(mal = 4, net = 1, inc = 2, hlth = 3),\n                                     y = c(mal = 1, net = 1, inc = 2, hlth = 2)))\nggdag(mosquito_dag) +\n  theme_dag()\n\nSpecify how those nodes are measured.\nFor the sake of this example, we’ll measure these nodes like so. See the random number example for more details about the distributions.\n\nMalaria risk: scale from 0–100, mostly around 40, but ranging from 10ish to 80ish. Best to use a Beta distribution.\nNet use: binary 0/1, TRUE/FALSE variable, where 50% of people use nets. Best to use a binomial distribution. However, since we want to use other variables that increase the likelihood of using a net, we’ll do some cool tricky stuff, explained later.\nIncome: weekly income, measured in dollars, mostly around 500 ± 300. Best to use a normal distribution.\nHealth: scale from 0–100, mostly around 70, but ranging from 50ish to 100. Best to use a Beta distribution.\n\nSpecify the relationships between the nodes based on the DAG equations.\nThere are three models in this DAG:\n\nhlth ~ inc: Income influences health. We’ll assume that every 10 dollars/week is associated with a 1 point increase in health (so a 1 dollar incrrease is associated with a 0.02 point increase in health)\nnet ~ inc + hlth: Income and health both increase the probability of net usage. This is where we do some cool tricky stuff.\nBoth income and health have an effect on the probability of bed net use, but bed net use is measured as a 0/1, TRUE/FALSE variable. If we run a regression with net as the outcome, we can’t really interpret the coefficients like “a 1 point increase in health is associated with a 0.42 point increase in bed net being TRUE.” That doesn’t even make sense.\nOrdinarily, when working with binary outcome variables, you use logistic regression models (see the crash course we had when talking about propensity scores here). In this kind of regression, the coefficients in the model represent changes in the log odds of using a net. As we discuss in the crash course section, log odds are typically impossible to interpet. If you exponentiate them, you get odds ratios, which let you say things like “a 1 point increase in health is associated with a 15% increase in the likelihood of using a net.” Technically we could include coefficients for a logistic regression model and simulate probabilities of using a net or not using log odds and odds ratios (and that’s what I do in the rain barrel data from Problem Set 3 (see code here)), but that’s really hard to wrap your head around since you’re dealing with strange uninterpretable coefficients. So we won’t do that here.\nInstead, we’ll do some fun trickery. We’ll create something called a “bed net score” that gets bigger as income and health increase. We’ll say that a 1 point increase in health score is associated with a 1.5 point increase in bed net score, and a 1 dollar increase in income is associated with a 0.5 point increase in bed net score. This results in a column that ranges all over the place, from 200 to 500 (in this case; that won’t always be true). This column definitely doesn’t look like a TRUE/FALSE binary column—it’s just a bunch of numbers. That’s okay!\nWe’ll then use the rescale() function from the scales package to take this bed net score and scale it down so that it goes from 0.05 to 0.95. This represents a person’s probability of using a bed net.\nFinally, we’ll use that probability in the rbinom() function to generate a 0 or 1 for each person. Some people will have a high probability because of their income and health, like 0.9, and will most likely use a net. Some people might have a 0.15 probability and will likely not use a net.\nWhen you generate binary variables like this, it’s hard to know the exact effect you’ll get, so it’s best to tinker with the numbers until you see relationships that you want.\nmal ~ net + inc + hlth: Finally net use, income, and health all have an effect on the risk of malaria. Building this relationship is easy since it’s just a regular linear regression model (since malaria risk is not binary). We’ll say that a 1 dollar increase in income is associated with a decrease in risk, a 1 point increase in health is associated with a decrease in risk, and using a net is associated with a 15 point decrease in risk. That’s the casual effect we’re building in to the DAG.\n\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nHere we go! Let’s make some data. I’ll comment the code below so you can see what’s happening at each step.\n\n# Make this randomness consistent\nset.seed(1234)\n\n# Simulate 1138 people (just for fun)\nn_people <- 1138\n\nnet_data <- tibble(\n  # Make an ID column (not necessary, but nice to have)\n  id = 1:n_people,\n  # Generate income variable: normal, 500 ± 300\n  income = rnorm(n_people, mean = 500, sd = 75)\n) %>%\n  # Generate health variable: beta, centered around 70ish\n  mutate(health_base = rbeta(n_people, shape1 = 7, shape2 = 4) * 100,\n         # Health increases by 0.02 for every dollar in income\n         health_income_effect = income * 0.02,\n         # Make the final health score and add some noise\n         health = health_base + health_income_effect + rnorm(n_people, mean = 0, sd = 3),\n         # Rescale so it doesn't go above 100\n         health = rescale(health, to = c(min(health), 100))) %>%\n  # Generate net variable based on income, health, and random noise\n  mutate(net_score = (0.5 * income) + (1.5 * health) + rnorm(n_people, mean = 0, sd = 15),\n         # Scale net score down to 0.05 to 0.95 to create a probability of using a net\n         net_probability = rescale(net_score, to = c(0.05, 0.95)),\n         # Randomly generate a 0/1 variable using that probability\n         net = rbinom(n_people, 1, net_probability)) %>%\n  # Finally generate a malaria risk variable based on income, health, net use,\n  # and random noise\n  mutate(malaria_risk_base = rbeta(n_people, shape1 = 4, shape2 = 5) * 100,\n         # Risk goes down by 10 when using a net. Because we rescale things,\n         # though, we have to make the effect a lot bigger here so it scales\n         # down to -10. Risk also decreases as health and income go up. I played\n         # with these numbers until they created reasonable coefficients.\n         malaria_effect = (-30 * net) + (-1.9 * health) + (-0.1 * income),\n         # Make the final malaria risk score and add some noise\n         malaria_risk = malaria_risk_base + malaria_effect + rnorm(n_people, 0, sd = 3),\n         # Rescale so it doesn't go below 0,\n         malaria_risk = rescale(malaria_risk, to = c(5, 70)))\n\n# Look at all these columns!\nhead(net_data)\n\nVerify all relationships with plots and models.\nLet’s see if we have the relationships we want. Income looks like it’s associated with health:\n\nggplot(net_data, aes(x = income, y = health)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\nlm(health ~ income, data = net_data) %>% tidy()\n\nIt looks like richer and healthier people are more likely to use nets:\n\nnet_income <- ggplot(net_data, aes(x = income, fill = as.factor(net))) +\n  geom_density(alpha = 0.7) +\n  theme(legend.position = \"bottom\")\n\nnet_health <- ggplot(net_data, aes(x = health, fill = as.factor(net))) +\n  geom_density(alpha = 0.7) +\n  theme(legend.position = \"bottom\")\n\nnet_income + net_health\n\nIncome increasing makes it 1% more likely to use a net; health increasing make it 2% more likely to use a net:\n\nglm(net ~ income + health, family = binomial(link = \"logit\"), data = net_data) %>%\n  tidy(exponentiate = TRUE)\n\nTry it out!\nIs the effect in there? Let’s try finding it by controlling for our two backdoors: health and income. Ordinarily we should do something like matching or inverse probability weighting, but we’ll just do regular regression here (which is okay-ish, since all these variables are indeed linearly related with each other—we made them that way!)\nIf we just look at the effect of nets on malaria risk without any statistical adjustment, we see that net cause a decrease of 13 points in malaria risk. This is wrong though becuase there’s confounding.\n\n# Wrong correlation-is-not-causation effect\nmodel_net_naive <- lm(malaria_risk ~ net, data = net_data)\ntidy(model_net_naive)\n\nIf we control for the confounders, we get the 10 point ATE. It works!\n\n# Correctly adjusted ATE effect\nmodel_net_ate <- lm(malaria_risk ~ net + health + income, data = net_data)\ntidy(model_net_ate)\n\nSave the data.\nSince it works, let’s save it:\n\n# In the end, all we need is id, income, health, net, and malaria risk:\nnet_data_final <- net_data %>%\n  select(id, income, health, net, malaria_risk)\nhead(net_data_final)\n\n\n# Save it as a CSV file\nwrite_csv(net_data_final, \"data/bed_nets.csv\")\n\n\n\n\nBrief pep talk intermission\nGenerating data for a full complete observational DAG like the example above is complicated and hard. These other forms of causal inference are design-based (i.e. tied to specific contexts like before/after treatment/control or arbitrary cutoffs) instead of model-based, so they’re actually a lot easier to simulate! So don’t be scared away yet!\n\n\nCreating an effect for RCTs\n\nDraw a DAG that maps out how all the columns you care about are related.\nRCTs are great because they make DAGs really easy! In a well-randomized RCT, you get to delete all arrows going into the treatment node in a DAG. We’ll stick with the same mosquito net situation we just used, but make it randomized:\n\nrct_dag <- dagify(mal ~ net + inc + hlth,\n                  hlth ~ inc,\n                  coords = list(x = c(mal = 4, net = 1, inc = 2, hlth = 3),\n                                y = c(mal = 1, net = 1, inc = 2, hlth = 2)))\nggdag(rct_dag) +\n  theme_dag()\n\nSpecify how those nodes are measured.\nWe’ll measure these nodes the same way as before:\n\nMalaria risk: scale from 0–100, mostly around 40, but ranging from 10ish to 80ish. Best to use a Beta distribution.\nNet use: binary 0/1, TRUE/FALSE variable, where 50% of people use nets. Best to use a binomial distribution.\nIncome: weekly income, measured in dollars, mostly around 500 ± 300. Best to use a normal distribution.\nHealth: scale from 0–100, mostly around 70, but ranging from 50ish to 100. Best to use a Beta distribution.\n\nSpecify the relationships between the nodes based on the DAG equations.\nThis is where RCTs are great. Because we removed all the arrows going into net, we don’t need to build any relationships that influence net use. Net use is randomized! We don’t need to make strange “bed net scores” and give people boosts according to income or health or anything. There are only two models in this DAG:\n\nhlth ~ inc: Income influences health. We’ll assume that every 10 dollars/week is associated with a 1 point increase in health (so a 1 dollar incrrease is associated with a 0.02 point increase in health)\nmal ~ net + inc + hlth: Net use, income, and health all have an effect on the risk of malaria. We’ll say that a 1 dollar increase in income is associated with a decrease in risk, a 1 point increase in health is associated with a decrease in risk, and using a net is associated with a 15 point decrease in risk. That’s the casual effect we’re building in to the DAG.\n\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nLet’s make this data. It’ll be a lot easier than the full DAG we did before. Again, I’ll comment the code below so you can see what’s happening at each step.\n\n# Make this randomness consistent\nset.seed(1234)\n\n# Simulate 793 people (just for fun)\nn_people <- 793\n\nrct_data <- tibble(\n  # Make an ID column (not necessary, but nice to have)\n  id = 1:n_people,\n  # Generate income variable: normal, 500 ± 300\n  income = rnorm(n_people, mean = 500, sd = 75)\n) %>%\n  # Generate health variable: beta, centered around 70ish\n  mutate(health_base = rbeta(n_people, shape1 = 7, shape2 = 4) * 100,\n         # Health increases by 0.02 for every dollar in income\n         health_income_effect = income * 0.02,\n         # Make the final health score and add some noise\n         health = health_base + health_income_effect + rnorm(n_people, mean = 0, sd = 3),\n         # Rescale so it doesn't go above 100\n         health = rescale(health, to = c(min(health), 100))) %>%\n  # Randomly assign people to use a net (this is nice and easy!)\n  mutate(net = rbinom(n_people, 1, 0.5)) %>%\n  # Finally generate a malaria risk variable based on income, health, net use,\n  # and random noise\n  mutate(malaria_risk_base = rbeta(n_people, shape1 = 4, shape2 = 5) * 100,\n         # Risk goes down by 10 when using a net. Because we rescale things,\n         # though, we have to make the effect a lot bigger here so it scales\n         # down to -10. Risk also decreases as health and income go up. I played\n         # with these numbers until they created reasonable coefficients.\n         malaria_effect = (-35 * net) + (-1.9 * health) + (-0.1 * income),\n         # Make the final malaria risk score and add some noise\n         malaria_risk = malaria_risk_base + malaria_effect + rnorm(n_people, 0, sd = 3),\n         # Rescale so it doesn't go below 0,\n         malaria_risk = rescale(malaria_risk, to = c(5, 70)))\n\n# Look at all these columns!\nhead(rct_data)\n\nVerify all relationships with plots and models.\nIncome still looks like it’s associated with health (which isn’t surprising, since it’s the same code we used for the full DAG earlier):\n\nggplot(net_data, aes(x = income, y = health)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\nlm(health ~ income, data = net_data) %>% tidy()\n\nTry it out!\nIs the effect in there? With an RCT, all we really need to do is compare the outcome across treatment and control groups—because there’s no confounding, we don’t need to control for anything. Ordinarily we should check for balance across characteristics like health and income (and maybe generate other demographic columns) like we did in the RCT example, but we’ll skip all that here since we’re just checking to see if the effect is there.\nIt looks like using nets causes an average decrease of 10 risk points. Great!\n\n# Correct RCT-based ATE\nmodel_rct <- lm(malaria_risk ~ net, data = rct_data)\ntidy(model_rct)\n\nJust for fun, if we control for health and income, we’ll get basically the same effect, since they don’t actualy confound the relationship and don’t really explain anything useful.\n\n# Controlling for stuff even though we don't need to\nmodel_rct_controls <- lm(malaria_risk ~ net + health + income, data = rct_data)\ntidy(model_rct_controls)\n\nSave the data.\nThe data works, so let’s get rid of the intermediate columns we don’t need and save it as a CSV file.\n\n# In the end, all we need is id, income, health, net, and malaria risk:\nrct_data_final <- rct_data %>%\n  select(id, income, health, net, malaria_risk)\nhead(rct_data_final)\n\n\n# Save it as a CSV file\nwrite_csv(rct_data_final, \"data/bed_nets_rct.csv\")\n\n\n\n\nCreating an effect for diff-in-diff\n\nDraw a DAG that maps out how all the columns you care about are related.\nDifference-in-differences approaches to causal inference are not based on models but on context or research design. You need comparable treatment and control groups before and after some policy or program is implemented.\nWe’ll keep with our mosquito net example and pretend that two cities in some country are dealing with malaria infections. City B rolls out a free net program in 2017; City A does not. Here’s what the DAG looks like:\n\ndid_dag <- dagify(mal ~ net + year + city,\n                  net ~ year + city,\n                  coords = list(x = c(mal = 3, net = 1, year = 2, city = 2),\n                                y = c(mal = 2, net = 2, year = 3, city = 1)))\nggdag(did_dag) +\n  theme_dag()\n\nSpecify how those nodes are measured.\nHere’s how we’ll measure these nodes:\n\nMalaria risk: scale from 0–100, mostly around 60, but ranging from 30ish to 90ish. Best to use a Beta distribution.\nNet use: binary 0/1, TRUE/FALSE variable. This is technically binomial, but we don’t need to simulate it since it will only happen for people who are in the treatment city after the universal net rollout.\nYear: year ranging from 2013 to 2020. Best to use a uniform distribution.\nCity: binary 0/1, City A/City B variable. Best to use a binomial distribution.\n\nSpecify the relationships between the nodes based on the DAG equations.\nThere are two models in the DAG:\n\nnet ~ year + city: Net use is determined by being in City B and being after 2017. We’ll assume perfect compliance here (but it’s fairly easy to simulate non-compliance and have some people in City A use nets after 2017, and some people in both cities use nets before 2017).\nmal ~ net + year + city: Malaria risk is determined by net use, year, and city. It’s determined by lots of other things too (like we saw in the previous DAGs), but since we’re assuming that the two cities are comparable treatment and control groups, we don’t need to worry about things like health, income, age, etc.\nWe’ll pretend that in general, City B has historicallly had a problem with malaria and people there have had higher risk: being in City B increases malaria risk by 5 points, on average. Over time, both cities have worked on mosquito abatement, so average malaria risk has decreased by 2 points per year (in both cities, because we believe in parallel trends). Using a mosquito net causes a decrease of 10 points on average. That’s our causal effect.\n\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nGeneration time! Heavily annotated code below:\n\n# Make this randomness consistent\nset.seed(1234)\n\n# Simulate 2567 people (just for fun)\nn_people <- 2567\n\ndid_data <- tibble(\n  # Make an ID column (not necessary, but nice to have)\n  id = 1:n_people,\n  # Generate year variable: uniform, between 2013 and 2020. Round so it's whole.\n  year = round(runif(n_people, min = 2013, max = 2020), 0),\n  # Generate city variable: binomial, 50% chance of being in a city. We'll use\n  # sample() instead of rbinom()\n  city = sample(c(\"City A\", \"City B\"), n_people, replace = TRUE)\n) %>%\n  # Generate net variable. We're assuming perfect compliance, so this will only\n  # be TRUE for people in City B after 2017\n  mutate(net = ifelse(city == \"City B\" & year > 2017, TRUE, FALSE)) %>%\n  # Generate a malaria risk variable based on year, city, net use, and random noise\n  mutate(malaria_risk_base = rbeta(n_people, shape1 = 6, shape2 = 3) * 100,\n         # Risk goes up if you're in City B because they have a worse problem.\n         # We could just say \"city_effect = 5\" and give everyone in City A an\n         # exact 5-point boost, but to add some noise, we'll give people an\n         # average boost using rnorm(). Some people might go up 7, some might go\n         # up 1, some might go down 2\n         city_effect = ifelse(city == \"City B\", rnorm(n_people, mean = 5, sd = 2), 0),\n         # Risk goes down by 2 points on average every year. Creating this\n         # effect with regression would work fine (-2 * year), except the years\n         # are huge here (-2 * 2013 and -2 * 2020, etc.) So first we create a\n         # smaller year column where 2013 is year 1, 2014 is year 2, and so on,\n         # that way we can say -2 * 1 and -2 * 6, or whatever.\n         # Also, rather than make risk go down by *exactly* 2 every year, we'll\n         # add some noise with rnorm(), so for some people it'll go down by 1 or\n         # 4 or up by 1, and so on\n         year_smaller = year - 2012,\n         year_effect = rnorm(n_people, mean = -2, sd = 0.1) * year_smaller,\n         # Using a net causes a decrease of 10 points, on average. Again, rather\n         # than use exactly 10, we'll use a distribution around 10. People only\n         # get a net boost if they're in City B after 2017.\n         net_effect = ifelse(city == \"City B\" & year > 2017,\n                             rnorm(n_people, mean = -10, sd = 1.5),\n                             0),\n         # Finally combine all these effects to create the malaria risk variable\n         malaria_risk = malaria_risk_base + city_effect + year_effect + net_effect,\n         # Rescale so it doesn't go below 0 or above 100\n         malaria_risk = rescale(malaria_risk, to = c(0, 100))) %>%\n  # Make an indicator variable showing if the row is after 2017\n  mutate(after = year > 2017)\n\nhead(did_data)\n\nVerify all relationships with plots and models.\nIs risk higher in City B? Yep.\n\nggplot(did_data, aes(x = city, y = malaria_risk, color = city)) +\n  stat_summary(geom = \"pointrange\", fun.data = \"mean_se\") +\n  guides(color = \"none\")\n\nDoes risk decrease over time? And are the trends parallel? There was a weird random spike in City B in 2017 for whatever reason, but in general, the trends in the two cities are pretty parallel from 2013 to 2017.\n\nplot_data <- did_data %>%\n  group_by(year, city) %>%\n  summarize(mean_risk = mean(malaria_risk),\n            se_risk = sd(malaria_risk) / sqrt(n()),\n            upper = mean_risk + (1.96 * se_risk),\n            lower = mean_risk + (-1.96 * se_risk))\n\nggplot(plot_data, aes(x = year, y = mean_risk, color = city)) +\n  geom_vline(xintercept = 2017.5) +\n  geom_ribbon(aes(ymin = lower, ymax = upper, fill = city), alpha = 0.3, color = FALSE) +\n  geom_line() +\n  theme(legend.position = \"bottom\")\n\nTry it out!\nLet’s see if it works! For diff-in-diff we need to use this model:\n\\[\n\\text{Malaria risk} = \\alpha + \\beta\\ \\text{City B} + \\gamma\\ \\text{After 2017} + \\delta\\ (\\text{City B} \\times \\text{After 2017}) + \\varepsilon\n\\]\n\nmodel_did <- lm(malaria_risk ~ city + after + city * after, data = did_data)\ntidy(model_did)\n\nIt works! Being in City B is associated with a 5-point higher risk on average; being after 2017 is associated with a 7.5-point lower risk on average, and being in City B after 2017 causes risk to drop by −10. The number isn’t exactly −10 here, since we rescaled the malaria_risk column a little, but still, it’s close. It’d probably be a good idea to build in some more noise and noncompliance, since the p-values are really really tiny here, but this is good enough for now.\nHere’s an obligatory diff-in-diff visualization:\n\nplot_data <- did_data %>%\n  group_by(after, city) %>%\n  summarize(mean_risk = mean(malaria_risk),\n            se_risk = sd(malaria_risk) / sqrt(n()),\n            upper = mean_risk + (1.96 * se_risk),\n            lower = mean_risk + (-1.96 * se_risk))\n\n# Extract parts of the model results for adding annotations\nmodel_results <- tidy(model_did)\nbefore_treatment <- filter(model_results, term == \"(Intercept)\")$estimate +\n  filter(model_results, term == \"cityCity B\")$estimate\ndiff_diff <- filter(model_results, term == \"cityCity B:afterTRUE\")$estimate\nafter_treatment <- before_treatment + diff_diff +\n  filter(model_results, term == \"afterTRUE\")$estimate\n\nggplot(plot_data, aes(x = after, y = mean_risk, color = city, group = city)) +\n  geom_pointrange(aes(ymin = lower, ymax = upper)) +\n  geom_line() +\n  annotate(geom = \"segment\", x = FALSE, xend = TRUE,\n           y = before_treatment, yend = after_treatment - diff_diff,\n           linetype = \"dashed\", color = \"grey50\") +\n  annotate(geom = \"segment\", x = 2.1, xend = 2.1,\n           y = after_treatment, yend = after_treatment - diff_diff,\n           linetype = \"dotted\", color = \"blue\") +\n  theme(legend.position = \"bottom\")\n\nSave the data.\nThe data works, so let’s get rid of the intermediate columns we don’t need and save it as a CSV file.\n\ndid_data_final <- did_data %>%\n  select(id, year, city, net, malaria_risk)\nhead(did_data_final)\n\n\n# Save data\nwrite_csv(did_data_final, \"data/diff_diff.csv\")\n\n\n\n\nCreating an effect for regression discontinuity\n\nDraw a DAG that maps out how all the columns you care about are related.\nRegression discontinuity designs are also based on context instead of models, so the DAG is pretty simple. We’ll keep with our mosquito net example and pretend that families that earn less than $450 a week qualify for a free net. Here’s the DAG:\n\nrdd_dag <- dagify(mal ~ net + inc,\n                  net ~ cut,\n                  cut ~ inc,\n                  coords = list(x = c(mal = 4, net = 1, inc = 3, cut = 2),\n                                y = c(mal = 1, net = 1, inc = 2, cut = 1.75)))\nggdag(rdd_dag) +\n  theme_dag()\n\nSpecify how those nodes are measured.\nHere’s how we’ll measure these nodes:\n\nMalaria risk: scale from 0–100, mostly around 60, but ranging from 30ish to 90ish. Best to use a Beta distribution.\nNet use: binary 0/1, TRUE/FALSE variable. This is technically binomial, but we don’t need to simulate it since it will only happen for people who below the cutoff.\nIncome: weekly income, measured in dollars, mostly around 500 ± 300. Best to use a normal distribution.\nCutoff: binary 0/1, below/above $450 variable. This is technically binomial, but we don’t need to simulate it since it is entirely based on income.\n\nSpecify the relationships between the nodes based on the DAG equations.\nThere are three models in the DAG:\n\ncut ~ inc: Being above or below the cutpoint is determined by income. We know the cutoff is 450, so we just make an indicator showing if people are below that.\nnet ~ cut: Net usage is determined by the cutpoint. If people are below the cutpoint, they’ll use a net; if not, they won’t. We can build in noncompliance here if we want and use fuzzy regression discontinuity. For the sake of this example, we’ll do it both ways, just so you can see both sharp and fuzzy synthetic data.\nmal ~ net + inc: Malaria risk is determined by both net usage and income. It’s also determined by lots of other things (age, education, city, etc.), but we don’t need to include those in the DAG because we’re using RDD to say that we have good treatment and control groups right around the cutoff.\nWe’ll pretend that a 1 dollar increase in income is associated with a drop in risk of 0.01, and that using a mosquito net causes a decrease of 10 points on average. That’s our causal effect.\n\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nLet’s fake some data! Heavily annotated code below:\n\n# Make this randomness consistent\nset.seed(1234)\n\n# Simulate 5441 people (we need a lot bc we're throwing most away)\nn_people <- 5441\n\nrdd_data <- tibble(\n  # Make an ID column (not necessary, but nice to have)\n  id = 1:n_people,\n  # Generate income variable: normal, 500 ± 300\n  income = rnorm(n_people, mean = 500, sd = 75)\n) %>%\n  # Generate cutoff variable\n  mutate(below_cutoff = ifelse(income < 450, TRUE, FALSE)) %>%\n  # Generate net variable. We'll make two: one that's sharp and has perfect\n  # compliance, and one that's fuzzy\n  # Here's the sharp one. It's easy. If you're below the cutoff you use a net.\n  mutate(net_sharp = ifelse(below_cutoff == TRUE, TRUE, FALSE)) %>%\n  # Here's the fuzzy one, which is a little trickier. If you're far away from\n  # the cutoff, you follow what you're supposed to do (like if your income is\n  # 800, you don't use the program; if your income is 200, you definitely use\n  # the program). But if you're close to the cutoff, we'll pretend that there's\n  # an 80% chance that you'll do what you're supposed to do.\n  mutate(net_fuzzy = case_when(\n    # If your income is between 450 and 500, there's a 20% chance of using the program\n    income >= 450 & income <= 500 ~ sample(c(TRUE, FALSE), n_people, replace = TRUE, prob = c(0.2, 0.8)),\n    # If your income is above 500, you definitely don't use the program\n    income > 500 ~ FALSE,\n    # If your income is between 400 and 450, there's an 80% chance of using the program\n    income < 450 & income >= 400 ~ sample(c(TRUE, FALSE), n_people, replace = TRUE, prob = c(0.8, 0.2)),\n    # If your income is below 400, you definitely use the program\n    income < 400 ~ TRUE\n  )) %>%\n  # Finally we can make the malaria risk score, based on income, net use, and\n  # random noise. We'll make two outcomes: one using the sharp net use and one\n  # using the fuzzy net use. They have the same effect built in, we just have to\n  # use net_sharp and net_fuzzy separately.\n  mutate(malaria_risk_base = rbeta(n_people, shape1 = 4, shape2 = 5) * 100) %>%\n  # Make the sharp version. There's really a 10 point decrease, but because of\n  # rescaling, we use 15. I only chose 15 through lots of trial and error (i.e.\n  # I used -11, ran the RDD model, and the effect was too small; I used -20, ran\n  # the model, and the effect was too big; I kept changing numbers until landing\n  # on -15). Risk also goes down as income increases.\n  mutate(malaria_effect_sharp = (-15 * net_sharp) + (-0.01 * income),\n         malaria_risk_sharp = malaria_risk_base + malaria_effect_sharp + rnorm(n_people, 0, sd = 3),\n         malaria_risk_sharp = rescale(malaria_risk_sharp, to = c(5, 70))) %>%\n  # Do the same thing, but with net_fuzzy\n  mutate(malaria_effect_fuzzy = (-15 * net_fuzzy) + (-0.01 * income),\n         malaria_risk_fuzzy = malaria_risk_base + malaria_effect_fuzzy + rnorm(n_people, 0, sd = 3),\n         malaria_risk_fuzzy = rescale(malaria_risk_fuzzy, to = c(5, 70))) %>%\n  # Make a version of income that's centered at the cutpoint\n  mutate(income_centered = income - 450)\n\nhead(rdd_data)\n\nVerify all relationships with plots and models.\nIs there a cutoff in the running variable when we use the sharp net variable? Yep!\n\nggplot(rdd_data, aes(x = income, y = net_sharp, color = below_cutoff)) +\n  geom_vline(xintercept = 450) +\n  geom_point(alpha = 0.3, position = position_jitter(width = NULL, height = 0.2)) +\n  guides(color = \"none\")\n\nIs there a cutoff in the running variable when we use the fuzzy net variable? Yep! There are some richer people using the program and some poorer people not using it.\n\nggplot(rdd_data, aes(x = income, y = net_fuzzy, color = below_cutoff)) +\n  geom_vline(xintercept = 450) +\n  geom_point(alpha = 0.3, position = position_jitter(width = NULL, height = 0.2)) +\n  guides(color = \"none\")\n\nTry it out!\nLet’s test it! For sharp RDD we need to use this model:\n\\[\n\\text{Malaria risk} = \\beta_0 + \\beta_1 \\text{Income}_\\text{centered} + \\beta_2 \\text{Net} + \\varepsilon\n\\]\nWe’ll use a bandwidth of ±$50, because why not. In real life you’d be more careful about bandwidth selection (or use rdbwselect() from the rdrobust package to find the optimal bandwidth)\n\nggplot(rdd_data, aes(x = income, y = malaria_risk_sharp, color = net_sharp)) +\n  geom_vline(xintercept = 450) +\n  geom_point(alpha = 0.2, size = 0.5) +\n  # Add lines for the full range\n  geom_smooth(data = filter(rdd_data, income_centered <= 0),\n              method = \"lm\", se = FALSE, size = 1, linetype = \"dashed\") +\n  geom_smooth(data = filter(rdd_data, income_centered > 0),\n              method = \"lm\", se = FALSE, size = 1, linetype = \"dashed\") +\n  # Add lines for bandwidth = 50\n  geom_smooth(data = filter(rdd_data, income_centered >= -50 & income_centered <= 0),\n              method = \"lm\", se = FALSE, size = 2) +\n  geom_smooth(data = filter(rdd_data, income_centered > 0 & income_centered <= 50),\n              method = \"lm\", se = FALSE, size = 2) +\n  theme(legend.position = \"bottom\")\n\n\nmodel_sharp <- lm(malaria_risk_sharp ~ income_centered + net_sharp,\n                  data = filter(rdd_data,\n                                income_centered >= -50 & income_centered <= 50))\ntidy(model_sharp)\n\nThere’s an effect! For people in the bandwidth, the local average treatment effect of nets is a 10.6 point reduction in malaria risk.\nLet’s check if it works with the fuzzy version where there are noncompliers:\n\nggplot(rdd_data, aes(x = income, y = malaria_risk_fuzzy, color = net_fuzzy)) +\n  geom_vline(xintercept = 450) +\n  geom_point(alpha = 0.2, size = 0.5) +\n  # Add lines for the full range\n  geom_smooth(data = filter(rdd_data, income_centered <= 0),\n              method = \"lm\", se = FALSE, size = 1, linetype = \"dashed\") +\n  geom_smooth(data = filter(rdd_data, income_centered > 0),\n              method = \"lm\", se = FALSE, size = 1, linetype = \"dashed\") +\n  # Add lines for bandwidth = 50\n  geom_smooth(data = filter(rdd_data, income_centered >= -50 & income_centered <= 0),\n              method = \"lm\", se = FALSE, size = 2) +\n  geom_smooth(data = filter(rdd_data, income_centered > 0 & income_centered <= 50),\n              method = \"lm\", se = FALSE, size = 2) +\n  theme(legend.position = \"bottom\")\n\nhere’s a gap, but it’s hard to measure since there are noncompliers on both sides. We can deal with the noncompliance if we use above/below the cutoff as an instrument (see the fuzzy regression discontinuity guide for a complete example). We should run this set of models:\n\\[\n\\begin{aligned}\n\\widehat{\\text{Net}} &= \\gamma_0 + \\gamma_1 \\text{Income}_{\\text{centered}} + \\gamma_2 \\text{Below 450} + \\omega \\\\\\\\\n\\text{Malaria risk} &= \\beta_0 + \\beta_1 \\text{Income}\\_{\\text{centered}} + \\beta_2 \\widehat{\\text{Net}} + \\epsilon\n\\end{aligned}\n\\]\nInstead of doing these two stages by hand (ugh), we’ll do the 2SLS regression with the iv_robust() function from the estimatr package:\n\nlibrary(estimatr)\n\nmodel_fuzzy <- iv_robust(malaria_risk_fuzzy ~ income_centered + net_fuzzy |\n                           income_centered + below_cutoff,\n                         data = filter(rdd_data,\n                                       income_centered >= -50 & income_centered <= 50))\ntidy(model_fuzzy)\n\nThe effect is slightly larger now (−11.2), but that’s because we are looking at a doubly local ATE: compliers in the bandwidth. But still, it’s close to −10, so that’s good. And we could probably get it closer if we did other mathy shenanigans like adding squared and cubed terms or using nonparametric estimation with rdrobust() in the rdrobust package.\nSave the data.\nThe data works, so let’s get rid of the intermediate columns we don’t need and save it as a CSV file. We’ll make two separate CSV files for fuzzy and sharp, just because.\n\nrdd_data_final_sharp <- rdd_data %>%\n  select(id, income, net = net_sharp, malaria_risk = malaria_risk_sharp)\nhead(rdd_data_final_sharp)\n\nrdd_data_final_fuzzy <- rdd_data %>%\n  select(id, income, net = net_fuzzy, malaria_risk = malaria_risk_fuzzy)\nhead(rdd_data_final_fuzzy)\n\n\n# Save data\nwrite_csv(rdd_data_final_sharp, \"data/rdd_sharp.csv\")\nwrite_csv(rdd_data_final_fuzzy, \"data/rdd_fuzzy.csv\")\n\n\n\n\nCreating an effect for instrumental variables\n\nDraw a DAG that maps out how all the columns you care about are related.\nAs with diff-in-diff and regression discontinuity, instrumental variables are a design-based approach to causal inference and thus don’t require complicated models (but you can still add control variables!), so their DAGs are simpler. Once again we’ll look at the effect of mosquito nets on malaria risk, but this time we’ll say that we cannot possibly measure all the confounding factors between net use and malaria risk, so we’ll use an instrument to extract the exogeneity from net use.\nAs we talked about in Session 11, good plausible instruments are hard to find: they have to cause bed net use and not be related to malaria risk except through bed net use.\nFor this example, we’ll pretend that free bed nets are distributed from town halls around the country. We’ll use “distance to town hall” as our instrument, since it could arguably maybe work perhaps. Being closer to a town hall makes you more likely to use a net, but being closer to a town halls doesn’t make put you at higher or lower risk for malaria on its own—it does that only because it changes your likelihood of getting a net.\nThis is where the story for the instrument falls apart, actually; in real life, if you live far away from a town hall, you probably live further from health services and live in more rural places with worse mosquito abatement policies, so you’re probably at higher risk of malaria. It’s probably a bad instrument, but just go with it.\nHere’s the DAG:\n\niv_dag <- dagify(mal ~ net + U,\n                 net ~ dist + U,\n                 coords = list(x = c(mal = 4, net = 2, U = 3, dist = 1),\n                               y = c(mal = 1, net = 1, U = 2, dist = 1.5)),\n                 latent = \"U\")\n\nggdag_status(iv_dag) +\n  guides(color = \"none\") +\n  theme_dag()\n\nSpecify how those nodes are measured.\nHere’s how we’ll measure these nodes:\n\nMalaria risk: scale from 0–100, mostly around 60, but ranging from 30ish to 90ish. Best to use a Beta distribution.\nNet use: binary 0/1, TRUE/FALSE variable. However, since we want to use other variables that increase the likelihood of using a net, we’ll do some cool tricky stuff with a bed net score, like we did in the observational DAG example earlier.\nDistance: distance to nearest town hall, measured in kilometers, mostly around 3, with a left skewed long tail (i.e. most people live fairly close, some people live far away). Best to use a Beta distribution (to get the skewed shape) that we then rescale.\nUnobserved: who knows?! There are a lot of unknown confounders. We could generate columns like income, age, education, and health, make them mathematically related to malaria risk and net use, and then throw those columns away in the final data so they’re unobserved. That would be fairly easy and intuitive.\nFor the sake of simplicity here, we’ll make a column called “risk factors,” kind of like we did with the “ability” column in the instrumental variables example—it’s a magical column that is unmeasurable, but it’ll open a backdoor path between net use and malaria risk and thus create endogeneity. It’ll be normally distributed around 50, with a standard deviation of 25.\n\nSpecify the relationships between the nodes based on the DAG equations.\nThere are two models in the DAG:\n\nnet ~ dist + U: Net usage is determined by both distance and our magical unobserved risk factor column. Net use is technically binomial, but in order to change the likelihood of net use based on distance to town hall and unobserved stuff, we’ll do the fancy tricky stuff we did in the observational DAG section above: we’ll create a bed net score, increase or decrease that score based on risk factors and distance, scale that score to a 0-1 scale of probabilities, and then draw a binomial 0/1 outcome using those probabilities.\nWe’ll say that a one kilometer increase in the distance to a town halls reduces the bed net score and a one point increase in risk factors reduces the bed net score.\nmal ~ net + U: Malaria risk is determined by both net usage and unkown stuff, or the magical column we’re calling “risk factors.” We’ll say that a one point increase in risk factors increases malaria risk, and that using a mosquito net causes a decrease of 10 points on average. That’s our causal effect.\n\nGenerate random columns that stand alone. Generate related columns using regression math. Consider adding random noise. This is an entirely trial and error process until you get numbers that look good. Rely heavily on plots as you try different coefficients and parameters. Optionally rescale any columns that go out of reasonable bounds. If you rescale, you’ll need to tinker with the coefficients you used since the final effects will also get rescaled.\nFake data time! Here’s some heavily annotated code:\n\n# Make this randomness consistent\nset.seed(1234)\n\n# Simulate 1578 people (just for fun)\nn_people <- 1578\n\niv_data <- tibble(\n  # Make an ID column (not necessary, but nice to have)\n  id = 1:n_people,\n  # Generate magical unobserved risk factor variable: normal, 500 ± 300\n  risk_factors = rnorm(n_people, mean = 100, sd = 25),\n  # Generate distance to town hall variable\n  distance = rbeta(n_people, shape1 = 1, shape2 = 4)\n) %>%\n  # Scale up distance to be 0.1-15 instead of 0-1\n  mutate(distance = rescale(distance, to = c(0.1, 15))) %>%\n  # Generate net variable based on distance, risk factors, and random noise\n  # Note: These -40 and -2 effects are entirely made up and I got them through a\n  # lot of trial and error and rerunning this stupid chunk dozens of times\n  mutate(net_score = 0 +\n           (-40 * distance) +  # Distance effect\n           (-2 * risk_factors) +  # Risk factor effect\n           rnorm(n_people, mean = 0, sd = 50),  # Random noise\n        net_probability = rescale(net_score, to = c(0.15, 1)),\n        # Randomly generate a 0/1 variable using that probability\n        net = rbinom(n_people, 1, net_probability)) %>%\n  # Generate malaria risk variable based on net use, risk factors, and random noise\n  mutate(malaria_risk_base = rbeta(n_people, shape1 = 7, shape2 = 5) * 100,\n         # We're aiming for a -10 net effect, but need to boost it because of rescaling\n         malaria_effect = (-20 * net) + (0.5 * risk_factors),\n         # Make the final malaria risk score\n         malaria_risk = malaria_risk_base + malaria_effect,\n         # Rescale so it doesn't go below 0\n         malaria_risk = rescale(malaria_risk, to = c(5, 80)))\niv_data\n\nVerify all relationships with plots and models.\nIs there a relationship between unobserved risk factors and malaria risk? Yep.\n\nggplot(iv_data, aes(x = risk_factors, y = malaria_risk)) +\n  geom_point(aes(color = as.factor(net))) +\n  geom_smooth(method = \"lm\")\n\nIs there a relationship between distance to town hall and net use? Yeah, those who live further away are less likely to use a net.\n\nggplot(iv_data, aes(x = distance, fill = as.factor(net))) +\n  geom_density(alpha = 0.7)\n\nIs there a relationship between net use and malaria risk? Haha, yeah, that’s a huge highly significant effect. Probably too perfect. We could increase those error bars if we tinker with some of the numbers in the code, but for the sake of this example, we’ll leave them like this.\n\nggplot(iv_data, aes(x = as.factor(net), y = malaria_risk, color = as.factor(net))) +\n  stat_summary(geom = \"pointrange\", fun.data = \"mean_se\")\n\nTry it out!\nCool, let’s see if this works. Remember, we can’t actually use the risk_factors column in real life, but we will here just to make sure the effect we built in exists. Here’s the true effect, where using a net causes a decrease of 10.9 malaria risk points\n\nmodel_forbidden <- lm(malaria_risk ~ net + risk_factors, data = iv_data)\ntidy(model_forbidden)\n\nSince we can’t actually use that column, we’ll use distance to town hall as an instrument. We should run this set of models:\n\\[\n\\begin{aligned}\n\\widehat{\\text{Net}} &= \\gamma_0 + \\gamma_1 \\text{Distance to town hall} + \\omega \\\\\\\\\n\\text{Malaria risk} &= \\beta_0 + \\beta_1 \\widehat{\\text{Net}} + \\epsilon\n\\end{aligned}\n\\]\nWe’ll run this 2SLS model with the iv_robust() function from the estimatr package:\n\nlibrary(estimatr)\n\nmodel_iv <- iv_robust(malaria_risk ~ net | distance, data = iv_data)\ntidy(model_iv)\n\n…and it’s relatively close, I guess, at −8.2. Getting instrumental variables to find exact causal effects is tricky, but I’m fine with this for simulated data.\nSave the data.\nThe data works well enough, so we’ll get rid of the extra intermediate columns and save it as a CSV file. We’ll keep the forbidden risk_factors column just for fun.\n\niv_data_final <- iv_data %>%\n  select(id, net, distance, malaria_risk, risk_factors)\n\nhead(iv_data_final)\n\n\n# Save data\nwrite_csv(iv_data_final, \"data/bed_nets_iv.csv\")"
  },
  {
    "objectID": "slides/synthetic-data.html#use-synthetic-data-packages",
    "href": "slides/synthetic-data.html#use-synthetic-data-packages",
    "title": "The ultimate guide to generating synthetic data for causal inference",
    "section": "Use synthetic data packages",
    "text": "Use synthetic data packages\nThere are several R packages that let you generate synthetic data with built-in relationships in a more automatic way. They all work a little differently, and if you’re interested in trying them out, make sure you check the documentation for details.\n\nfabricatr\nThe fabricatr package is a very powerful package for simulating data. It was invented specifically for using in preregistered studies, so it can handle a ton of different data structures like panel data and time series data. You can build in causal effects and force columns to be correlated with each other.\nfabricatr has exceptionally well-written documentation with like a billion detailed examples (see the right sidebar here). This is a gold standard package and you should most definitely check it out.\nHere’s a simple example of simulating a bunch of voters and making older ones more likely to vote:\n\nlibrary(fabricatr)\n\nset.seed(1234)\n\nfake_voters <- fabricate(\n  # Make 100 people\n  N = 100,\n  # Age uniformly distributed between 18 and 85\n  age = round(runif(N, 18, 85)),\n  # Older people more likely to vote\n  turnout = draw_binary(prob = ifelse(age < 40, 0.4, 0.7), N = N)\n)\n\nhead(fake_voters)\n\nAnd here’s an example of country-year panel data where there are country-specific and year-specific effects on GDP:\n\nset.seed(1234)\n\npanel_global_data <- fabricate(\n  years = add_level(\n    N = 10,\n    ts_year = 0:9,\n    year_shock = rnorm(N, 0, 0.3)\n  ),\n  countries = add_level(\n    N = 5,\n    base_gdp = runif(N, 15, 22),\n    growth_units = runif(N, 0.25, 0.5),\n    growth_error = runif(N, 0.15, 0.5),\n    nest = FALSE\n  ),\n  country_years = cross_levels(\n    by = join_using(years, countries),\n    gdp_measure = base_gdp + year_shock + (ts_year * growth_units) +\n      rnorm(N, sd = growth_error)\n  )\n) %>%\n  # Scale up the years to be actual years instead of 1, 2, 3, etc.\n  mutate(year = ts_year + 2010)\n\nhead(panel_global_data)\n\n\nggplot(panel_global_data, aes(x = year, y = gdp_measure, color = countries)) +\n  geom_line() +\n  labs(x = \"Year\", y = \"Log GDP\", color = \"Countries\")\n\nThat all just scratches the surface of what fabricatr can do. Again, check the examples and documentation and play around with it to see what else it can do.\n\n\nwakefield\nThe wakefield package is jokingly named after Andrew Wakefield, the British researcher who invented fake data to show that the MMR vaccine causes autism. This package lets you quickly generate random fake datasets. It has a bunch of pre-set column possibilities, like age, color, Likert scales, political parties, religion, and so on, and you can also use standard R functions like rnorm(), rbinom(), or rbeta(). It also lets you create repeated measures (1st grade score, 2nd grade score, 3rd grade score, etc.) and build correlations between variables.\nYou should definitely look at the documentation to see a ton of examples of how it all works. Here’s a basic example:\n\nlibrary(wakefield)\n\nset.seed(1234)\n\nwakefield_data <- r_data_frame(\n  n = 500,\n  id,\n  treatment = rbinom(1, 0.3),  # 30% chance of being in treatment\n  outcome = rnorm(mean = 500, sd = 100),\n  race,\n  age = age(x = 18:45),\n  sex = sex_inclusive(),\n  survey_question_1 = likert(),\n  survey_question_2 = likert()\n)\nhead(wakefield_data)\n\n\n\nfaux\nThe faux package does some really neat things. We can create data that has built-in correlations without going through all the math. For instance, let’s say we have 3 variables A, B, and C that are normally distributed with these parameters:\n\nA: mean = 10, sd = 2\nB: mean = 5, sd = 1\nC: mean = 20, sd = 5\n\nWe want A to correlate with B at r = 0.8 (highly correlated), A to correlate with C at r = 0.3 (less correlated), and B to correlate with C at r = 0.4 (moderately correlated). Here’s how to create that data with faux:\n\nlibrary(faux)\n\nset.seed(1234)\n\nfaux_data <- rnorm_multi(n = 100,\n                         mu = c(10, 5, 20),\n                         sd = c(2, 1, 5),\n                         r = c(0.8, 0.3, 0.4),\n                         varnames = c(\"A\", \"B\", \"C\"),\n                         empirical = FALSE)\nhead(faux_data)\n\n# Check averages and standard deviations\nfaux_data %>%\n  # Convert to long/tidy so we can group and summarize\n  pivot_longer(cols = everything(), names_to = \"variable\", values_to = \"value\") %>%\n  group_by(variable) %>%\n  summarize(mean = mean(value),\n            sd = sd(value))\n\n# Check correlations\ncor(faux_data$A, faux_data$B)\ncor(faux_data$A, faux_data$C)\ncor(faux_data$B, faux_data$C)\n\nfaux can do a ton of other things too, so make sure you check out the documentation and all the articles with examples here."
  },
  {
    "objectID": "tutorials/R/index.html",
    "href": "tutorials/R/index.html",
    "title": "R",
    "section": "",
    "text": "R Overview"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html",
    "href": "tutorials/R/r-manuals/test.html",
    "title": "R Manuals :: An Introduction to R",
    "section": "",
    "text": "This is an introduction to R (“GNU S”), a language and environment for statistical computing and graphics. R is similar to the award-winning1 S system, which was developed at Bell Laboratories by John Chambers et al. It provides a wide variety of statistical and graphical techniques (linear and nonlinear modelling, statistical tests, time series analysis, classification, clustering, ...).\nThis manual provides information on data types, programming elements, statistical modelling and graphics.\nThis manual is for R, version 4.3.0 Under development.\nCopyright © 1990 W. N. Venables\nCopyright © 1992 W. N. Venables & D. M. Smith\nCopyright © 1997 R. Gentleman & R. Ihaka\nCopyright © 1997, 1998 M. Maechler\nCopyright © 1999–2022 R Core Team\n\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that this permission notice may be stated in a translation approved by the R Core Team."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-the-r-environment",
    "href": "tutorials/R/r-manuals/test.html#sec-the-r-environment",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.1 The R environment",
    "text": "1.1 The R environment\nR is an integrated suite of software facilities for data manipulation, calculation and graphical display. Among other things it has\n\nan effective data handling and storage facility,\na suite of operators for calculations on arrays, in particular matrices,\na large, coherent, integrated collection of intermediate tools for data analysis,\ngraphical facilities for data analysis and display either directly at the computer or on hardcopy, and\na well developed, simple and effective programming language (called ‘S’) which includes conditionals, loops, user defined recursive functions and input and output facilities. (Indeed most of the system supplied functions are themselves written in the S language.)\n\nThe term “environment” is intended to characterize it as a fully planned and coherent system, rather than an incremental accretion of very specific and inflexible tools, as is frequently the case with other data analysis software.\nR is very much a vehicle for newly developing methods of interactive data analysis. It has developed rapidly, and has been extended by a large collection of packages. However, most programs written in R are essentially ephemeral, written for a single piece of data analysis."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-related-software-and-documentation",
    "href": "tutorials/R/r-manuals/test.html#sec-related-software-and-documentation",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.2 Related software and documentation",
    "text": "1.2 Related software and documentation\nR can be regarded as an implementation of the S language which was developed at Bell Laboratories by Rick Becker, John Chambers and Allan Wilks, and also forms the basis of the S-PLUS systems.\nThe evolution of the S language is characterized by four books by John Chambers and coauthors. For R, the basic reference is The New S Language: A Programming Environment for Data Analysis and Graphics by Richard A. Becker, John M. Chambers and Allan R. Wilks. The new features of the 1991 release of S are covered in Statistical Models in S edited by John M. Chambers and Trevor J. Hastie. The formal methods and classes of the methods package are based on those described in Programming with Data by John M. Chambers. See References, for precise references.\nThere are now a number of books which describe how to use R for data analysis and statistics, and documentation for S/S-PLUS can typically be used with R, keeping the differences between the S implementations in mind. See What documentation exists for R in the R statistical system FAQ."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-r-and-statistics",
    "href": "tutorials/R/r-manuals/test.html#sec-r-and-statistics",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.3 R and statistics",
    "text": "1.3 R and statistics\nOur introduction to the R environment did not mention statistics, yet many people use R as a statistics system. We prefer to think of it of an environment within which many classical and modern statistical techniques have been implemented. A few of these are built into the base R environment, but many are supplied as packages. There are about 25 packages supplied with R (called “standard” and “recommended” packages) and many more are available through the CRAN family of Internet sites (via https://CRAN.R-project.org) and elsewhere. More details on packages are given later (see Section 13).\nMost classical statistics and much of the latest methodology is available for use with R, but users may need to be prepared to do a little work to find it.\nThere is an important difference in philosophy between S (and hence R) and the other main statistical systems. In S a statistical analysis is normally done as a series of steps, with intermediate results being stored in objects. Thus whereas SAS and SPSS will give copious output from a regression or discriminant analysis, R will give minimal output and store the results in a fit object for subsequent interrogation by further R functions."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-r-and-the-window-system",
    "href": "tutorials/R/r-manuals/test.html#sec-r-and-the-window-system",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.4 R and the window system",
    "text": "1.4 R and the window system\nThe most convenient way to use R is at a graphics workstation running a windowing system. This guide is aimed at users who have this facility. In particular we will occasionally refer to the use of R on an X window system although the vast bulk of what is said applies generally to any implementation of the R environment.\nMost users will find it necessary to interact directly with the operating system on their computer from time to time. In this guide, we mainly discuss interaction with the operating system on UNIX machines. If you are running R under Windows or macOS you will need to make some small adjustments.\nSetting up a workstation to take full advantage of the customizable features of R is a straightforward if somewhat tedious procedure, and will not be considered further here. Users in difficulty should seek local expert help."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-using-r-interactively",
    "href": "tutorials/R/r-manuals/test.html#sec-using-r-interactively",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.5 Using R interactively",
    "text": "1.5 Using R interactively\nWhen you use the R program it issues a prompt when it expects input commands. The default prompt is >, which on UNIX might be the same as the shell prompt, and so it may appear that nothing is happening. However, as we shall see, it is easy to change to a different R prompt if you wish. We will assume that the UNIX shell prompt is $.\nIn using R under UNIX the suggested procedure for the first occasion is as follows:\n\nCreate a separate sub-directory, say work, to hold data files on which you will use R for this problem. This will be the working directory whenever you use R for this particular problem. R     $ mkdir work     $ cd work\nStart the R program with the command R     $ R\nAt this point R commands may be issued (see later).\nTo quit the R program the command is\n> q()\nAt this point you will be asked whether you want to save the data from your R session. On some systems this will bring up a dialog box, and on others you will receive a text prompt to which you can respond yes, no or cancel (a single letter abbreviation will do) to save the data before quitting, quit without saving, or return to the R session. Data which is saved will be available in future R sessions.\n\nFurther R sessions are simple.\n\nMake work the working directory and start the program as before: R     $ cd work     $ R\nUse the R program, terminating with the q() command at the end of the session.\n\nTo use R under Windows the procedure to follow is basically the same. Create a folder as the working directory, and set that in the Start In field in your R shortcut. Then launch R by double clicking on the icon."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-1.6-an-introductory-session",
    "href": "tutorials/R/r-manuals/test.html#sec-1.6-an-introductory-session",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.6 1.6 An introductory session",
    "text": "1.6 1.6 An introductory session\nReaders wishing to get a feel for R at a computer before proceeding are strongly advised to work through the introductory session given in Section 15."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-getting-help-with-functions-and-features",
    "href": "tutorials/R/r-manuals/test.html#sec-getting-help-with-functions-and-features",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.7 Getting help with functions and features",
    "text": "1.7 Getting help with functions and features\nR has an inbuilt help facility similar to the man facility of UNIX. To get more information on any specific named function, for example solve, the command is\n> help(solve)\nAn alternative is\n> ?solve\nFor a feature specified by special characters, the argument must be enclosed in double or single quotes, making it a “character string”: This is also necessary for a few words with syntactic meaning including if, for and function.\n> help(\"[[\")\nEither form of quote mark may be used to escape the other, as in the string \"It's important\". Our convention is to use double quote marks for preference.\nOn most R installations help is available in HTML format by running\n> help.start()\nwhich will launch a Web browser that allows the help pages to be browsed with hyperlinks. On UNIX, subsequent help requests are sent to the HTML-based help system. The ‘Search Engine and Keywords’ link in the page loaded by help.start() is particularly useful as it is contains a high-level concept list which searches though available functions. It can be a great way to get your bearings quickly and to understand the breadth of what R has to offer.\nThe help.search command (alternatively ??) allows searching for help in various ways. For example,\n> ??solve\nTry ?help.search for details and more examples.\nThe examples on a help topic can normally be run by\n> example(topic)\nWindows versions of R have other optional help systems: use\n> ?help\nfor further details."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-r-commands-case-sensitivity-etc.",
    "href": "tutorials/R/r-manuals/test.html#sec-r-commands-case-sensitivity-etc.",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.8 R commands, case sensitivity, etc.",
    "text": "1.8 R commands, case sensitivity, etc.\nTechnically R is an expression language with a very simple syntax. It is case sensitive as are most UNIX based packages, so A and a are different symbols and would refer to different variables. The set of symbols which can be used in R names depends on the operating system and country within which R is being run (technically on the locale in use). Normally all alphanumeric symbols are allowed2 (and in some countries this includes accented letters) plus . and _‘, with the restriction that a name must start with’. or a letter, and if it starts with . the second character must not be a digit. Names are effectively unlimited in length.\nElementary commands consist of either expressions or assignments. If an expression is given as a command, it is evaluated, printed (unless specifically made invisible), and the value is lost. An assignment also evaluates an expression and passes the value to a variable but the result is not automatically printed.\nCommands are separated either by a semi-colon (;), or by a newline. Elementary commands can be grouped together into one compound expression by braces ({’ and ’}). Comments can be put almost3 anywhere, starting with a hashmark (#), everything to the end of the line is a comment.\nIf a command is not complete at the end of a line, R will give a different prompt, by default\n+\non second and subsequent lines and continue to read input until the command is syntactically complete. This prompt may be changed by the user. We will generally omit the continuation prompt and indicate continuation by simple indenting.\nCommand lines entered at the console are limited4 to about 4095 bytes (not characters)."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-recall-and-correction-of-previous-commands",
    "href": "tutorials/R/r-manuals/test.html#sec-recall-and-correction-of-previous-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.9 Recall and correction of previous commands",
    "text": "1.9 Recall and correction of previous commands\nUnder many versions of UNIX and on Windows, R provides a mechanism for recalling and re-executing previous commands. The vertical arrow keys on the keyboard can be used to scroll forward and backward through a command history. Once a command is located in this way, the cursor can be moved within the command using the horizontal arrow keys, and characters can be removed with the DEL key or added with the other keys. More details are provided later: see Section 17 .\nThe recall and editing capabilities under UNIX are highly customizable. You can find out how to do this by reading the manual entry for the readline library.\nAlternatively, the Emacs text editor provides more general support mechanisms (via ESS, Emacs Speaks Statistics) for working interactively with R. See R and Emacs in The R statistical system FAQ."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-executing-commands-from-or-diverting-output-to-a-file",
    "href": "tutorials/R/r-manuals/test.html#sec-executing-commands-from-or-diverting-output-to-a-file",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.10 Executing commands from or diverting output to a file",
    "text": "1.10 Executing commands from or diverting output to a file\nIf commands5 are stored in an external file, say commands.R in the working directory work, they may be executed at any time in an R session with the command\n> source(\"commands.R\")\nFor Windows Source is also available on the File menu. The function sink,\n> sink(\"record.lis\")\nwill divert all subsequent output from the console to an external file, record.lis. The command\n> sink()\nrestores it to the console once again."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-data-permanency-and-removing-objects",
    "href": "tutorials/R/r-manuals/test.html#sec-data-permanency-and-removing-objects",
    "title": "R Manuals :: An Introduction to R",
    "section": "1.11 Data permanency and removing objects",
    "text": "1.11 Data permanency and removing objects\nThe entities that R creates and manipulates are known as objects. These may be variables, arrays of numbers, character strings, functions, or more general structures built from such components.\nDuring an R session, objects are created and stored by name (we discuss this process in the next section). The R command\n> objects()\n(alternatively, ls()) can be used to display the names of (most of) the objects which are currently stored within R. The collection of objects currently stored is called the workspace.\nTo remove objects the function rm is available:\n> rm(x, y, z, ink, junk, temp, foo, bar)\nAll objects created during an R session can be stored permanently in a file for use in future R sessions. At the end of each R session you are given the opportunity to save all the currently available objects. If you indicate that you want to do this, the objects are written to a file called .RData6 in the current directory, and the command lines used in the session are saved to a file called .Rhistory.\nWhen R is started at later time from the same directory it reloads the workspace from this file. At the same time the associated commands history is reloaded.\nIt is recommended that you should use separate working directories for analyses conducted with R. It is quite common for objects with names x and y to be created during an analysis. Names like this are often meaningful in the context of a single analysis, but it can be quite hard to decide what they might be when the several analyses have been conducted in the same directory."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-vectors-and-assignment",
    "href": "tutorials/R/r-manuals/test.html#sec-vectors-and-assignment",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.1 Vectors and assignment",
    "text": "2.1 Vectors and assignment\nR operates on named data structures. The simplest such structure is the numeric vector, which is a single entity consisting of an ordered collection of numbers. To set up a vector named x, say, consisting of five numbers, namely 10.4, 5.6, 3.1, 6.4 and 21.7, use the R command\n> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)\nThis is an assignment statement using the function c() which in this context can take an arbitrary number of vector arguments and whose value is a vector got by concatenating its arguments end to end.7\nA number occurring by itself in an expression is taken as a vector of length one.\nNotice that the assignment operator (<-), which consists of the two characters <’ (“less than”) and ‘- (“minus”) occurring strictly side-by-side and it ’points’ to the object receiving the value of the expression. In most contexts the = operator can be used as an alternative.\nAssignment can also be made using the function assign(). An equivalent way of making the same assignment as above is with:\n> assign(\"x\", c(10.4, 5.6, 3.1, 6.4, 21.7))\nThe usual operator, <-, can be thought of as a syntactic short-cut to this.\nAssignments can also be made in the other direction, using the obvious change in the assignment operator. So the same assignment could be made using\n> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x\nIf an expression is used as a complete command, the value is printed and lost8. So now if we were to use the command\n> 1/x\nthe reciprocals of the five values would be printed at the terminal (and the value of x, of course, unchanged).\nThe further assignment\n> y <- c(x, 0, x)\nwould create a vector y with 11 entries consisting of two copies of x with a zero in the middle place."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-vector-arithmetic",
    "href": "tutorials/R/r-manuals/test.html#sec-vector-arithmetic",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.2 Vector arithmetic",
    "text": "2.2 Vector arithmetic\nVectors can be used in arithmetic expressions, in which case the operations are performed element by element. Vectors occurring in the same expression need not all be of the same length. If they are not, the value of the expression is a vector with the same length as the longest vector which occurs in the expression. Shorter vectors in the expression are recycled as often as need be (perhaps fractionally) until they match the length of the longest vector. In particular a constant is simply repeated. So with the above assignments the command\n> v <- 2*x + y + 1\ngenerates a new vector v of length 11 constructed by adding together, element by element, 2*x repeated 2.2 times, y repeated just once, and 1 repeated 11 times.\nThe elementary arithmetic operators are the usual +, -, *, / and ^ for raising to a power. In addition all of the common arithmetic functions are available. log, exp, sin, cos, tan, sqrt, and so on, all have their usual meaning. max and min select the largest and smallest elements of a vector respectively. range is a function whose value is a vector of length two, namely c(min(x), max(x)). length(x) is the number of elements in x, sum(x) gives the total of the elements in x, and prod(x) their product.\nTwo statistical functions are mean(x) which calculates the sample mean, which is the same as sum(x)/length(x), and var(x) which gives\nsum((x-mean(x))^2)/(length(x)-1)\nor sample variance. If the argument to var() is an n-by-p matrix the value is a p-by-p sample covariance matrix got by regarding the rows as independent p-variate sample vectors.\nsort(x) returns a vector of the same size as x with the elements arranged in increasing order; however there are other more flexible sorting facilities available (see order() or sort.list() which produce a permutation to do the sorting).\nNote that max and min select the largest and smallest values in their arguments, even if they are given several vectors. The parallel maximum and minimum functions pmax and pmin return a vector (of length equal to their longest argument) that contains in each element the largest (smallest) element in that position in any of the input vectors.\nFor most purposes the user will not be concerned if the “numbers” in a numeric vector are integers, reals or even complex. Internally calculations are done as double precision real numbers, or double precision complex numbers if the input data are complex.\nTo work with complex numbers, supply an explicit complex part. Thus\nsqrt(-17)\nwill give NaN and a warning, but\nsqrt(-17+0i)\nwill do the computations as complex numbers."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-generating-regular-sequences",
    "href": "tutorials/R/r-manuals/test.html#sec-generating-regular-sequences",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.3 Generating regular sequences",
    "text": "2.3 Generating regular sequences\nR has a number of facilities for generating commonly used sequences of numbers. For example 1:30 is the vector c(1, 2, …, 29, 30). The colon operator has high priority within an expression, so, for example 2*1:15 is the vector c(2, 4, …, 28, 30). Put n <- 10 and compare the sequences 1:n-1 and 1:(n-1).\nThe construction 30:1 may be used to generate a sequence backwards.\nThe function seq() is a more general facility for generating sequences. It has five arguments, only some of which may be specified in any one call. The first two arguments, if given, specify the beginning and end of the sequence, and if these are the only two arguments given the result is the same as the colon operator. That is seq(2,10) is the same vector as 2:10.\nArguments to seq(), and to many other R functions, can also be given in named form, in which case the order in which they appear is irrelevant. The first two arguments may be named from=``value and to=``value; thus seq(1,30), seq(from=1, to=30) and seq(to=30, from=1) are all the same as 1:30. The next two arguments to seq() may be named by=``value and length=``value, which specify a step size and a length for the sequence respectively. If neither of these is given, the default by=1 is assumed.\nFor example\n> seq(-5, 5, by=.2) -> s3\ngenerates in s3 the vector c(-5.0, -4.8, -4.6, …, 4.6, 4.8, 5.0). Similarly\n> s4 <- seq(length=51, from=-5, by=.2)\ngenerates the same vector in s4.\nThe fifth argument may be named along=``vector, which is normally used as the only argument to create the sequence 1, 2, …, length(``vector), or the empty sequence if the vector is empty (as it can be).\nA related function is rep() which can be used for replicating an object in various complicated ways. The simplest form is\n> s5 <- rep(x, times=5)\nwhich will put five copies of x end-to-end in s5. Another useful version is\n> s6 <- rep(x, each=5)\nwhich repeats each element of x five times before moving on to the next."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-logical-vectors",
    "href": "tutorials/R/r-manuals/test.html#sec-logical-vectors",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.4 Logical vectors",
    "text": "2.4 Logical vectors\nAs well as numerical vectors, R allows manipulation of logical quantities. The elements of a logical vector can have the values TRUE, FALSE, and NA (for “not available”, see below). The first two are often abbreviated as T and F, respectively. Note however that T and F are just variables which are set to TRUE and FALSE by default, but are not reserved words and hence can be overwritten by the user. Hence, you should always use TRUE and FALSE.\nLogical vectors are generated by conditions. For example\n> temp <- x > 13\nsets temp as a vector of the same length as x with values FALSE corresponding to elements of x where the condition is not met and TRUE where it is.\nThe logical operators are <, <=, >, >=, == for exact equality and != for inequality. In addition if c1 and c2 are logical expressions, then c1 & c2 is their intersection (“and”), c1 | c2 is their union (“or”), and !c1 is the negation of c1.\nLogical vectors may be used in ordinary arithmetic, in which case they are coerced into numeric vectors, FALSE becoming 0 and TRUE becoming 1. However there are situations where logical vectors and their coerced numeric counterparts are not equivalent, for example see the next subsection."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-missing-values",
    "href": "tutorials/R/r-manuals/test.html#sec-missing-values",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.5 Missing values",
    "text": "2.5 Missing values\nIn some cases the components of a vector may not be completely known. When an element or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an NA becomes an NA. The motivation for this rule is simply that if the specification of an operation is incomplete, the result cannot be known and hence is not available.\nThe function is.na(x) gives a logical vector of the same size as x with value TRUE if and only if the corresponding element in x is NA.\n> z <- c(1:3,NA);  ind <- is.na(z)\nNotice that the logical expression x == NA is quite different from is.na(x) since NA is not really a value but a marker for a quantity that is not available. Thus x == NA is a vector of the same length as x all of whose values are NA as the logical expression itself is incomplete and hence undecidable.\nNote that there is a second kind of “missing” values which are produced by numerical computation, the so-called Not a Number, NaN, values. Examples are\n> 0/0\nor\n> Inf - Inf\nwhich both give NaN since the result cannot be defined sensibly.\nIn summary, is.na(xx) is TRUE both for NA and NaN values. To differentiate these, is.nan(xx) is only TRUE for NaNs.\nMissing values are sometimes printed as <NA> when character vectors are printed without quotes."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-character-vectors",
    "href": "tutorials/R/r-manuals/test.html#sec-character-vectors",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.6 Character vectors",
    "text": "2.6 Character vectors\nCharacter quantities and character vectors are used frequently in R, for example as plot labels. Where needed they are denoted by a sequence of characters delimited by the double quote character, e.g., \"x-values\", \"New iteration results\".\nCharacter strings are entered using either matching double (\") or single (') quotes, but are printed using double quotes (or sometimes without quotes). They use C-style escape sequences, using \\ as the escape character, so \\ is entered and printed as \\\\, and inside double quotes \" is entered as \\\". Other useful escape sequences are \\n, newline, \\t, tab and \\b, backspace—see ?Quotes for a full list.\nCharacter vectors may be concatenated into a vector by the c() function; examples of their use will emerge frequently.\nThe paste() function takes an arbitrary number of arguments and concatenates them one by one into character strings. Any numbers given among the arguments are coerced into character strings in the evident way, that is, in the same way they would be if they were printed. The arguments are by default separated in the result by a single blank character, but this can be changed by the named argument, sep=``string, which changes it to string, possibly empty.\nFor example\n> labs <- paste(c(\"X\",\"Y\"), 1:10, sep=\"\")\nmakes labs into the character vector\nc(\"X1\", \"Y2\", \"X3\", \"Y4\", \"X5\", \"Y6\", \"X7\", \"Y8\", \"X9\", \"Y10\")\nNote particularly that recycling of short lists takes place here too; thus c(\"X\", \"Y\") is repeated 5 times to match the sequence 1:10. 9"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-index-vectors-selecting-and-modifying-subsets-of-a-data-set",
    "href": "tutorials/R/r-manuals/test.html#sec-index-vectors-selecting-and-modifying-subsets-of-a-data-set",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.7 Index vectors; selecting and modifying subsets of a data set",
    "text": "2.7 Index vectors; selecting and modifying subsets of a data set\nSubsets of the elements of a vector may be selected by appending to the name of the vector an index vector in square brackets. More generally any expression that evaluates to a vector may have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression.\nSuch index vectors can be any of four distinct types.\n\nA logical vector. In this case the index vector is recycled to the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected and those corresponding to FALSE are omitted. For example\n> y <- x[!is.na(x)]\ncreates (or re-creates) an object y which will contain the non-missing values of x, in the same order. Note that if x has missing values, y will be shorter than x. Also\n> (x+1)[(!is.na(x)) & x>0] -> z\ncreates an object z and places in it the values of the vector x+1 for which the corresponding value in x was both non-missing and positive.\nA vector of positive integral quantities. In this case the values in the index vector must lie in the set {1, 2, …, length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x and\n> x[1:10]\nselects the first 10 elements of x (assuming length(x) is not less than 10). Also\n> c(\"x\",\"y\")[rep(c(1,2,2,1), times=4)]\n(an admittedly unlikely thing to do) produces a character vector of length 16 consisting of \"x\", \"y\", \"y\", \"x\" repeated four times.\nA vector of negative integral quantities. Such an index vector specifies the values to be excluded rather than included. Thus\n> y <- x[-(1:5)]\ngives y all but the first five elements of x.\nA vector of character strings. This possibility only applies where an object has a names attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above.\n> fruit <- c(5, 10, 1, 20)\n> names(fruit) <- c(\"orange\", \"banana\", \"apple\", \"peach\")\n> lunch <- fruit[c(\"apple\",\"orange\")]\nThe advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with data frames, as we shall see later.\n\nAn indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form vector[``index_vector] as having an arbitrary expression in place of the vector name does not make much sense here.\nFor example\n> x[is.na(x)] <- 0\nreplaces any missing values in x by zeros and\n> y[y < 0] <- -y[y < 0]\nhas the same effect as\n> y <- abs(y)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-other-types-of-objects",
    "href": "tutorials/R/r-manuals/test.html#sec-other-types-of-objects",
    "title": "R Manuals :: An Introduction to R",
    "section": "2.8 Other types of objects",
    "text": "2.8 Other types of objects\nVectors are the most important type of object in R, but there are several others which we will meet more formally in later sections.\n\nmatrices or more generally arrays are multi-dimensional generalizations of vectors. In fact, they are vectors that can be indexed by two or more indices and will be printed in special ways. @#sec-arrays-and-matrices.\nfactors provide compact ways to handle categorical data. See\n\n\n\nlists are a general form of vector in which the various elements need not be of the same type, and are often themselves vectors or lists. Lists provide a convenient way to return the results of a statistical computation. See Section 6.1.\ndata frames are matrix-like structures, in which the columns can be of different types. Think of data frames as ‘data matrices’ with one row per observational unit but with (possibly) both numerical and categorical variables. Many experiments are best described by data frames: the treatments are categorical but the response is numeric. See Section 6.3.\nfunctions are themselves objects in R which can be stored in the project’s workspace. This provides a simple and convenient way to extend R. See Section 10 ."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-intrinsic-attributes:-mode-and-length",
    "href": "tutorials/R/r-manuals/test.html#sec-intrinsic-attributes:-mode-and-length",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.1 Intrinsic attributes: mode and length",
    "text": "3.1 Intrinsic attributes: mode and length\nThe entities R operates on are technically known as objects. Examples are vectors of numeric (real) or complex values, vectors of logical values and vectors of character strings. These are known as “atomic” structures since their components are all of the same type, or mode, namely numeric10, complex, logical, character and raw.\nVectors must have their values all of the same mode. Thus any given vector must be unambiguously either logical, numeric, complex, character or raw. (The only apparent exception to this rule is the special “value” listed as NA for quantities not available, but in fact there are several types of NA). Note that a vector can be empty and still have a mode. For example the empty character string vector is listed as character(0) and the empty numeric vector as numeric(0).\nR also operates on objects called lists, which are of mode list. These are ordered sequences of objects which individually can be of any mode. lists are known as “recursive” rather than atomic structures since their components can themselves be lists in their own right.\nThe other recursive structures are those of mode function and expression. Functions are the objects that form part of the R system along with similar user written functions, which we discuss in some detail later. Expressions as objects form an advanced part of R which will not be discussed in this guide, except indirectly when we discuss formulae used with modeling in R.\nBy the mode of an object we mean the basic type of its fundamental constituents. This is a special case of a “property” of an object. Another property of every object is its length. The functions mode(``object) and length(``object) can be used to find out the mode and length of any defined structure 11.\nFurther properties of an object are usually provided by attributes(``object), see Getting and setting attributes. Because of this, mode and length are also called “intrinsic attributes” of an object.\nFor example, if z is a complex vector of length 100, then in an expression mode(z) is the character string \"complex\" and length(z) is 100.\nR caters for changes of mode almost anywhere it could be considered sensible to do so, (and a few where it might not be). For example with\n> z <- 0:9\nwe could put\n> digits <- as.character(z)\nafter which digits is the character vector c(\"0\", \"1\", \"2\", …, \"9\"). A further coercion, or change of mode, reconstructs the numerical vector again:\n> d <- as.integer(digits)\nNow d and z are the same.12 There is a large collection of functions of the form as.``something() for either coercion from one mode to another, or for investing an object with some other attribute it may not already possess. The reader should consult the different help files to become familiar with them."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-changing-the-length-of-an-object",
    "href": "tutorials/R/r-manuals/test.html#sec-changing-the-length-of-an-object",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.2 Changing the length of an object",
    "text": "3.2 Changing the length of an object\nAn “empty” object may still have a mode. For example\n> e <- numeric()\nmakes e an empty vector structure of mode numeric. Similarly character() is a empty character vector, and so on. Once an object of any size has been created, new components may be added to it simply by giving it an index value outside its previous range. Thus\n> e[3] <- 17\nnow makes e a vector of length 3, (the first two components of which are at this point both NA). This applies to any structure at all, provided the mode of the additional component(s) agrees with the mode of the object in the first place.\nThis automatic adjustment of lengths of an object is used often, for example in the scan() function for input. (see The scan() function.)\nConversely to truncate the size of an object requires only an assignment to do so. Hence if alpha is an object of length 10, then\n> alpha <- alpha[2 * 1:5]\nmakes it an object of length 5 consisting of just the former components with even index. (The old indices are not retained, of course.) We can then retain just the first three values by\n> length(alpha) <- 3\nand vectors can be extended (by missing values) in the same way."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-getting-and-setting-attributes",
    "href": "tutorials/R/r-manuals/test.html#sec-getting-and-setting-attributes",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.3 Getting and setting attributes",
    "text": "3.3 Getting and setting attributes\nThe function attributes(``object) returns a list of all the non-intrinsic attributes currently defined for that object. The function attr(``object, ``name) can be used to select a specific attribute. These functions are rarely used, except in rather special circumstances when some new attribute is being created for some particular purpose, for example to associate a creation date or an operator with an R object. The concept, however, is very important.\nSome care should be exercised when assigning or deleting attributes since they are an integral part of the object system used in R.\nWhen it is used on the left hand side of an assignment it can be used either to associate a new attribute with object or to change an existing one. For example\n> attr(z, \"dim\") <- c(10,10)\nallows R to treat z as if it were a 10-by-10 matrix."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-the-class-of-an-object",
    "href": "tutorials/R/r-manuals/test.html#sec-the-class-of-an-object",
    "title": "R Manuals :: An Introduction to R",
    "section": "3.4 The class of an object",
    "text": "3.4 The class of an object\nAll objects in R have a class, reported by the function class. For simple vectors this is just the mode, for example \"numeric\", \"logical\", \"character\" or \"list\", but \"matrix\", \"array\", \"factor\" and \"data.frame\" are other possible values.\nA special attribute known as the class of the object is used to allow for an object-oriented style13 of programming in R. For example if an object has class \"data.frame\", it will be printed in a certain way, the plot() function will display it graphically in a certain way, and other so-called generic functions such as summary() will react to it as an argument in a way sensitive to its class.\nTo remove temporarily the effects of class, use the function unclass(). For example if winter has the class \"data.frame\" then\n> winter\nwill print it in data frame form, which is rather like a matrix, whereas\n> unclass(winter)\nwill print it as an ordinary list. Only in rather special situations do you need to use this facility, but one is when you are learning to come to terms with the idea of class and generic functions.\nGeneric functions and classes will be discussed further in Object orientation, but only briefly."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-4.1-a-specific-example",
    "href": "tutorials/R/r-manuals/test.html#sec-4.1-a-specific-example",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.1 4.1 A specific example",
    "text": "4.1 4.1 A specific example\nSuppose, for example, we have a sample of 30 tax accountants from all the states and territories of Australia14 and their individual state of origin is specified by a character vector of state mnemonics as\n> state <- c(\"tas\", \"sa\",  \"qld\", \"nsw\", \"nsw\", \"nt\",  \"wa\",  \"wa\",\n             \"qld\", \"vic\", \"nsw\", \"vic\", \"qld\", \"qld\", \"sa\",  \"tas\",\n             \"sa\",  \"nt\",  \"wa\",  \"vic\", \"qld\", \"nsw\", \"nsw\", \"wa\",\n             \"sa\",  \"act\", \"nsw\", \"vic\", \"vic\", \"act\")\nNotice that in the case of a character vector, “sorted” means sorted in alphabetical order.\nA factor is similarly created using the factor() function:\n> statef <- factor(state)\nThe print() function handles factors slightly differently from other objects:\n> statef\n [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa\n[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act\nLevels:  act nsw nt qld sa tas vic wa\nTo find out the levels of a factor the function levels() can be used.\n> levels(statef)\n[1] \"act\" \"nsw\" \"nt\"  \"qld\" \"sa\"  \"tas\" \"vic\" \"wa\"\n\n\n\n• The function tapply() and ragged arrays\n  \n\n\n\n• Ordered factors"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-function-tapply-and-ragged-arrays-sec-the-function-tapply-and-ragged-arrays",
    "href": "tutorials/R/r-manuals/test.html#the-function-tapply-and-ragged-arrays-sec-the-function-tapply-and-ragged-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.2 The function tapply() and ragged arrays {#sec-the-function-tapply()-and-ragged-arrays}",
    "text": "4.2 The function tapply() and ragged arrays {#sec-the-function-tapply()-and-ragged-arrays}\nTo continue the previous example, suppose we have the incomes of the same tax accountants in another vector (in suitably large units of money)\n> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,\n               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,\n               59, 46, 58, 43)\nTo calculate the sample mean income for each state we can now use the special function tapply():\n> incmeans <- tapply(incomes, statef, mean)\ngiving a means vector with the components labelled by the levels\n   act    nsw     nt    qld     sa    tas    vic     wa\n44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250\nThe function tapply() is used to apply a function, here mean(), to each group of components of the first argument, here incomes, defined by the levels of the second component, here statef15, as if they were separate vector structures. The result is a structure of the same length as the levels attribute of the factor containing the results. The reader should consult the help document for more details.\nSuppose further we needed to calculate the standard errors of the state income means. To do this we need to write an R function to calculate the standard error for any given vector. Since there is an builtin function var() to calculate the sample variance, such a function is a very simple one liner, specified by the assignment:\n> stdError <- function(x) sqrt(var(x)/length(x))\n(Writing functions will be considered later in Section 10 . Note that R’s a builtin function sd() is something different.) After this assignment, the standard errors are calculated by\n> incster <- tapply(incomes, statef, stdError)\nand the values calculated are then\n> incster\nact    nsw  nt    qld     sa tas   vic     wa\n1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575\nAs an exercise you may care to find the usual 95% confidence limits for the state mean incomes. To do this you could use tapply() once more with the length() function to find the sample sizes, and the qt() function to find the percentage points of the appropriate t-distributions. (You could also investigate R’s facilities for t-tests.)\nThe function tapply() can also be used to handle more complicated indexing of a vector by multiple categories. For example, we might wish to split the tax accountants by both state and sex. However in this simple instance (just one factor) what happens can be thought of as follows. The values in the vector are collected into groups corresponding to the distinct entries in the factor. The function is then applied to each of these groups individually. The value is a vector of function results, labelled by the levels attribute of the factor.\nThe combination of a vector and a labelling factor is an example of what is sometimes called a ragged array, since the subclass sizes are possibly irregular. When the subclass sizes are all the same the indexing may be done implicitly and much more efficiently, as we see in the next section."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-ordered-factors",
    "href": "tutorials/R/r-manuals/test.html#sec-ordered-factors",
    "title": "R Manuals :: An Introduction to R",
    "section": "4.3 Ordered factors",
    "text": "4.3 Ordered factors\nThe levels of factors are stored in alphabetical order, or in the order they were specified to factor if they were specified explicitly.\nSometimes the levels will have a natural ordering that we want to record and want our statistical analysis to make use of. The ordered() function creates such ordered factors but is otherwise identical to factor. For most purposes the only difference between ordered and unordered factors is that the former are printed showing the ordering of the levels, but the contrasts generated for them in fitting linear models are different."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-arrays",
    "href": "tutorials/R/r-manuals/test.html#sec-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.1 Arrays",
    "text": "5.1 Arrays\nAn array can be considered as a multiply subscripted collection of data entries, for example numeric. R allows simple facilities for creating and handling arrays, and in particular the special case of matrices.\nA dimension vector is a vector of non-negative integers. If its length is k then the array is k-dimensional, e.g. a matrix is a 2-dimensional array. The dimensions are indexed from one up to the values given in the dimension vector.\nA vector can be used by R as an array only if it has a dimension vector as its dim attribute. Suppose, for example, z is a vector of 1500 elements. The assignment\n> dim(z) <- c(3,5,100)\ngives it the dim attribute that allows it to be treated as a 3 by 5 by 100 array.\nOther functions such as matrix() and array() are available for simpler and more natural looking assignments, as we shall see in The array() function.\nThe values in the data vector give the values in the array in the same order as they would occur in FORTRAN, that is “column major order,” with the first subscript moving fastest and the last subscript slowest.\nFor example if the dimension vector for an array, say a, is c(3,4,2) then there are 3 * 4 * 2 = 24 entries in a and the data vector holds them in the order a[1,1,1], a[2,1,1], …, a[2,4,2], a[3,4,2].\nArrays can be one-dimensional: such arrays are usually treated in the same way as vectors (including when printing), but the exceptions can cause confusion."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-array-indexing.-subsections-of-an-array",
    "href": "tutorials/R/r-manuals/test.html#sec-array-indexing.-subsections-of-an-array",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.2 Array indexing. Subsections of an array",
    "text": "5.2 Array indexing. Subsections of an array\nIndividual elements of an array may be referenced by giving the name of the array followed by the subscripts in square brackets, separated by commas.\nMore generally, subsections of an array may be specified by giving a sequence of index vectors in place of subscripts; however if any index position is given an empty index vector, then the full range of that subscript is taken.\nContinuing the previous example, a[2,,] is a 4 * 2 array with dimension vector c(4,2) and data vector containing the values\nc(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],\n  a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])\nin that order. a[,,] stands for the entire array, which is the same as omitting the subscripts entirely and using a alone.\nFor any array, say Z, the dimension vector may be referenced explicitly as dim(Z) (on either side of an assignment).\nAlso, if an array name is given with just one subscript or index vector, then the corresponding values of the data vector only are used; in this case the dimension vector is ignored. This is not the case, however, if the single index is not a vector but itself an array, as we next discuss."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-index-matrices",
    "href": "tutorials/R/r-manuals/test.html#sec-index-matrices",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.3 Index matrices",
    "text": "5.3 Index matrices\nAs well as an index vector in any subscript position, a matrix may be used with a single index matrix in order either to assign a vector of quantities to an irregular collection of elements in the array, or to extract an irregular collection as a vector.\nA matrix example makes the process clear. In the case of a doubly indexed array, an index matrix may be given consisting of two columns and as many rows as desired. The entries in the index matrix are the row and column indices for the doubly indexed array. Suppose for example we have a 4 by 5 array X and we wish to do the following:\n\nExtract elements X[1,3], X[2,2] and X[3,1] as a vector structure, and\nReplace these entries in the array X by zeroes.\n\nIn this case we need a 3 by 2 subscript array, as in the following example.\n> x <- array(1:20, dim=c(4,5))   # Generate a 4 by 5 array.\n> x\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n> i <- array(c(1:3,3:1), dim=c(3,2))\n> i                             # i is a 3 by 2 index array.\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    2\n[3,]    3    1\n> x[i]                          # Extract those elements\n[1] 9 6 3\n> x[i] <- 0                     # Replace those elements by zeros.\n> x\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    0   13   17\n[2,]    2    0   10   14   18\n[3,]    0    7   11   15   19\n[4,]    4    8   12   16   20\n>\nNegative indices are not allowed in index matrices. NA and zero values are allowed: rows in the index matrix containing a zero are ignored, and rows containing an NA produce an NA in the result.\nAs a less trivial example, suppose we wish to generate an (unreduced) design matrix for a block design defined by factors blocks (b levels) and varieties (v levels). Further suppose there are n plots in the experiment. We could proceed as follows:\n> Xb <- matrix(0, n, b)\n> Xv <- matrix(0, n, v)\n> ib <- cbind(1:n, blocks)\n> iv <- cbind(1:n, varieties)\n> Xb[ib] <- 1\n> Xv[iv] <- 1\n> X <- cbind(Xb, Xv)\nTo construct the incidence matrix, N say, we could use\n> N <- crossprod(Xb, Xv)\nHowever a simpler direct way of producing this matrix is to use table():\n> N <- table(blocks, varieties)\nIndex matrices must be numerical: any other form of matrix (e.g. a logical or character matrix) supplied as a matrix is treated as an indexing vector."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-array-function-sec-the-array-function",
    "href": "tutorials/R/r-manuals/test.html#the-array-function-sec-the-array-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.4 The array() function {#sec-the-array()-function}",
    "text": "5.4 The array() function {#sec-the-array()-function}\nAs well as giving a vector structure a dim attribute, arrays can be constructed from vectors by the array function, which has the form\n> Z <- array(data_vector, dim_vector)\nFor example, if the vector h contains 24 or fewer, numbers then the command\n> Z <- array(h, dim=c(3,4,2))\nwould use h to set up 3 by 4 by 2 array in Z. If the size of h is exactly 24 the result is the same as\n> Z <- h ; dim(Z) <- c(3,4,2)\nHowever if h is shorter than 24, its values are recycled from the beginning again to make it up to size 24 (see The recycling rule) but dim(h) <- c(3,4,2) would signal an error about mismatching length. As an extreme but common example\n> Z <- array(0, c(3,4,2))\nmakes Z an array of all zeros.\nAt this point dim(Z) stands for the dimension vector c(3,4,2), and Z[1:24] stands for the data vector as it was in h, and Z[] with an empty subscript or Z with no subscript stands for the entire array as an array.\nArrays may be used in arithmetic expressions and the result is an array formed by element-by-element operations on the data vector. The dim attributes of operands generally need to be the same, and this becomes the dimension vector of the result. So if A, B and C are all similar arrays, then\n> D <- 2*A*B + C + 1\nmakes D a similar array with its data vector being the result of the given element-by-element operations. However the precise rule concerning mixed array and vector calculations has to be considered a little more carefully.\n\n5.4.1 Mixed vector and array arithmetic. The recycling rule\nThe precise rule affecting element by element mixed calculations with vectors and arrays is somewhat quirky and hard to find in the references. From experience we have found the following to be a reliable guide.\n\nThe expression is scanned from left to right.\nAny short vector operands are extended by recycling their values until they match the size of any other operands.\nAs long as short vectors and arrays only are encountered, the arrays must all have the same dim attribute or an error results.\nAny vector operand longer than a matrix or array operand generates an error.\nIf array structures are present and no error or coercion to vector has been precipitated, the result is an array structure with the common dim attribute of its array operands."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-the-outer-product-of-two-arrays",
    "href": "tutorials/R/r-manuals/test.html#sec-the-outer-product-of-two-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.5 The outer product of two arrays",
    "text": "5.5 The outer product of two arrays\nAn important operation on arrays is the outer product. If a and b are two numeric arrays, their outer product is an array whose dimension vector is obtained by concatenating their two dimension vectors (order is important), and whose data vector is got by forming all possible products of elements of the data vector of a with those of b. The outer product is formed by the special operator %o%:\n> ab <- a %o% b\nAn alternative is\n> ab <- outer(a, b, \"*\")\nThe multiplication function can be replaced by an arbitrary function of two variables. For example if we wished to evaluate the function f(x; y) = cos(y)/(1 + x^2) over a regular grid of values with x- and y-coordinates defined by the R vectors x and y respectively, we could proceed as follows:\n> f <- function(x, y) cos(y)/(1 + x^2)\n> z <- outer(x, y, f)\nIn particular the outer product of two ordinary vectors is a doubly subscripted array (that is a matrix, of rank at most 1). Notice that the outer product operator is of course non-commutative. Defining your own R functions will be considered further in Section 10 .\n\n5.5.1 An example: Determinants of 2 by 2 single-digit matrices\nAs an artificial but cute example, consider the determinants of 2 by 2 matrices [a, b; c, d] where each entry is a non-negative integer in the range 0, 1, …, 9, that is a digit.\nThe problem is to find the determinants, ad - bc, of all possible matrices of this form and represent the frequency with which each value occurs as a high density plot. This amounts to finding the probability distribution of the determinant if each digit is chosen independently and uniformly at random.\nA neat way of doing this uses the outer() function twice:\n> d <- outer(0:9, 0:9)\n> fr <- table(outer(d, d, \"-\"))\n> plot(fr, xlab=\"Determinant\", ylab=\"Frequency\")\nNotice that plot() here uses a histogram like plot method, because it “sees” that fr is of class \"table\". The “obvious” way of doing this problem with for loops, to be discussed in Loops and conditional execution, is so inefficient as to be impractical.\nIt is also perhaps surprising that about 1 in 20 such matrices is singular."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-generalized-transpose-of-an-array",
    "href": "tutorials/R/r-manuals/test.html#sec-generalized-transpose-of-an-array",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.6 Generalized transpose of an array",
    "text": "5.6 Generalized transpose of an array\nThe function aperm(a, perm) may be used to permute an array, a. The argument perm must be a permutation of the integers {1, …, k}, where k is the number of subscripts in a. The result of the function is an array of the same size as a but with old dimension given by perm[j] becoming the new j-th dimension. The easiest way to think of this operation is as a generalization of transposition for matrices. Indeed if A is a matrix, (that is, a doubly subscripted array) then B given by\n> B <- aperm(A, c(2,1))\nis just the transpose of A. For this special case a simpler function t() is available, so we could have used B <- t(A)."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-matrix-facilities",
    "href": "tutorials/R/r-manuals/test.html#sec-matrix-facilities",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.7 Matrix facilities",
    "text": "5.7 Matrix facilities\nAs noted above, a matrix is just an array with two subscripts. However it is such an important special case it needs a separate discussion. R contains many operators and functions that are available only for matrices. For example t(X) is the matrix transpose function, as noted above. The functions nrow(A) and ncol(A) give the number of rows and columns in the matrix A respectively.\n\n5.7.1 Matrix multiplication\nThe operator %*% is used for matrix multiplication. An n by 1 or 1 by n matrix may of course be used as an n-vector if in the context such is appropriate. Conversely, vectors which occur in matrix multiplication expressions are automatically promoted either to row or column vectors, whichever is multiplicatively coherent, if possible, (although this is not always unambiguously possible, as we see later).\nIf, for example, A and B are square matrices of the same size, then\n> A * B\nis the matrix of element by element products and\n> A %*% B\nis the matrix product. If x is a vector, then\n> x %*% A %*% x\nis a quadratic form.16\nThe function crossprod() forms “crossproducts”, meaning that crossprod(X, y) is the same as t(X) %*% y but the operation is more efficient. If the second argument to crossprod() is omitted it is taken to be the same as the first.\nThe meaning of diag() depends on its argument. diag(v), where v is a vector, gives a diagonal matrix with elements of the vector as the diagonal entries. On the other hand diag(M), where M is a matrix, gives the vector of main diagonal entries of M. This is the same convention as that used for diag() in MATLAB. Also, somewhat confusingly, if k is a single numeric value then diag(k) is the k by k identity matrix!\n\n\n5.7.2 Linear equations and inversion\nSolving linear equations is the inverse of matrix multiplication. When after\n> b <- A %*% x\nonly A and b are given, the vector x is the solution of that linear equation system. In R,\n> solve(A,b)\nsolves the system, returning x (up to some accuracy loss). Note that in linear algebra, formally x = A^{-1} %*% b where A^{-1} denotes the inverse of A, which can be computed by\nsolve(A)\nbut rarely is needed. Numerically, it is both inefficient and potentially unstable to compute x <- solve(A) %*% b instead of solve(A,b).\nThe quadratic form  x %*% A^{-1} %*% x   which is used in multivariate computations, should be computed by something like17 x %*% solve(A,x), rather than computing the inverse of A.\n\n\n5.7.3 Eigenvalues and eigenvectors\nThe function eigen(Sm) calculates the eigenvalues and eigenvectors of a symmetric matrix Sm. The result of this function is a list of two components named values and vectors. The assignment\n> ev <- eigen(Sm)\nwill assign this list to ev. Then ev$val is the vector of eigenvalues of Sm and ev$vec is the matrix of corresponding eigenvectors. Had we only needed the eigenvalues we could have used the assignment:\n> evals <- eigen(Sm)$values\nevals now holds the vector of eigenvalues and the second component is discarded. If the expression\n> eigen(Sm)\nis used by itself as a command the two components are printed, with their names. For large matrices it is better to avoid computing the eigenvectors if they are not needed by using the expression\n> evals <- eigen(Sm, only.values = TRUE)$values\n\n\n5.7.4 Singular value decomposition and determinants\nThe function svd(M) takes an arbitrary matrix argument, M, and calculates the singular value decomposition of M. This consists of a matrix of orthonormal columns U with the same column space as M, a second matrix of orthonormal columns V whose column space is the row space of M and a diagonal matrix of positive entries D such that M = U %*% D %*% t(V). D is actually returned as a vector of the diagonal elements. The result of svd(M) is actually a list of three components named d, u and v, with evident meanings.\nIf M is in fact square, then, it is not hard to see that\n> absdetM <- prod(svd(M)$d)\ncalculates the absolute value of the determinant of M. If this calculation were needed often with a variety of matrices it could be defined as an R function\n> absdet <- function(M) prod(svd(M)$d)\nafter which we could use absdet() as just another R function. As a further trivial but potentially useful example, you might like to consider writing a function, say tr(), to calculate the trace of a square matrix. [Hint: You will not need to use an explicit loop. Look again at the diag() function.]\nR has a builtin function det to calculate a determinant, including the sign, and another, determinant, to give the sign and modulus (optionally on log scale),\n\n\n5.7.5 Least squares fitting and the QR decomposition\nThe function lsfit() returns a list giving results of a least squares fitting procedure. An assignment such as\n> ans <- lsfit(X, y)\ngives the results of a least squares fit where y is the vector of observations and X is the design matrix. See the help facility for more details, and also for the follow-up function ls.diag() for, among other things, regression diagnostics. Note that a grand mean term is automatically included and need not be included explicitly as a column of X. Further note that you almost always will prefer using lm(.) (see Linear models) to lsfit() for regression modelling.\nAnother closely related function is qr() and its allies. Consider the following assignments\n> Xplus <- qr(X)\n> b <- qr.coef(Xplus, y)\n> fit <- qr.fitted(Xplus, y)\n> res <- qr.resid(Xplus, y)\nThese compute the orthogonal projection of y onto the range of X in fit, the projection onto the orthogonal complement in res and the coefficient vector for the projection in b, that is, b is essentially the result of the MATLAB ‘backslash’ operator.\nIt is not assumed that X has full column rank. Redundancies will be discovered and removed as they are found.\nThis alternative is the older, low-level way to perform least squares calculations. Although still useful in some contexts, it would now generally be replaced by the statistical models features, as will be discussed in Statistical models in R."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#forming-partitioned-matrices-cbind-and-rbind-sec-forming-partitioned-matrices-cbind-and-rbind",
    "href": "tutorials/R/r-manuals/test.html#forming-partitioned-matrices-cbind-and-rbind-sec-forming-partitioned-matrices-cbind-and-rbind",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.8 Forming partitioned matrices, cbind() and rbind() {#sec-forming-partitioned-matrices-cbind()-and-rbind()}",
    "text": "5.8 Forming partitioned matrices, cbind() and rbind() {#sec-forming-partitioned-matrices-cbind()-and-rbind()}\nAs we have already seen informally, matrices can be built up from other vectors and matrices by the functions cbind() and rbind(). Roughly cbind() forms matrices by binding together matrices horizontally, or column-wise, and rbind() vertically, or row-wise.\nIn the assignment\n> X <- cbind(arg_1, arg_2, arg_3, …)\nthe arguments to cbind() must be either vectors of any length, or matrices with the same column size, that is the same number of rows. The result is a matrix with the concatenated arguments arg_1, arg_2, … forming the columns.\nIf some of the arguments to cbind() are vectors they may be shorter than the column size of any matrices present, in which case they are cyclically extended to match the matrix column size (or the length of the longest vector if no matrices are given).\nThe function rbind() does the corresponding operation for rows. In this case any vector argument, possibly cyclically extended, are of course taken as row vectors.\nSuppose X1 and X2 have the same number of rows. To combine these by columns into a matrix X, together with an initial column of 1s we can use\n> X <- cbind(1, X1, X2)\nThe result of rbind() or cbind() always has matrix status. Hence cbind(x) and rbind(x) are possibly the simplest ways explicitly to allow the vector x to be treated as a column or row matrix respectively."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-concatenation-function-c-with-arrays-sec-the-concatenation-function-c-with-arrays",
    "href": "tutorials/R/r-manuals/test.html#the-concatenation-function-c-with-arrays-sec-the-concatenation-function-c-with-arrays",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.9 The concatenation function, c(), with arrays {#sec-the-concatenation-function-c()-with-arrays}",
    "text": "5.9 The concatenation function, c(), with arrays {#sec-the-concatenation-function-c()-with-arrays}\nIt should be noted that whereas cbind() and rbind() are concatenation functions that respect dim attributes, the basic c() function does not, but rather clears numeric objects of all dim and dimnames attributes. This is occasionally useful in its own right.\nThe official way to coerce an array back to a simple vector object is to use as.vector()\n> vec <- as.vector(X)\nHowever a similar result can be achieved by using c() with just one argument, simply for this side-effect:\n> vec <- c(X)\nThere are slight differences between the two, but ultimately the choice between them is largely a matter of style (with the former being preferable)."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-frequency-tables-from-factors",
    "href": "tutorials/R/r-manuals/test.html#sec-frequency-tables-from-factors",
    "title": "R Manuals :: An Introduction to R",
    "section": "5.10 Frequency tables from factors",
    "text": "5.10 Frequency tables from factors\nRecall that a factor defines a partition into groups. Similarly a pair of factors defines a two way cross classification, and so on. The function table() allows frequency tables to be calculated from equal length factors. If there are k factor arguments, the result is a k-way array of frequencies.\nSuppose, for example, that statef is a factor giving the state code for each entry in a data vector. The assignment\n> statefr <- table(statef)\ngives in statefr a table of frequencies of each state in the sample. The frequencies are ordered and labelled by the levels attribute of the factor. This simple case is equivalent to, but more convenient than,\n> statefr <- tapply(statef, statef, length)\nFurther suppose that incomef is a factor giving a suitably defined “income class” for each entry in the data vector, for example with the cut() function:\n> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef\nThen to calculate a two-way table of frequencies:\n> table(incomef,statef)\n         statef\nincomef   act nsw nt qld sa tas vic wa\n  (35,45]   1   1  0   1  0   0   1  0\n  (45,55]   1   1  1   1  2   0   1  3\n  (55,65]   0   3  1   3  2   2   2  1\n  (65,75]   0   1  0   0  0   0   1  0\nExtension to higher-way frequency tables is immediate."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-lists",
    "href": "tutorials/R/r-manuals/test.html#sec-lists",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.1 Lists",
    "text": "6.1 Lists\nAn R list is an object consisting of an ordered collection of objects known as its components.\nThere is no particular need for the components to be of the same mode or type, and, for example, a list could consist of a numeric vector, a logical value, a matrix, a complex vector, a character array, a function, and so on. Here is a simple example of how to make a list:\n> Lst <- list(name=\"Fred\", wife=\"Mary\", no.children=3,\n              child.ages=c(4,7,9))\nComponents are always numbered and may always be referred to as such. Thus if Lst is the name of a list with four components, these may be individually referred to as Lst[[1]], Lst[[2]], Lst[[3]] and Lst[[4]]. If, further, Lst[[4]] is a vector subscripted array then Lst[[4]][1] is its first entry.\nIf Lst is a list, then the function length(Lst) gives the number of (top level) components it has.\nComponents of lists may also be named, and in this case the component may be referred to either by giving the component name as a character string in place of the number in double square brackets, or, more conveniently, by giving an expression of the form\n> name$component_name\nfor the same thing.\nThis is a very useful convention as it makes it easier to get the right component if you forget the number.\nSo in the simple example given above:\nLst$name is the same as Lst[[1]] and is the string \"Fred\",\nLst$wife is the same as Lst[[2]] and is the string \"Mary\",\nLst$child.ages[1] is the same as Lst[[4]][1] and is the number 4.\nAdditionally, one can also use the names of the list components in double square brackets, i.e., Lst[[\"name\"]] is the same as Lst$name. This is especially useful, when the name of the component to be extracted is stored in another variable as in\n> x <- \"name\"; Lst[[x]]\nIt is very important to distinguish Lst[[1]] from Lst[1]. [[``…]] is the operator used to select a single element, whereas [``…] is a general subscripting operator. Thus the former is the first object in the list Lst, and if it is a named list the name is not included. The latter is a sublist of the list Lst consisting of the first entry only. If it is a named list, the names are transferred to the sublist.\nThe names of components may be abbreviated down to the minimum number of letters needed to identify them uniquely. Thus Lst$coefficients may be minimally specified as Lst$coe and Lst$covariance as Lst$cov.\nThe vector of names is in fact simply an attribute of the list like any other and may be handled as such. Other structures besides lists may, of course, similarly be given a names attribute also."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-constructing-and-modifying-lists",
    "href": "tutorials/R/r-manuals/test.html#sec-constructing-and-modifying-lists",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.2 Constructing and modifying lists",
    "text": "6.2 Constructing and modifying lists\nNew lists may be formed from existing objects by the function list(). An assignment of the form\n> Lst <- list(name_1=object_1, …, name_m=object_m)\nsets up a list Lst of m components using object_1, …, object_m for the components and giving them names as specified by the argument names, (which can be freely chosen). If these names are omitted, the components are numbered only. The components used to form the list are copied when forming the new list and the originals are not affected.\nLists, like any subscripted object, can be extended by specifying additional components. For example\n> Lst[5] <- list(matrix=Mat)\n\n6.2.1 Concatenating lists\nWhen the concatenation function c() is given list arguments, the result is an object of mode list also, whose components are those of the argument lists joined together in sequence.\n> list.ABC <- c(list.A, list.B, list.C)\nRecall that with vector objects as arguments the concatenation function similarly joined together all arguments into a single vector structure. In this case all other attributes, such as dim attributes, are discarded."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-data-frames",
    "href": "tutorials/R/r-manuals/test.html#sec-data-frames",
    "title": "R Manuals :: An Introduction to R",
    "section": "6.3 Data frames",
    "text": "6.3 Data frames\nA data frame is a list with class \"data.frame\". There are restrictions on lists that may be made into data frames, namely\n\nThe components must be vectors (numeric, character, or logical), factors, numeric matrices, lists, or other data frames.\nMatrices, lists, and data frames provide as many variables to the new data frame as they have columns, elements, or variables, respectively.\nVector structures appearing as variables of the data frame must all have the same length, and matrix structures must all have the same number of rows.\n\nA data frame may for many purposes be regarded as a matrix with columns possibly of differing modes and attributes. It may be displayed in matrix form, and its rows and columns extracted using matrix indexing conventions.\n\n6.3.1 Making data frames\nObjects satisfying the restrictions placed on the columns (components) of a data frame may be used to form one using the function data.frame:\n> accountants <- data.frame(home=statef, loot=incomes, shot=incomef)\nA list whose components conform to the restrictions of a data frame may be coerced into a data frame using the function as.data.frame()\nThe simplest way to construct a data frame from scratch is to use the read.table() function to read an entire data frame from an external file. This is discussed further in Reading data from files.\n\n\n6.3.2 attach() and detach() {#sec-attach()-and-detach()}\nThe $ notation, such as accountants$home, for list components is not always very convenient. A useful facility would be somehow to make the components of a list or data frame temporarily visible as variables under their component name, without the need to quote the list name explicitly each time.\nThe attach() function takes a ‘database’ such as a list or data frame as its argument. Thus suppose lentils is a data frame with three variables lentils$u, lentils$v, lentils$w. The attach\n> attach(lentils)\nplaces the data frame in the search path at position 2, and provided there are no variables u, v or w in position 1, u, v and w are available as variables from the data frame in their own right. At this point an assignment such as\n> u <- v+w\ndoes not replace the component u of the data frame, but rather masks it with another variable u in the working directory at position 1 on the search path. To make a permanent change to the data frame itself, the simplest way is to resort once again to the $ notation:\n> lentils$u <- v+w\nHowever the new value of component u is not visible until the data frame is detached and attached again.\nTo detach a data frame, use the function\n> detach()\nMore precisely, this statement detaches from the search path the entity currently at position 2. Thus in the present context the variables u, v and w would be no longer visible, except under the list notation as lentils$u and so on. Entities at positions greater than 2 on the search path can be detached by giving their number to detach, but it is much safer to always use a name, for example by detach(lentils) or detach(\"lentils\")\n\nNote: In R lists and data frames can only be attached at position 2 or above, and what is attached is a copy of the original object. You can alter the attached values via assign, but the original list or data frame is unchanged.\n\n\n\n6.3.3 Working with data frames\nA useful convention that allows you to work with many different problems comfortably together in the same working directory is\n\ngather together all variables for any well defined and separate problem in a data frame under a suitably informative name;\nwhen working with a problem attach the appropriate data frame at position 2, and use the working directory at level 1 for operational quantities and temporary variables;\nbefore leaving a problem, add any variables you wish to keep for future reference to the data frame using the $ form of assignment, and then detach();\nfinally remove all unwanted variables from the working directory and keep it as clean of left-over temporary variables as possible.\n\nIn this way it is quite simple to work with many problems in the same directory, all of which have variables named x, y and z, for example.\n\n\n6.3.4 Attaching arbitrary lists\nattach() is a generic function that allows not only directories and data frames to be attached to the search path, but other classes of object as well. In particular any object of mode \"list\" may be attached in the same way:\n> attach(any.old.list)\nAnything that has been attached can be detached by detach, by position number or, preferably, by name.\n\n\n6.3.5 Managing the search path\nThe function search shows the current search path and so is a very useful way to keep track of which data frames and lists (and packages) have been attached and detached. Initially it gives\n> search()\n[1] \".GlobalEnv\"   \"Autoloads\"    \"package:base\"\nwhere .GlobalEnv is the workspace.18\nAfter lentils is attached we have\n> search()\n[1] \".GlobalEnv\"   \"lentils\"      \"Autoloads\"    \"package:base\"\n> ls(2)\n[1] \"u\" \"v\" \"w\"\nand as we see ls (or objects) can be used to examine the contents of any position on the search path.\nFinally, we detach the data frame and confirm it has been removed from the search path.\n> detach(\"lentils\")\n> search()\n[1] \".GlobalEnv\"   \"Autoloads\"    \"package:base\""
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-read.table-function-sec-the-read.table-function",
    "href": "tutorials/R/r-manuals/test.html#the-read.table-function-sec-the-read.table-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.1 The read.table() function {#sec-the-read.table()-function}",
    "text": "7.1 The read.table() function {#sec-the-read.table()-function}\nTo read an entire data frame directly, the external file will normally have a special form.\n\nThe first line of the file should have a name for each variable in the data frame.\nEach additional line of the file has as its first item a row label and the values for each variable.\n\nIf the file has one fewer item in its first line than in its second, this arrangement is presumed to be in force. So the first few lines of a file to be read as a data frame might look as follows.\n\n\n\n\n\n\n\n\nInput file form with names and row labels:\n\n     Price    Floor     Area   Rooms     Age  Cent.heat\n01   52.00    111.0      830     5       6.2      no\n02   54.75    128.0      710     5       7.5      no\n03   57.50    101.0     1000     5       4.2      no\n04   57.50    131.0      690     6       8.8      no\n05   59.75     93.0      900     5       1.9     yes\n...\n\n\n\n\n\nBy default numeric items (except row labels) are read as numeric variables and non-numeric variables, such as Cent.heat in the example, as character variables. This can be changed if necessary.\nThe function read.table() can then be used to read the data frame directly\n> HousePrice <- read.table(\"houses.data\")\nOften you will want to omit including the row labels directly and use the default labels. In this case the file may omit the row label column as in the following.\n\n\n\n\n\n\n\n\nInput file form without row labels:\n\nPrice    Floor     Area   Rooms     Age  Cent.heat\n52.00    111.0      830     5       6.2      no\n54.75    128.0      710     5       7.5      no\n57.50    101.0     1000     5       4.2      no\n57.50    131.0      690     6       8.8      no\n59.75     93.0      900     5       1.9     yes\n...\n\n\n\n\n\nThe data frame may then be read as\n> HousePrice <- read.table(\"houses.data\", header=TRUE)\nwhere the header=TRUE option specifies that the first line is a line of headings, and hence, by implication from the form of the file, that no explicit row labels are given."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-scan-function-sec-the-scan-function",
    "href": "tutorials/R/r-manuals/test.html#the-scan-function-sec-the-scan-function",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.2 The scan() function {#sec-the-scan()-function}",
    "text": "7.2 The scan() function {#sec-the-scan()-function}\nSuppose the data vectors are of equal length and are to be read in parallel. Further suppose that there are three vectors, the first of mode character and the remaining two of mode numeric, and the file is input.dat. The first step is to use scan() to read in the three vectors as a list, as follows\n> inp <- scan(\"input.dat\", list(\"\",0,0))\nThe second argument is a dummy list structure that establishes the mode of the three vectors to be read. The result, held in inp, is a list whose components are the three vectors read in. To separate the data items into three separate vectors, use assignments like\n> label <- inp[[1]]; x <- inp[[2]]; y <- inp[[3]]\nMore conveniently, the dummy list can have named components, in which case the names can be used to access the vectors read in. For example\n> inp <- scan(\"input.dat\", list(id=\"\", x=0, y=0))\nIf you wish to access the variables separately they may either be re-assigned to variables in the working frame:\n> label <- inp$id; x <- inp$x; y <- inp$y\nor the list may be attached at position 2 of the search path (see Attaching arbitrary lists).\nIf the second argument is a single value and not a list, a single vector is read in, all components of which must be of the same mode as the dummy value.\n> X <- matrix(scan(\"light.dat\", 0), ncol=5, byrow=TRUE)\nThere are more elaborate input facilities available and these are detailed in the manuals."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-accessing-builtin-datasets",
    "href": "tutorials/R/r-manuals/test.html#sec-accessing-builtin-datasets",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.3 Accessing builtin datasets",
    "text": "7.3 Accessing builtin datasets\nAround 100 datasets are supplied with R (in package datasets), and others are available in packages (including the recommended packages supplied with R). To see the list of datasets currently available use\ndata()\nAll the datasets supplied with R are available directly by name. However, many packages still use the obsolete convention in which data was also used to load datasets into R, for example\ndata(infert)\nand this can still be used with the standard packages (as in this example). In most cases this will load an R object of the same name. However, in a few cases it loads several objects, so see the on-line help for the object to see what to expect.\n\n7.3.1 7.3.1 Loading data from other R packages\nTo access data from a particular package, use the package argument, for example\ndata(package=\"rpart\")\ndata(Puromycin, package=\"datasets\")\nIf a package has been attached by library, its datasets are automatically included in the search.\nUser-contributed packages can be a rich source of datasets."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-editing-data",
    "href": "tutorials/R/r-manuals/test.html#sec-editing-data",
    "title": "R Manuals :: An Introduction to R",
    "section": "7.4 Editing data",
    "text": "7.4 Editing data\nWhen invoked on a data frame or matrix, edit brings up a separate spreadsheet-like environment for editing. This is useful for making small changes once a data set has been read. The command\n> xnew <- edit(xold)\nwill allow you to edit your data set xold, and on completion the changed object is assigned to xnew. If you want to alter the original dataset xold, the simplest way is to use fix(xold), which is equivalent to xold <- edit(xold).\nUse\n> xnew <- edit(data.frame())\nto enter new data via the spreadsheet interface."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-r-as-a-set-of-statistical-tables",
    "href": "tutorials/R/r-manuals/test.html#sec-r-as-a-set-of-statistical-tables",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.1 R as a set of statistical tables",
    "text": "8.1 R as a set of statistical tables\nOne convenient use of R is to provide a comprehensive set of statistical tables. Functions are provided to evaluate the cumulative distribution function P(X <= x), the probability density function and the quantile function (given q, the smallest x such that P(X <= x) > q), and to simulate from the distribution.\n\n\n\n\n\nDistribution\nR name\nadditional arguments\n\n\n\n\nbeta\nbeta\nshape1, shape2, ncp\n\n\nbinomial\nbinom\nsize, prob\n\n\nCauchy\ncauchy\nlocation, scale\n\n\nchi-squared\nchisq\ndf, ncp\n\n\nexponential\nexp\nrate\n\n\nF\nf\ndf1, df2, ncp\n\n\ngamma\ngamma\nshape, scale\n\n\ngeometric\ngeom\nprob\n\n\nhypergeometric\nhyper\nm, n, k\n\n\nlog-normal\nlnorm\nmeanlog, sdlog\n\n\nlogistic\nlogis\nlocation, scale\n\n\nnegative binomial\nnbinom\nsize, prob\n\n\nnormal\nnorm\nmean, sd\n\n\nPoisson\npois\nlambda\n\n\nsigned rank\nsignrank\nn\n\n\nStudent’s t\nt\ndf, ncp\n\n\nuniform\nunif\nmin, max\n\n\nWeibull\nweibull\nshape, scale\n\n\nWilcoxon\nwilcox\nm, n\n\n\n\n\n\nPrefix the name given here by ‘d’ for the density, ‘p’ for the CDF, ‘q’ for the quantile function and ‘r’ for simulation (random deviates). The first argument is x for d``xxx, q for p``xxx, p for q``xxx and n for r``xxx (except for rhyper, rsignrank and rwilcox, for which it is nn). In not quite all cases is the non-centrality parameter ncp currently available: see the on-line help for details.\nThe p``xxx and q``xxx functions all have logical arguments lower.tail and log.p and the d``xxx ones have log. This allows, e.g., getting the cumulative (or “integrated”) hazard function, H(t) = - log(1 - F(t)), by\n - pxxx(t, ..., lower.tail = FALSE, log.p = TRUE)\nor more accurate log-likelihoods (by d``xxx(..., log = TRUE)), directly.\nIn addition there are functions ptukey and qtukey for the distribution of the studentized range of samples from a normal distribution, and dmultinom and rmultinom for the multinomial distribution. Further distributions are available in contributed packages, notably SuppDists.\nHere are some examples\n> ## 2-tailed p-value for t distribution\n> 2*pt(-2.43, df = 13)\n> ## upper 1% point for an F(2, 7) distribution\n> qf(0.01, 2, 7, lower.tail = FALSE)\nSee the on-line help on RNG for how random-number generation is done in R."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-examining-the-distribution-of-a-set-of-data",
    "href": "tutorials/R/r-manuals/test.html#sec-examining-the-distribution-of-a-set-of-data",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.2 Examining the distribution of a set of data",
    "text": "8.2 Examining the distribution of a set of data\nGiven a (univariate) set of data we can examine its distribution in a large number of ways. The simplest is to examine the numbers. Two slightly different summaries are given by summary and fivenum and a display of the numbers by stem (a “stem and leaf” plot).\n> attach(faithful)\n> summary(eruptions)\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n  1.600   2.163   4.000   3.488   4.454   5.100\n> fivenum(eruptions)\n[1] 1.6000 2.1585 4.0000 4.4585 5.1000\n> stem(eruptions)\n\n  The decimal point is 1 digit(s) to the left of the |\n\n  16 | 070355555588\n  18 | 000022233333335577777777888822335777888\n  20 | 00002223378800035778\n  22 | 0002335578023578\n  24 | 00228\n  26 | 23\n  28 | 080\n  30 | 7\n  32 | 2337\n  34 | 250077\n  36 | 0000823577\n  38 | 2333335582225577\n  40 | 0000003357788888002233555577778\n  42 | 03335555778800233333555577778\n  44 | 02222335557780000000023333357778888\n  46 | 0000233357700000023578\n  48 | 00000022335800333\n  50 | 0370\nA stem-and-leaf plot is like a histogram, and R has a function hist to plot histograms.\n> hist(eruptions)\n## make the bins smaller, make a plot of density\n> hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)\n> lines(density(eruptions, bw=0.1))\n> rug(eruptions) # show the actual data points\nMore elegant density plots can be made by density, and we added a line produced by density in this example. The bandwidth bw was chosen by trial-and-error as the default gives too much smoothing (it usually does for “interesting” densities). (Better automated methods of bandwidth choice are available, and in this example bw = \"SJ\" gives a good result.)\n\n\n\nimages/hist\n\n\nWe can plot the empirical cumulative distribution function by using the function ecdf.\n> plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)\nThis distribution is obviously far from any standard distribution. How about the right-hand mode, say eruptions of longer than 3 minutes? Let us fit a normal distribution and overlay the fitted CDF.\n> long <- eruptions[eruptions > 3]\n> plot(ecdf(long), do.points=FALSE, verticals=TRUE)\n> x <- seq(3, 5.4, 0.01)\n> lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)\n\n\n\nimages/ecdf\n\n\nQuantile-quantile (Q-Q) plots can help us examine this more carefully.\npar(pty=\"s\")       # arrange for a square figure region\nqqnorm(long); qqline(long)\nwhich shows a reasonable fit but a shorter right tail than one would expect from a normal distribution. Let us compare this with some simulated data from a t distribution\n\n\n\nimages/QQ\n\n\nx <- rt(250, df = 5)\nqqnorm(x); qqline(x)\nwhich will usually (if it is a random sample) show longer tails than expected for a normal. We can make a Q-Q plot against the generating distribution by\nqqplot(qt(ppoints(250), df = 5), x, xlab = \"Q-Q plot for t dsn\")\nqqline(x)\nFinally, we might want a more formal test of agreement with normality (or not). R provides the Shapiro-Wilk test\n> shapiro.test(long)\n\n         Shapiro-Wilk normality test\n\ndata:  long\nW = 0.9793, p-value = 0.01052\nand the Kolmogorov-Smirnov test\n> ks.test(long, \"pnorm\", mean = mean(long), sd = sqrt(var(long)))\n\n         One-sample Kolmogorov-Smirnov test\n\ndata:  long\nD = 0.0661, p-value = 0.4284\nalternative hypothesis: two.sided\n(Note that the distribution theory is not valid here as we have estimated the parameters of the normal distribution from the same sample.)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-one--and-two-sample-tests",
    "href": "tutorials/R/r-manuals/test.html#sec-one--and-two-sample-tests",
    "title": "R Manuals :: An Introduction to R",
    "section": "8.3 One- and two-sample tests",
    "text": "8.3 One- and two-sample tests\nSo far we have compared a single sample to a normal distribution. A much more common operation is to compare aspects of two samples. Note that in R, all “classical” tests including the ones used below are in package stats which is normally loaded.\nConsider the following sets of data on the latent heat of the fusion of ice (cal/gm) from Rice (1995, p.490)\nMethod A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97\n          80.05 80.03 80.02 80.00 80.02\nMethod B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97\nBoxplots provide a simple graphical comparison of the two samples.\nA <- scan()\n79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97\n80.05 80.03 80.02 80.00 80.02\n\nB <- scan()\n80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97\n\nboxplot(A, B)\nwhich indicates that the first group tends to give higher results than the second.\n\n\n\nimages/ice\n\n\nTo test for the equality of the means of the two examples, we can use an unpaired t-test by\n> t.test(A, B)\n\n         Welch Two Sample t-test\n\ndata:  A and B\nt = 3.2499, df = 12.027, p-value = 0.00694\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.01385526 0.07018320\nsample estimates:\nmean of x mean of y\n 80.02077  79.97875\nwhich does indicate a significant difference, assuming normality. By default the R function does not assume equality of variances in the two samples. We can use the F test to test for equality in the variances, provided that the two samples are from normal populations.\n> var.test(A, B)\n\n         F test to compare two variances\n\ndata:  A and B\nF = 0.5837, num df = 12, denom df =  7, p-value = 0.3938\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.1251097 2.1052687\nsample estimates:\nratio of variances\n         0.5837405\nwhich shows no evidence of a significant difference, and so we can use the classical t-test that assumes equality of the variances.\n> t.test(A, B, var.equal=TRUE)\n\n         Two Sample t-test\n\ndata:  A and B\nt = 3.4722, df = 19, p-value = 0.002551\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 0.01669058 0.06734788\nsample estimates:\nmean of x mean of y\n 80.02077  79.97875\nAll these tests assume normality of the two samples. The two-sample Wilcoxon (or Mann-Whitney) test only assumes a common continuous distribution under the null hypothesis.\n> wilcox.test(A, B)\n\n         Wilcoxon rank sum test with continuity correction\n\ndata:  A and B\nW = 89, p-value = 0.007497\nalternative hypothesis: true location shift is not equal to 0\n\nWarning message:\nCannot compute exact p-value with ties in: wilcox.test(A, B)\nNote the warning: there are several ties in each sample, which suggests strongly that these data are from a discrete distribution (probably due to rounding).\nThere are several ways to compare graphically the two samples. We have already seen a pair of boxplots. The following\n> plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))\n> plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)\nwill show the two empirical CDFs, and qqplot will perform a Q-Q plot of the two samples. The Kolmogorov-Smirnov test is of the maximal vertical distance between the two ecdf’s, assuming a common continuous distribution:\n> ks.test(A, B)\n\n         Two-sample Kolmogorov-Smirnov test\n\ndata:  A and B\nD = 0.5962, p-value = 0.05919\nalternative hypothesis: two-sided\n\nWarning message:\ncannot compute correct p-values with ties in: ks.test(A, B)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-grouped-expressions",
    "href": "tutorials/R/r-manuals/test.html#sec-grouped-expressions",
    "title": "R Manuals :: An Introduction to R",
    "section": "9.1 Grouped expressions",
    "text": "9.1 Grouped expressions\nR is an expression language in the sense that its only command type is a function or expression which returns a result. Even an assignment is an expression whose result is the value assigned, and it may be used wherever any expression may be used; in particular multiple assignments are possible.\nCommands may be grouped together in braces, {``expr_1; ``…; ``expr_m}, in which case the value of the group is the result of the last expression in the group evaluated. Since such a group is also an expression it may, for example, be itself included in parentheses and used as part of an even larger expression, and so on."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-control-statements",
    "href": "tutorials/R/r-manuals/test.html#sec-control-statements",
    "title": "R Manuals :: An Introduction to R",
    "section": "9.2 Control statements",
    "text": "9.2 Control statements\n\n9.2.1 Conditional execution: if statements {#sec-conditional-execution:-if-statements}\nThe language has available a conditional construction of the form\n> if (expr_1) expr_2 else expr_3\nwhere expr_1 must evaluate to a single logical value and the result of the entire expression is then evident.\nThe “short-circuit” operators && and || are often used as part of the condition in an if statement. Whereas & and | apply element-wise to vectors, && and || apply to vectors of length one, and only evaluate their second argument if necessary.\nThere is a vectorized version of the if/else construct, the ifelse function. This has the form ifelse(condition, a, b) and returns a vector of the same length as condition, with elements a[i] if condition[i] is true, otherwise b[i] (where a and b are recycled as necessary).\n\n\n9.2.2 Repetitive execution: for loops, repeat and while {#sec-repetitive-execution:-for-loops-repeat-and-while}\nThere is also a for loop construction which has the form\n> for (name in expr_1) expr_2\nwhere name is the loop variable. expr_1 is a vector expression, (often a sequence like 1:20), and expr_2 is often a grouped expression with its sub-expressions written in terms of the dummy name. expr_2 is repeatedly evaluated as name ranges through the values in the vector result of expr_1.\nAs an example, suppose ind is a vector of class indicators and we wish to produce separate plots of y versus x within classes. One possibility here is to use coplot(),20 which will produce an array of plots corresponding to each level of the factor. Another way to do this, now putting all plots on the one display, is as follows:\n> xc <- split(x, ind)\n> yc <- split(y, ind)\n> for (i in 1:length(yc)) {\n    plot(xc[[i]], yc[[i]])\n    abline(lsfit(xc[[i]], yc[[i]]))\n  }\n(Note the function split() which produces a list of vectors obtained by splitting a larger vector according to the classes specified by a factor. This is a useful function, mostly used in connection with boxplots. See the help facility for further details.)\n\nWarning: for() loops are used in R code much less often than in compiled languages. Code that takes a ‘whole object’ view is likely to be both clearer and faster in R.\n\nOther looping facilities include the\n> repeat expr\nstatement and the\n> while (condition) expr\nstatement.\nThe break statement can be used to terminate any loop, possibly abnormally. This is the only way to terminate repeat loops.\nThe next statement can be used to discontinue one particular cycle and skip to the “next”.\nControl statements are most often used in connection with functions which are discussed in Section 10 , and where more examples will emerge."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-simple-examples",
    "href": "tutorials/R/r-manuals/test.html#sec-simple-examples",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.1 Simple examples",
    "text": "10.1 Simple examples\nAs a first example, consider a function to calculate the two sample t-statistic, showing “all the steps”. This is an artificial example, of course, since there are other, simpler ways of achieving the same end.\nThe function is defined as follows:\n> twosam <- function(y1, y2) {\n    n1  <- length(y1); n2  <- length(y2)\n    yb1 <- mean(y1);   yb2 <- mean(y2)\n    s1  <- var(y1);    s2  <- var(y2)\n    s <- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)\n    tst <- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))\n    tst\n  }\nWith this function defined, you could perform two sample t-tests using a call such as\n> tstat <- twosam(data$male, data$female); tstat\nAs a second example, consider a function to emulate directly the MATLAB backslash command, which returns the coefficients of the orthogonal projection of the vector y onto the column space of the matrix, X. (This is ordinarily called the least squares estimate of the regression coefficients.) This would ordinarily be done with the qr() function; however this is sometimes a bit tricky to use directly and it pays to have a simple function such as the following to use it safely.\nThus given a n by 1 vector y and an n by p matrix X then X \\ y is defined as (X’X)^{-}X’y, where (X’X)^{-} is a generalized inverse of X'X.\n> bslash <- function(X, y) {\n  X <- qr(X)\n  qr.coef(X, y)\n}\nAfter this object is created it may be used in statements such as\n> regcoeff <- bslash(Xmat, yvar)\nand so on.\nThe classical R function lsfit() does this job quite well, and more21. It in turn uses the functions qr() and qr.coef() in the slightly counterintuitive way above to do this part of the calculation. Hence there is probably some value in having just this part isolated in a simple to use function if it is going to be in frequent use. If so, we may wish to make it a matrix binary operator for even more convenient use."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-defining-new-binary-operators",
    "href": "tutorials/R/r-manuals/test.html#sec-defining-new-binary-operators",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.2 Defining new binary operators",
    "text": "10.2 Defining new binary operators\nHad we given the bslash() function a different name, namely one of the form\n%anything%\nit could have been used as a binary operator in expressions rather than in function form. Suppose, for example, we choose ! for the internal character. The function definition would then start as\n> \"%!%\" <- function(X, y) { … }\n(Note the use of quote marks.) The function could then be used as X %!% y. (The backslash symbol itself is not a convenient choice as it presents special problems in this context.)\nThe matrix multiplication operator, %*%, and the outer product matrix operator %o% are other examples of binary operators defined in this way."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-named-arguments-and-defaults",
    "href": "tutorials/R/r-manuals/test.html#sec-named-arguments-and-defaults",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.3 Named arguments and defaults",
    "text": "10.3 Named arguments and defaults\nAs first noted in Generating regular sequences, if arguments to called functions are given in the “name=``object” form, they may be given in any order. Furthermore the argument sequence may begin in the unnamed, positional form, and specify named arguments after the positional arguments.\nThus if there is a function fun1 defined by\n> fun1 <- function(data, data.frame, graph, limit) {\n    [function body omitted]\n  }\nthen the function may be invoked in several ways, for example\n> ans <- fun1(d, df, TRUE, 20)\n> ans <- fun1(d, df, graph=TRUE, limit=20)\n> ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)\nare all equivalent.\nIn many cases arguments can be given commonly appropriate default values, in which case they may be omitted altogether from the call when the defaults are appropriate. For example, if fun1 were defined as\n> fun1 <- function(data, data.frame, graph=TRUE, limit=20) { … }\nit could be called as\n> ans <- fun1(d, df)\nwhich is now equivalent to the three cases above, or as\n> ans <- fun1(d, df, limit=10)\nwhich changes one of the defaults.\nIt is important to note that defaults may be arbitrary expressions, even involving other arguments to the same function; they are not restricted to be constants as in our simple example here."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#the-sec-the--argument",
    "href": "tutorials/R/r-manuals/test.html#the-sec-the--argument",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.4 The ‘…{#sec-the-’…’-argument}",
    "text": "10.4 The ‘…{#sec-the-’…’-argument}\nAnother frequent requirement is to allow one function to pass on argument settings to another. For example many graphics functions use the function par() and functions like plot() allow the user to pass on graphical parameters to par() to control the graphical output. (See The par() function, for more details on the par() function.) This can be done by including an extra argument, literally ‘…’, of the function, which may then be passed on. An outline example is given below.\nfun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {\n  [omitted statements]\n  if (graph)\n    par(pch=\"*\", ...)\n  [more omissions]\n}\nLess frequently, a function will need to refer to components of ‘…’. The expression list(...) evaluates all such arguments and returns them in a named list, while ..1, ..2, etc. evaluate them one at a time, with ‘..n’ returning the n’th unmatched argument."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-assignments-within-functions",
    "href": "tutorials/R/r-manuals/test.html#sec-assignments-within-functions",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.5 Assignments within functions",
    "text": "10.5 Assignments within functions\nNote that any ordinary assignments done within the function are local and temporary and are lost after exit from the function. Thus the assignment X <- qr(X) does not affect the value of the argument in the calling program.\nTo understand completely the rules governing the scope of R assignments the reader needs to be familiar with the notion of an evaluation frame. This is a somewhat advanced, though hardly difficult, topic and is not covered further here.\nIf global and permanent assignments are intended within a function, then either the “superassignment” operator, <<- or the function assign() can be used. See the help document for details."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-more-advanced-examples",
    "href": "tutorials/R/r-manuals/test.html#sec-more-advanced-examples",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.6 More advanced examples",
    "text": "10.6 More advanced examples\n\n10.6.1 Efficiency factors in block designs\nAs a more complete, if a little pedestrian, example of a function, consider finding the efficiency factors for a block design. (Some aspects of this problem have already been discussed in Index matrices.)\nA block design is defined by two factors, say blocks (b levels) and varieties (v levels). If R and K are the v by v and b by b replications and block size matrices, respectively, and N is the b by v incidence matrix, then the efficiency factors are defined as the eigenvalues of the matrix E = I_v - R^{-1/2}N’K^{-1}NR^{-1/2} = I_v - A’A, where A = K^{-1/2}NR^{-1/2}. One way to write the function is given below.\n> bdeff <- function(blocks, varieties) {\n    blocks <- as.factor(blocks)             # minor safety move\n    b <- length(levels(blocks))\n    varieties <- as.factor(varieties)       # minor safety move\n    v <- length(levels(varieties))\n    K <- as.vector(table(blocks))           # remove dim attr\n    R <- as.vector(table(varieties))        # remove dim attr\n    N <- table(blocks, varieties)\n    A <- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))\n    sv <- svd(A)\n    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)\n}\nIt is numerically slightly better to work with the singular value decomposition on this occasion rather than the eigenvalue routines.\nThe result of the function is a list giving not only the efficiency factors as the first component, but also the block and variety canonical contrasts, since sometimes these give additional useful qualitative information.\n\n\n10.6.2 Dropping all names in a printed array\nFor printing purposes with large matrices or arrays, it is often useful to print them in close block form without the array names or numbers. Removing the dimnames attribute will not achieve this effect, but rather the array must be given a dimnames attribute consisting of empty strings. For example to print a matrix, X\n> temp <- X\n> dimnames(temp) <- list(rep(\"\", nrow(X)), rep(\"\", ncol(X)))\n> temp; rm(temp)\nThis can be much more conveniently done using a function, no.dimnames(), shown below, as a “wrap around” to achieve the same result. It also illustrates how some effective and useful user functions can be quite short.\nno.dimnames <- function(a) {\n  ## Remove all dimension names from an array for compact printing.\n  d <- list()\n  l <- 0\n  for(i in dim(a)) {\n    d[[l <- l + 1]] <- rep(\"\", i)\n  }\n  dimnames(a) <- d\n  a\n}\nWith this function defined, an array may be printed in close format using\n> no.dimnames(X)\nThis is particularly useful for large integer arrays, where patterns are the real interest rather than the values.\n\n\n10.6.3 Recursive numerical integration\nFunctions may be recursive, and may themselves define functions within themselves. Note, however, that such functions, or indeed variables, are not inherited by called functions in higher evaluation frames as they would be if they were on the search path.\nThe example below shows a naive way of performing one-dimensional numerical integration. The integrand is evaluated at the end points of the range and in the middle. If the one-panel trapezium rule answer is close enough to the two panel, then the latter is returned as the value. Otherwise the same process is recursively applied to each panel. The result is an adaptive integration process that concentrates function evaluations in regions where the integrand is farthest from linear. There is, however, a heavy overhead, and the function is only competitive with other algorithms when the integrand is both smooth and very difficult to evaluate.\nThe example is also given partly as a little puzzle in R programming.\narea <- function(f, a, b, eps = 1.0e-06, lim = 10) {\n  fun1 <- function(f, a, b, fa, fb, a0, eps, lim, fun) {\n    ## function ‘fun1’ is only visible inside ‘area’\n    d <- (a + b)/2\n    h <- (b - a)/4\n    fd <- f(d)\n    a1 <- h * (fa + fd)\n    a2 <- h * (fd + fb)\n    if(abs(a0 - a1 - a2) < eps || lim == 0)\n      return(a1 + a2)\n    else {\n      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +\n             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))\n    }\n  }\n  fa <- f(a)\n  fb <- f(b)\n  a0 <- ((fa + fb) * (b - a))/2\n  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)\n}"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-scope",
    "href": "tutorials/R/r-manuals/test.html#sec-scope",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.7 Scope",
    "text": "10.7 Scope\nThe discussion in this section is somewhat more technical than in other parts of this document. However, it details one of the major differences between S-PLUS and R.\nThe symbols which occur in the body of a function can be divided into three classes; formal parameters, local variables and free variables. The formal parameters of a function are those occurring in the argument list of the function. Their values are determined by the process of binding the actual function arguments to the formal parameters. Local variables are those whose values are determined by the evaluation of expressions in the body of the functions. Variables which are not formal parameters or local variables are called free variables. Free variables become local variables if they are assigned to. Consider the following function definition.\nf <- function(x) {\n  y <- 2*x\n  print(x)\n  print(y)\n  print(z)\n}\nIn this function, x is a formal parameter, y is a local variable and z is a free variable.\nIn R the free variable bindings are resolved by first looking in the environment in which the function was created. This is called lexical scope. First we define a function called cube.\ncube <- function(n) {\n  sq <- function() n*n\n  n*sq()\n}\nThe variable n in the function sq is not an argument to that function. Therefore it is a free variable and the scoping rules must be used to ascertain the value that is to be associated with it. Under static scope (S-PLUS) the value is that associated with a global variable named n. Under lexical scope (R) it is the parameter to the function cube since that is the active binding for the variable n at the time the function sq was defined. The difference between evaluation in R and evaluation in S-PLUS is that S-PLUS looks for a global variable called n while R first looks for a variable called n in the environment created when cube was invoked.\n## first evaluation in S\nS> cube(2)\nError in sq(): Object \"n\" not found\nDumped\nS> n <- 3\nS> cube(2)\n[1] 18\n## then the same function evaluated in R\nR> cube(2)\n[1] 8\nLexical scope can also be used to give functions mutable state. In the following example we show how R can be used to mimic a bank account. A functioning bank account needs to have a balance or total, a function for making withdrawals, a function for making deposits and a function for stating the current balance. We achieve this by creating the three functions within account and then returning a list containing them. When account is invoked it takes a numerical argument total and returns a list containing the three functions. Because these functions are defined in an environment which contains total, they will have access to its value.\nThe special assignment operator, <<-, is used to change the value associated with total. This operator looks back in enclosing environments for an environment that contains the symbol total and when it finds such an environment it replaces the value, in that environment, with the value of right hand side. If the global or top-level environment is reached without finding the symbol total then that variable is created and assigned to there. For most users <<- creates a global variable and assigns the value of the right hand side to it22. Only when <<- has been used in a function that was returned as the value of another function will the special behavior described here occur.\nopen.account <- function(total) {\n  list(\n    deposit = function(amount) {\n      if(amount <= 0)\n        stop(\"Deposits must be positive!\\n\")\n      total <<- total + amount\n      cat(amount, \"deposited.  Your balance is\", total, \"\\n\\n\")\n    },\n    withdraw = function(amount) {\n      if(amount > total)\n        stop(\"You don't have that much money!\\n\")\n      total <<- total - amount\n      cat(amount, \"withdrawn.  Your balance is\", total, \"\\n\\n\")\n    },\n    balance = function() {\n      cat(\"Your balance is\", total, \"\\n\\n\")\n    }\n  )\n}\n\nross <- open.account(100)\nrobert <- open.account(200)\n\nross$withdraw(30)\nross$balance()\nrobert$balance()\n\nross$deposit(50)\nross$balance()\nross$withdraw(500)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-customizing-the-environment",
    "href": "tutorials/R/r-manuals/test.html#sec-customizing-the-environment",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.8 Customizing the environment",
    "text": "10.8 Customizing the environment\nUsers can customize their environment in several different ways. There is a site initialization file and every directory can have its own special initialization file. Finally, the special functions .First and .Last can be used.\nThe location of the site initialization file is taken from the value of the R_PROFILE environment variable. If that variable is unset, the file Rprofile.site in the R home subdirectory etc is used. This file should contain the commands that you want to execute every time R is started under your system. A second, personal, profile file named .Rprofile23 can be placed in any directory. If R is invoked in that directory then that file will be sourced. This file gives individual users control over their workspace and allows for different startup procedures in different working directories. If no .Rprofile file is found in the startup directory, then R looks for a .Rprofile file in the user’s home directory and uses that (if it exists). If the environment variable R_PROFILE_USER is set, the file it points to is used instead of the .Rprofile files.\nAny function named .First() in either of the two profile files or in the .RData image has a special status. It is automatically performed at the beginning of an R session and may be used to initialize the environment. For example, the definition in the example below alters the prompt to $ and sets up various other useful things that can then be taken for granted in the rest of the session.\nThus, the sequence in which files are executed is, Rprofile.site, the user profile, .RData and then .First(). A definition in later files will mask definitions in earlier files.\n> .First <- function() {\n  options(prompt=\"$ \", continue=\"+\\t\")  # $ is the prompt\n  options(digits=5, length=999)         # custom numbers and printout\n  x11()                                 # for graphics\n  par(pch = \"+\")                        # plotting character\n  source(file.path(Sys.getenv(\"HOME\"), \"R\", \"mystuff.R\"))\n                                        # my personal functions\n  library(MASS)                         # attach a package\n}\nSimilarly a function .Last(), if defined, is (normally) executed at the very end of the session. An example is given below.\n> .Last <- function() {\n  graphics.off()                        # a small safety measure.\n  cat(paste(date(),\"\\nAdios\\n\"))        # Is it time for lunch?\n}"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-classes-generic-functions-and-object-orientation",
    "href": "tutorials/R/r-manuals/test.html#sec-classes-generic-functions-and-object-orientation",
    "title": "R Manuals :: An Introduction to R",
    "section": "10.9 Classes, generic functions and object orientation",
    "text": "10.9 Classes, generic functions and object orientation\nThe class of an object determines how it will be treated by what are known as generic functions. Put the other way round, a generic function performs a task or action on its arguments specific to the class of the argument itself. If the argument lacks any class attribute, or has a class not catered for specifically by the generic function in question, there is always a default action provided.\nAn example makes things clearer. The class mechanism offers the user the facility of designing and writing generic functions for special purposes. Among the other generic functions are plot() for displaying objects graphically, summary() for summarizing analyses of various types, and anova() for comparing statistical models.\nThe number of generic functions that can treat a class in a specific way can be quite large. For example, the functions that can accommodate in some fashion objects of class \"data.frame\" include\n[     [[<-    any    as.matrix\n[<-   mean    plot   summary\nA currently complete list can be got by using the methods() function:\n> methods(class=\"data.frame\")\nConversely the number of classes a generic function can handle can also be quite large. For example the plot() function has a default method and variants for objects of classes \"data.frame\", \"density\", \"factor\", and more. A complete list can be got again by using the methods() function:\n> methods(plot)\nFor many generic functions the function body is quite short, for example\n> coef\nfunction (object, ...)\nUseMethod(\"coef\")\nThe presence of UseMethod indicates this is a generic function. To see what methods are available we can use methods()\n> methods(coef)\n[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*\n[5] coef.nls*         coef.summary.nls*\n\n   Non-visible functions are asterisked\nIn this example there are six methods, none of which can be seen by typing its name. We can read these by either of\n> getAnywhere(\"coef.aov\")\nA single object matching 'coef.aov' was found\nIt was found in the following places\n  registered S3 method for coef from namespace stats\n  namespace:stats\nwith value\n\nfunction (object, ...)\n{\n    z <- object$coef\n    z[!is.na(z)]\n}\n\n> getS3method(\"coef\", \"aov\")\nfunction (object, ...)\n{\n    z <- object$coef\n    z[!is.na(z)]\n}\nA function named gen.``cl will be invoked by the generic gen for class cl, so do not name functions in this style unless they are intended to be methods.\nThe reader is referred to the R Language Definition for a more complete discussion of this mechanism."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-defining-statistical-models-formulae",
    "href": "tutorials/R/r-manuals/test.html#sec-defining-statistical-models-formulae",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.1 Defining statistical models; formulae",
    "text": "11.1 Defining statistical models; formulae\nThe template for a statistical model is a linear regression model with independent, homoscedastic errors\n\ny_i = sum_{j=0}^p beta_j x_{ij} + e_i,     i = 1, …, n,\n\nwhere the e_i are NID(0, sigma^2). In matrix terms this would be written\n\ny = X  beta + e\n\nwhere the y is the response vector, X is the model matrix or design matrix and has columns x_0, x_1, …, x_p, the determining variables. Very often x_0 will be a column of ones defining an intercept term.\n\n11.1.1 Examples\nBefore giving a formal specification, a few examples may usefully set the picture.\nSuppose y, x, x0, x1, x2, … are numeric variables, X is a matrix and A, B, C, … are factors. The following formulae on the left side below specify statistical models as described on the right.\ny ~ x\ny ~ 1 + x\n: Both imply the same simple linear regression model of y on x. The first has an implicit intercept term, and the second an explicit one.\ny ~ 0 + x\ny ~ -1 + x\ny ~ x - 1\n: Simple linear regression of y on x through the origin (that is, without an intercept term).\n\nlog(y) ~ x1 + x2\n\nMultiple regression of the transformed variable, log(y), on x1 and x2 (with an implicit intercept term).\n\n\ny ~ poly(x,2)\ny ~ 1 + x + I(x^2)\n: Polynomial regression of y on x of degree 2. The first form uses orthogonal polynomials, and the second uses explicit powers, as basis.\n\ny ~ X + poly(x,2)\n\nMultiple regression y with model matrix consisting of the matrix X as well as polynomial terms in x to degree 2.\n\ny ~ A\n\nSingle classification analysis of variance model of y, with classes determined by A.\n\ny ~ A + x\n\nSingle classification analysis of covariance model of y, with classes determined by A, and with covariate x.\n\n\ny ~ A*B\ny ~ A + B + A:B\ny ~ B %in% A\ny ~ A/B\n: Two factor non-additive model of y on A and B. The first two specify the same crossed classification and the second two specify the same nested classification. In abstract terms all four specify the same model subspace.\ny ~ (A + B + C)^2\ny ~ A*B*C - A:B:C\n: Three factor experiment but with a model containing main effects and two factor interactions only. Both formulae specify the same model.\ny ~ A * x\ny ~ A/x\ny ~ A/(1 + x) - 1\n: Separate simple linear regression models of y on x within the levels of A, with different codings. The last form produces explicit estimates of as many different intercepts and slopes as there are levels in A.\n\ny ~ A*B + Error(C)\n\nAn experiment with two treatment factors, A and B, and error strata determined by factor C. For example a split plot experiment, with whole plots (and hence also subplots), determined by factor C.\n\n\nThe operator ~ is used to define a model formula in R. The form, for an ordinary linear model, is\nresponse ~ op_1 term_1 op_2 term_2 op_3 term_3 …\nwhere\n\nresponse\n\nis a vector or matrix, (or expression evaluating to a vector or matrix) defining the response variable(s).\n\nop_i\n\nis an operator, either + or -, implying the inclusion or exclusion of a term in the model, (the first is optional).\n\nterm_i\n\nis either\n\na vector or matrix expression, or 1,\na factor, or\na formula expression consisting of factors, vectors or matrices connected by formula operators.\n\nIn all cases each term defines a collection of columns either to be added to or removed from the model matrix. A 1 stands for an intercept column and is by default included in the model matrix unless explicitly removed.\n\n\nThe formula operators are similar in effect to the Wilkinson and Rogers notation used by such programs as Glim and Genstat. One inevitable change is that the operator .’ becomes ’: since the period is a valid name character in R.\nThe notation is summarized below (based on Chambers & Hastie, 1992, p.29):\n\nY~ ``M\n\nY is modeled as M.\n\nM_1+ ``M_2\n\nInclude M_1 and M_2.\n\nM_1- ``M_2\n\nInclude M_1 leaving out terms of M_2.\n\nM_1: ``M_2\n\nThe tensor product of M_1 and M_2. If both terms are factors, then the “subclasses” factor.\n\nM_1%in% ``M_2\n\nSimilar to M_1:``M_2, but with a different coding.\n\nM_1* ``M_2\n\nM_1+ ``M_2+ ``M_1:``M_2.\n\nM_1/ ``M_2\n\nM_1+ ``M_2%in% ``M_1.\n\nM^``n\n\nAll terms in M together with “interactions” up to order n\n\nI(``M)\n\nInsulate M. Inside M all operators have their normal arithmetic meaning, and that term appears in the model matrix.\n\n\nNote that inside the parentheses that usually enclose function arguments all operators have their normal arithmetic meaning. The function I() is an identity function used to allow terms in model formulae to be defined using arithmetic operators.\nNote particularly that the model formulae specify the columns of the model matrix, the specification of the parameters being implicit. This is not the case in other contexts, for example in specifying nonlinear models.\n\n\n11.1.2 Contrasts\nWe need at least some idea how the model formulae specify the columns of the model matrix. This is easy if we have continuous variables, as each provides one column of the model matrix (and the intercept will provide a column of ones if included in the model).\nWhat about a k-level factor A? The answer differs for unordered and ordered factors. For unordered factors k - 1 columns are generated for the indicators of the second, …, kth levels of the factor. (Thus the implicit parameterization is to contrast the response at each level with that at the first.) For ordered factors the k - 1 columns are the orthogonal polynomials on 1, …, k, omitting the constant term.\nAlthough the answer is already complicated, it is not the whole story. First, if the intercept is omitted in a model that contains a factor term, the first such term is encoded into k columns giving the indicators for all the levels. Second, the whole behavior can be changed by the options setting for contrasts. The default setting in R is\noptions(contrasts = c(\"contr.treatment\", \"contr.poly\"))\nThe main reason for mentioning this is that R and S have different defaults for unordered factors, S using Helmert contrasts. So if you need to compare your results to those of a textbook or paper which used S-PLUS, you will need to set\noptions(contrasts = c(\"contr.helmert\", \"contr.poly\"))\nThis is a deliberate difference, as treatment contrasts (R’s default) are thought easier for newcomers to interpret.\nWe have still not finished, as the contrast scheme to be used can be set for each term in the model using the functions contrasts and C.\nWe have not yet considered interaction terms: these generate the products of the columns introduced for their component terms.\nAlthough the details are complicated, model formulae in R will normally generate the models that an expert statistician would expect, provided that marginality is preserved. Fitting, for example, a model with an interaction but not the corresponding main effects will in general lead to surprising results, and is for experts only."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-linear-models",
    "href": "tutorials/R/r-manuals/test.html#sec-linear-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.2 Linear models",
    "text": "11.2 Linear models\nThe basic function for fitting ordinary multiple models is lm(), and a streamlined version of the call is as follows:\n> fitted.model <- lm(formula, data = data.frame)\nFor example\n> fm2 <- lm(y ~ x1 + x2, data = production)\nwould fit a multiple regression model of y on x1 and x2 (with implicit intercept term).\nThe important (but technically optional) parameter data = production specifies that any variables needed to construct the model should come first from the production data frame. This is the case regardless of whether data frame production has been attached on the search path or not."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-generic-functions-for-extracting-model-information",
    "href": "tutorials/R/r-manuals/test.html#sec-generic-functions-for-extracting-model-information",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.3 Generic functions for extracting model information",
    "text": "11.3 Generic functions for extracting model information\nThe value of lm() is a fitted model object; technically a list of results of class \"lm\". Information about the fitted model can then be displayed, extracted, plotted and so on by using generic functions that orient themselves to objects of class \"lm\". These include\nadd1    deviance   formula      predict  step\nalias   drop1      kappa        print    summary\nanova   effects    labels       proj     vcov\ncoef    family     plot         residuals\nA brief description of the most commonly used ones is given below.\n\nanova(``object_1, ``object_2)\nCompare a submodel with an outer model and produce an analysis of variance table.\ncoef(``object)\nExtract the regression coefficient (matrix).\nLong form: coefficients(``object).\ndeviance(``object)\nResidual sum of squares, weighted if appropriate.\nformula(``object)\nExtract the model formula.\nplot(``object)\nProduce four plots, showing residuals, fitted values and some diagnostics.\npredict(``object, newdata=``data.frame)\nThe data frame supplied must have variables specified with the same labels as the original. The value is a vector or matrix of predicted values corresponding to the determining variable values in data.frame.\nprint(``object)\nPrint a concise version of the object. Most often used implicitly.\nresiduals(``object)\nExtract the (matrix of) residuals, weighted as appropriate.\nShort form: resid(``object).\nstep(``object)\nSelect a suitable model by adding or dropping terms and preserving hierarchies. The model with the smallest value of AIC (Akaike’s An Information Criterion) discovered in the stepwise search is returned.\nsummary(``object)\nPrint a comprehensive summary of the results of the regression analysis.\nvcov(``object)\nReturns the variance-covariance matrix of the main parameters of a fitted model object."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-analysis-of-variance-and-model-comparison",
    "href": "tutorials/R/r-manuals/test.html#sec-analysis-of-variance-and-model-comparison",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.4 Analysis of variance and model comparison",
    "text": "11.4 Analysis of variance and model comparison\nThe model fitting function aov(``formula, data=``data.frame) operates at the simplest level in a very similar way to the function lm(), and most of the generic functions listed in the table in Generic functions for extracting model information apply.\nIt should be noted that in addition aov() allows an analysis of models with multiple error strata such as split plot experiments, or balanced incomplete block designs with recovery of inter-block information. The model formula\nresponse ~ mean.formula + Error(strata.formula)\nspecifies a multi-stratum experiment with error strata defined by the strata.formula. In the simplest case, strata.formula is simply a factor, when it defines a two strata experiment, namely between and within the levels of the factor.\nFor example, with all determining variables factors, a model formula such as that in:\n> fm <- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)\nwould typically be used to describe an experiment with mean model v + n*p*k and three error strata, namely “between farms”, “within farms, between blocks” and “within blocks”.\n\n11.4.1 ANOVA tables\nNote also that the analysis of variance table (or tables) are for a sequence of fitted models. The sums of squares shown are the decrease in the residual sums of squares resulting from an inclusion of that term in the model at that place in the sequence. Hence only for orthogonal experiments will the order of inclusion be inconsequential.\nFor multistratum experiments the procedure is first to project the response onto the error strata, again in sequence, and to fit the mean model to each projection. For further details, see Chambers & Hastie (1992).\nA more flexible alternative to the default full ANOVA table is to compare two or more models directly using the anova() function.\n> anova(fitted.model.1, fitted.model.2, …)\nThe display is then an ANOVA table showing the differences between the fitted models when fitted in sequence. The fitted models being compared would usually be an hierarchical sequence, of course. This does not give different information to the default, but rather makes it easier to comprehend and control."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-updating-fitted-models",
    "href": "tutorials/R/r-manuals/test.html#sec-updating-fitted-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.5 Updating fitted models",
    "text": "11.5 Updating fitted models\nThe update() function is largely a convenience function that allows a model to be fitted that differs from one previously fitted usually by just a few additional or removed terms. Its form is\n> new.model <- update(old.model, new.formula)\nIn the new.formula the special name consisting of a period, ., only, can be used to stand for “the corresponding part of the old model formula”. For example,\n> fm05 <- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)\n> fm6  <- update(fm05, . ~ . + x6)\n> smf6 <- update(fm6, sqrt(.) ~ .)\nwould fit a five variate multiple regression with variables (presumably) from the data frame production, fit an additional model including a sixth regressor variable, and fit a variant on the model where the response had a square root transform applied.\nNote especially that if the data= argument is specified on the original call to the model fitting function, this information is passed on through the fitted model object to update() and its allies.\nThe name ‘.’ can also be used in other contexts, but with slightly different meaning. For example\n> fmfull <- lm(y ~ . , data = production)\nwould fit a model with response y and regressor variables all other variables in the data frame production.\nOther functions for exploring incremental sequences of models are add1(), drop1() and step(). The names of these give a good clue to their purpose, but for full details see the on-line help."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-generalized-linear-models",
    "href": "tutorials/R/r-manuals/test.html#sec-generalized-linear-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.6 Generalized linear models",
    "text": "11.6 Generalized linear models\nGeneralized linear modeling is a development of linear models to accommodate both non-normal response distributions and transformations to linearity in a clean and straightforward way. A generalized linear model may be described in terms of the following sequence of assumptions:\n\nThere is a response, y, of interest and stimulus variables x_1, x_2, …, whose values influence the distribution of the response.\nThe stimulus variables influence the distribution of y through a single linear function, only. This linear function is called the linear predictor, and is usually written\n\neta = beta_1 x_1 + beta_2 x_2 + … + beta_p x_p,\n\nhence x_i has no influence on the distribution of y if and only if beta_i is zero.\nThe distribution of y is of the form\n\nf_Y(y; mu, phi)\n  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))\n\nwhere phi is a scale parameter (possibly known), and is constant for all observations, A represents a prior weight, assumed known but possibly varying with the observations, and $\\mu$ is the mean of y. So it is assumed that the distribution of y is determined by its mean and possibly a scale parameter as well.\nThe mean, mu, is a smooth invertible function of the linear predictor:\n\nmu = m(eta),    eta = m^{-1}(mu) = ell(mu)\n\nand this inverse function, ell(), is called the link function.\n\nThese assumptions are loose enough to encompass a wide class of models useful in statistical practice, but tight enough to allow the development of a unified methodology of estimation and inference, at least approximately. The reader is referred to any of the current reference works on the subject for full details, such as McCullagh & Nelder (1989) or Dobson (1990).\n\n11.6.1 Families\nThe class of generalized linear models handled by facilities supplied in R includes gaussian, binomial, poisson, inverse gaussian and gamma response distributions and also quasi-likelihood models where the response distribution is not explicitly specified. In the latter case the variance function must be specified as a function of the mean, but in other cases this function is implied by the response distribution.\nEach response distribution admits a variety of link functions to connect the mean with the linear predictor. Those automatically available are shown in the following table:\n\n\n\n\n\nFamily name\nLink functions\n\n\n\n\nbinomial\nlogit, probit, log, cloglog\n\n\ngaussian\nidentity, log, inverse\n\n\nGamma\nidentity, inverse, log\n\n\ninverse.gaussian\n1/mu^2, identity, inverse, log\n\n\npoisson\nidentity, log, sqrt\n\n\nquasi\nlogit, probit, cloglog, identity, inverse, log, 1/mu^2, sqrt\n\n\n\n\n\nThe combination of a response distribution, a link function and various other pieces of information that are needed to carry out the modeling exercise is called the family of the generalized linear model.\n\n\n11.6.2 The glm() function {#sec-the-glm()-function}\nSince the distribution of the response depends on the stimulus variables through a single linear function only, the same mechanism as was used for linear models can still be used to specify the linear part of a generalized model. The family has to be specified in a different way.\nThe R function to fit a generalized linear model is glm() which uses the form\n> fitted.model <- glm(formula, family=family.generator, data=data.frame)\nThe only new feature is the family.generator, which is the instrument by which the family is described. It is the name of a function that generates a list of functions and expressions that together define and control the model and estimation process. Although this may seem a little complicated at first sight, its use is quite simple.\nThe names of the standard, supplied family generators are given under “Family Name” in the table in Families. Where there is a choice of links, the name of the link may also be supplied with the family name, in parentheses as a parameter. In the case of the quasi family, the variance function may also be specified in this way.\nSome examples make the process clear.\n\n\n11.6.3 The gaussian family {#sec-the-gaussian-family}\nA call such as\n> fm <- glm(y ~ x1 + x2, family = gaussian, data = sales)\nachieves the same result as\n> fm <- lm(y ~ x1+x2, data=sales)\nbut much less efficiently. Note how the gaussian family is not automatically provided with a choice of links, so no parameter is allowed. If a problem requires a gaussian family with a nonstandard link, this can usually be achieved through the quasi family, as we shall see later.\n\n\n11.6.4 The binomial family {#sec-the-binomial-family}\nConsider a small, artificial example, from Silvey (1970).\nOn the Aegean island of Kalythos the male inhabitants suffer from a congenital eye disease, the effects of which become more marked with increasing age. Samples of islander males of various ages were tested for blindness and the results recorded. The data is shown below:\nThe problem we consider is to fit both logistic and probit models to this data, and to estimate for each model the LD50, that is the age at which the chance of blindness for a male inhabitant is 50%.\nIf y is the number of blind at age x and n the number tested, both models have the form y ~ B(n, F(beta_0 + beta_1 x)) where for the probit case, F(z) = Phi(z) is the standard normal distribution function, and in the logit case (the default), F(z) = e^z/(1+e^z). In both cases the LD50 is LD50 = - beta_0/beta_1 that is, the point at which the argument of the distribution function is zero.\nThe first step is to set the data up as a data frame\n> kalythos <- data.frame(x = c(20,35,45,55,70), n = rep(50,5),\n                         y = c(6,17,26,37,44))\nTo fit a binomial model using glm() there are three possibilities for the response:\n\nIf the response is a vector it is assumed to hold binary data, and so must be a 0/1 vector.\nIf the response is a two-column matrix it is assumed that the first column holds the number of successes for the trial and the second holds the number of failures.\nIf the response is a factor, its first level is taken as failure (0) and all other levels as ‘success’ (1).\n\nHere we need the second of these conventions, so we add a matrix to our data frame:\n> kalythos$Ymat <- cbind(kalythos$y, kalythos$n - kalythos$y)\nTo fit the models we use\n> fmp <- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)\n> fml <- glm(Ymat ~ x, family = binomial, data = kalythos)\nSince the logit link is the default the parameter may be omitted on the second call. To see the results of each fit we could use\n> summary(fmp)\n> summary(fml)\nBoth models fit (all too) well. To find the LD50 estimate we can use a simple function:\n> ld50 <- function(b) -b[1]/b[2]\n> ldp <- ld50(coef(fmp)); ldl <- ld50(coef(fml)); c(ldp, ldl)\nThe actual estimates from this data are 43.663 years and 43.601 years respectively.\n\n\n11.6.5 Poisson models\nWith the Poisson family the default link is the log, and in practice the major use of this family is to fit surrogate Poisson log-linear models to frequency data, whose actual distribution is often multinomial. This is a large and important subject we will not discuss further here. It even forms a major part of the use of non-gaussian generalized models overall.\nOccasionally genuinely Poisson data arises in practice and in the past it was often analyzed as gaussian data after either a log or a square-root transformation. As a graceful alternative to the latter, a Poisson generalized linear model may be fitted as in the following example:\n> fmod <- glm(y ~ A + B + x, family = poisson(link=sqrt),\n              data = worm.counts)\n\n\n11.6.6 Quasi-likelihood models\nFor all families the variance of the response will depend on the mean and will have the scale parameter as a multiplier. The form of dependence of the variance on the mean is a characteristic of the response distribution; for example for the poisson distribution Var(y) = mu.\nFor quasi-likelihood estimation and inference the precise response distribution is not specified, but rather only a link function and the form of the variance function as it depends on the mean. Since quasi-likelihood estimation uses formally identical techniques to those for the gaussian distribution, this family provides a way of fitting gaussian models with non-standard link functions or variance functions, incidentally.\nFor example, consider fitting the non-linear regression y = theta_1 z_1 / (z_2 - theta_2) + e which may be written alternatively as y = 1 / (beta_1 x_1 + beta_2 x_2) + e where x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 = theta_2/theta_1. Supposing a suitable data frame to be set up we could fit this non-linear regression as\n> nlfit <- glm(y ~ x1 + x2 - 1,\n               family = quasi(link=inverse, variance=constant),\n               data = biochem)\nThe reader is referred to the manual and the help document for further information, as needed."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-nonlinear-least-squares-and-maximum-likelihood-models",
    "href": "tutorials/R/r-manuals/test.html#sec-nonlinear-least-squares-and-maximum-likelihood-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.7 Nonlinear least squares and maximum likelihood models",
    "text": "11.7 Nonlinear least squares and maximum likelihood models\nCertain forms of nonlinear model can be fitted by Generalized Linear Models (glm()). But in the majority of cases we have to approach the nonlinear curve fitting problem as one of nonlinear optimization. R’s nonlinear optimization routines are optim(), nlm() and nlminb(), We seek the parameter values that minimize some index of lack-of-fit, and they do this by trying out various parameter values iteratively. Unlike linear regression for example, there is no guarantee that the procedure will converge on satisfactory estimates. All the methods require initial guesses about what parameter values to try, and convergence may depend critically upon the quality of the starting values.\n\n11.7.1 Least squares\nOne way to fit a nonlinear model is by minimizing the sum of the squared errors (SSE) or residuals. This method makes sense if the observed errors could have plausibly arisen from a normal distribution.\nHere is an example from Bates & Watts (1988), page 51. The data are:\n> x <- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,\n         1.10, 1.10)\n> y <- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)\nThe fit criterion to be minimized is:\n> fn <- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)\nIn order to do the fit we need initial estimates of the parameters. One way to find sensible starting values is to plot the data, guess some parameter values, and superimpose the model curve using those values.\n> plot(x, y)\n> xfit <- seq(.02, 1.1, .05)\n> yfit <- 200 * xfit/(0.1 + xfit)\n> lines(spline(xfit, yfit))\nWe could do better, but these starting values of 200 and 0.1 seem adequate. Now do the fit:\n> out <- nlm(fn, p = c(200, 0.1), hessian = TRUE)\nAfter the fitting, out$minimum is the SSE, and out$estimate are the least squares estimates of the parameters. To obtain the approximate standard errors (SE) of the estimates we do:\n> sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))\nThe 2 which is subtracted in the line above represents the number of parameters. A 95% confidence interval would be the parameter estimate +/- 1.96 SE. We can superimpose the least squares fit on a new plot:\n> plot(x, y)\n> xfit <- seq(.02, 1.1, .05)\n> yfit <- 212.68384222 * xfit/(0.06412146 + xfit)\n> lines(spline(xfit, yfit))\nThe standard package stats provides much more extensive facilities for fitting non-linear models by least squares. The model we have just fitted is the Michaelis-Menten model, so we can use\n> df <- data.frame(x=x, y=y)\n> fit <- nls(y ~ SSmicmen(x, Vm, K), df)\n> fit\nNonlinear regression model\n  model:  y ~ SSmicmen(x, Vm, K)\n   data:  df\n          Vm            K\n212.68370711   0.06412123\n residual sum-of-squares:  1195.449\n> summary(fit)\n\nFormula: y ~ SSmicmen(x, Vm, K)\n\nParameters:\n    Estimate Std. Error t value Pr(>|t|)\nVm 2.127e+02  6.947e+00  30.615 3.24e-11\nK  6.412e-02  8.281e-03   7.743 1.57e-05\n\nResidual standard error: 10.93 on 10 degrees of freedom\n\nCorrelation of Parameter Estimates:\n      Vm\nK 0.7651\n\n\n11.7.2 Maximum likelihood\nMaximum likelihood is a method of nonlinear model fitting that applies even if the errors are not normal. The method finds the parameter values which maximize the log likelihood, or equivalently which minimize the negative log-likelihood. Here is an example from Dobson (1990), pp. 108–111. This example fits a logistic model to dose-response data, which clearly could also be fit by glm(). The data are:\n> x <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,\n         1.8369, 1.8610, 1.8839)\n> y <- c( 6, 13, 18, 28, 52, 53, 61, 60)\n> n <- c(59, 60, 62, 56, 63, 59, 62, 60)\nThe negative log-likelihood to minimize is:\n> fn <- function(p)\n   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))\n           + log(choose(n, y)) ))\nWe pick sensible starting values and do the fit:\n> out <- nlm(fn, p = c(-50,20), hessian = TRUE)\nAfter the fitting, out$minimum is the negative log-likelihood, and out$estimate are the maximum likelihood estimates of the parameters. To obtain the approximate SEs of the estimates we do:\n> sqrt(diag(solve(out$hessian)))\nA 95% confidence interval would be the parameter estimate +/- 1.96 SE."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-some-non-standard-models",
    "href": "tutorials/R/r-manuals/test.html#sec-some-non-standard-models",
    "title": "R Manuals :: An Introduction to R",
    "section": "11.8 Some non-standard models",
    "text": "11.8 Some non-standard models\nWe conclude this chapter with just a brief mention of some of the other facilities available in R for special regression and data analysis problems.\n\n Mixed models. The recommended nlme package provides functions lme() and nlme() for linear and non-linear mixed-effects models, that is linear and non-linear regressions in which some of the coefficients correspond to random effects. These functions make heavy use of formulae to specify the models.\n Local approximating regressions. The loess() function fits a nonparametric regression by using a locally weighted regression. Such regressions are useful for highlighting a trend in messy data or for data reduction to give some insight into a large data set.\nFunction loess is in the standard package stats, together with code for projection pursuit regression.\n Robust regression. There are several functions available for fitting regression models in a way resistant to the influence of extreme outliers in the data. Function lqs in the recommended package MASS provides state-of-art algorithms for highly-resistant fits. Less resistant but statistically more efficient methods are available in packages, for example function rlm in package MASS.\n Additive models. This technique aims to construct a regression function from smooth additive functions of the determining variables, usually one for each determining variable. Functions avas and ace in package acepack and functions bruto and mars in package mda provide some examples of these techniques in user-contributed packages to R. An extension is Generalized Additive Models, implemented in user-contributed packages gam and mgcv.\n Tree-based models. Rather than seek an explicit global linear model for prediction or interpretation, tree-based models seek to bifurcate the data, recursively, at critical points of the determining variables in order to partition the data ultimately into groups that are as homogeneous as possible within, and as heterogeneous as possible between. The results often lead to insights that other data analysis methods tend not to yield.\nModels are again specified in the ordinary linear model form. The model fitting function is tree(), but many other generic functions such as plot() and text() are well adapted to displaying the results of a tree-based model fit in a graphical way.\nTree models are available in R via the user-contributed packages rpart and tree."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-high-level-plotting-commands",
    "href": "tutorials/R/r-manuals/test.html#sec-high-level-plotting-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.1 High-level plotting commands",
    "text": "12.1 High-level plotting commands\nHigh-level plotting functions are designed to generate a complete plot of the data passed as arguments to the function. Where appropriate, axes, labels and titles are automatically generated (unless you request otherwise.) High-level plotting commands always start a new plot, erasing the current plot if necessary.\n\n12.1.1 The plot() function {#sec-the-plot()-function}\nOne of the most frequently used plotting functions in R is the plot() function. This is a generic function: the type of plot produced is dependent on the type or class of the first argument.\nplot(``x, ``y)\nplot(``xy)\n: If x and y are vectors, plot(``x, ``y) produces a scatterplot of y against x. The same effect can be produced by supplying one argument (second form) as either a list containing two elements x and y or a two-column matrix.\n\nplot(``x)\n\nIf x is a time series, this produces a time-series plot. If x is a numeric vector, it produces a plot of the values in the vector against their index in the vector. If x is a complex vector, it produces a plot of imaginary versus real parts of the vector elements.\n\n\nplot(``f)\nplot(``f, ``y)\n: f is a factor object, y is a numeric vector. The first form generates a bar plot of f; the second form produces boxplots of y for each level of f.\nplot(``df)\nplot(~ ``expr)\nplot(``y~ ``expr)\n: df is a data frame, y is any object, expr is a list of object names separated by + (e.g., a + b + c). The first two forms produce distributional plots of the variables in a data frame (first form) or of a number of named objects (second form). The third form plots y against every object named in expr.\n\n\n12.1.2 Displaying multivariate data\nR provides two very useful functions for representing multivariate data. If X is a numeric matrix or data frame, the command\n> pairs(X)\nproduces a pairwise scatterplot matrix of the variables defined by the columns of X, that is, every column of X is plotted against every other column of X and the resulting n(n-1) plots are arranged in a matrix with plot scales constant over the rows and columns of the matrix.\nWhen three or four variables are involved a coplot may be more enlightening. If a and b are numeric vectors and c is a numeric vector or factor object (all of the same length), then the command\n> coplot(a ~ b | c)\nproduces a number of scatterplots of a against b for given values of c. If c is a factor, this simply means that a is plotted against b for every level of c. When c is numeric, it is divided into a number of conditioning intervals and for each interval a is plotted against b for values of c within the interval. The number and position of intervals can be controlled with given.values= argument to coplot()—the function co.intervals() is useful for selecting intervals. You can also use two given variables with a command like\n> coplot(a ~ b | c + d)\nwhich produces scatterplots of a against b for every joint conditioning interval of c and d.\nThe coplot() and pairs() function both take an argument panel= which can be used to customize the type of plot which appears in each panel. The default is points() to produce a scatterplot but by supplying some other low-level graphics function of two vectors x and y as the value of panel= you can produce any type of plot you wish. An example panel function useful for coplots is panel.smooth().\n\n\n12.1.3 Display graphics\nOther high-level graphics functions produce different types of plots. Some examples are:\nqqnorm(x)\nqqline(x)\nqqplot(x, y)\n: \nDistribution-comparison plots. The first form plots the numeric\nvector `x` against the expected Normal order scores (a normal scores\nplot) and the second adds a straight line to such a plot by drawing\na line through the distribution and data quartiles. The third form\nplots the quantiles of `x` against those of `y` to compare their\nrespective distributions.\nhist(x)\nhist(x, nclass=``n)\nhist(x, breaks=``b, …)\n: \nProduces a histogram of the numeric vector `x`. A sensible number of\nclasses is usually chosen, but a recommendation can be given with\nthe `nclass=` argument. Alternatively, the breakpoints can be\nspecified exactly with the `breaks=` argument. If the\n`probability=TRUE` argument is given, the bars represent relative\nfrequencies divided by bin width instead of counts.\n\ndotchart(x, …)\n\n\nConstructs a dotchart of the data in x. In a dotchart the y-axis gives a labelling of the data in x and the x-axis gives its value. For example it allows easy visual selection of all data entries with values lying in specified ranges.\n\n\nimage(x, y, z, …)\ncontour(x, y, z, …)\npersp(x, y, z, …)\n: \nPlots of three variables. The `image` plot draws a grid of\nrectangles using different colours to represent the value of `z`,\nthe `contour` plot draws contour lines to represent the value of\n`z`, and the `persp` plot draws a 3D surface.\n\n\n12.1.4 Arguments to high-level plotting functions\nThere are a number of arguments which may be passed to high-level graphics functions, as follows:\n\nadd=TRUE\n\nForces the function to act as a low-level graphics function, superimposing the plot on the current plot (some functions only).\n\naxes=FALSE\n\nSuppresses generation of axes—useful for adding your own custom axes with the axis() function. The default, axes=TRUE, means include axes.\n\n\nlog=\"x\"\nlog=\"y\"\nlog=\"xy\"\n: Causes the x, y or both axes to be logarithmic. This will work for many, but not all, types of plot.\n\ntype=\n\nThe type= argument controls the type of plot produced, as follows:\n\ntype=\"p\"\n\nPlot individual points (the default)\n\ntype=\"l\"\n\nPlot lines\n\ntype=\"b\"\n\nPlot points connected by lines (both)\n\ntype=\"o\"\n\nPlot points overlaid by lines\n\ntype=\"h\"\n\nPlot vertical lines from points to the zero axis (high-density)\n\n\ntype=\"s\"\ntype=\"S\"\n: Step-function plots. In the first form, the top of the vertical defines the point; in the second, the bottom.\n\ntype=\"n\"\n\nNo plotting at all. However axes are still drawn (by default) and the coordinate system is set up according to the data. Ideal for creating plots with subsequent low-level graphics functions.\n\n\n\n\nxlab=``string\nylab=``string\n: Axis labels for the x and y axes. Use these arguments to change the default labels, usually the names of the objects used in the call to the high-level plotting function.\n\nmain=``string\n\nFigure title, placed at the top of the plot in a large font.\n\nsub=``string\n\nSub-title, placed just below the x-axis in a smaller font."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-low-level-plotting-commands",
    "href": "tutorials/R/r-manuals/test.html#sec-low-level-plotting-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.2 Low-level plotting commands",
    "text": "12.2 Low-level plotting commands\nSometimes the high-level plotting functions don’t produce exactly the kind of plot you desire. In this case, low-level plotting commands can be used to add extra information (such as points, lines or text) to the current plot.\nSome of the more useful low-level plotting functions are:\npoints(x, y)\nlines(x, y)\n: \nAdds points or connected lines to the current plot. `plot()`'s\n`type=` argument can also be passed to these functions (and defaults\nto `\"p\"` for `points()` and `\"l\"` for `lines()`.)\n\ntext(x, y, labels, …)\n\n\nAdd text to a plot at points given by x, y. Normally labels is an integer or character vector in which case labels[i] is plotted at point (x[i], y[i]). The default is 1:length(x).\nNote: This function is often used in the sequence\n> plot(x, y, type=\"n\"); text(x, y, names)\nThe graphics parameter type=\"n\" suppresses the points but sets up the axes, and the text() function supplies special characters, as specified by the character vector names for the points.\n\n\nabline(a, b)\nabline(h=``y)\nabline(v=``x)\nabline(``lm.obj)\n: \nAdds a line of slope `b` and intercept `a` to the current plot.\n`h=``y`{.variable} may be used to specify *y*-coordinates for the\nheights of horizontal lines to go across a plot, and\n`v=``x`{.variable} similarly for the *x*-coordinates for vertical\nlines. Also `lm.obj`{.variable} may be list with a `coefficients`\ncomponent of length 2 (such as the result of model-fitting\nfunctions,) which are taken as an intercept and slope, in that\norder.\n\npolygon(x, y, …)\n\n\nDraws a polygon defined by the ordered vertices in (x, y) and (optionally) shade it in with hatch lines, or fill it if the graphics device allows the filling of figures.\n\nlegend(x, y, legend, …)\n\n\nAdds a legend to the current plot at the specified position. Plotting characters, line styles, colors etc., are identified with the labels in the character vector legend. At least one other argument v (a vector the same length as legend) with the corresponding values of the plotting unit must also be given, as follows:\n\nlegend( , fill=``v)\n\nColors for filled boxes\n\nlegend( , col=``v)\n\nColors in which points or lines will be drawn\n\nlegend( , lty=``v)\n\nLine styles\n\nlegend( , lwd=``v)\n\nLine widths\n\nlegend( , pch=``v)\n\nPlotting characters (character vector)\n\n\n\ntitle(main, sub)\n\n\nAdds a title main to the top of the current plot in a large font and (optionally) a sub-title sub at the bottom in a smaller font.\n\naxis(side, …)\n\n\nAdds an axis to the current plot on the side given by the first argument (1 to 4, counting clockwise from the bottom.) Other arguments control the positioning of the axis within or beside the plot, and tick positions and labels. Useful for adding custom axes after calling plot() with the axes=FALSE argument.\n\n\nLow-level plotting functions usually require some positioning information (e.g., x and y coordinates) to determine where to place the new plot elements. Coordinates are given in terms of user coordinates which are defined by the previous high-level graphics command and are chosen based on the supplied data.\nWhere x and y arguments are required, it is also sufficient to supply a single argument being a list with elements named x and y. Similarly a matrix with two columns is also valid input. In this way functions such as locator() (see below) may be used to specify positions on a plot interactively.\n\n12.2.1 Mathematical annotation\nIn some cases, it is useful to add mathematical symbols and formulae to a plot. This can be achieved in R by specifying an expression rather than a character string in any one of text, mtext, axis, or title. For example, the following code draws the formula for the Binomial probability function:\n> text(x, y, expression(paste(bgroup(\"(\", atop(n, x), \")\"), p^x, q^{n-x})))\nMore information, including a full listing of the features available can obtained from within R using the commands:\n> help(plotmath)\n> example(plotmath)\n> demo(plotmath)\n\n\n12.2.2 Hershey vector fonts\nIt is possible to specify Hershey vector fonts for rendering text when using the text and contour functions. There are three reasons for using the Hershey fonts:\n\nHershey fonts can produce better output, especially on a computer screen, for rotated and/or small text.\nHershey fonts provide certain symbols that may not be available in the standard fonts. In particular, there are zodiac signs, cartographic symbols and astronomical symbols.\nHershey fonts provide Cyrillic and Japanese (Kana and Kanji) characters.\n\nMore information, including tables of Hershey characters can be obtained from within R using the commands:\n> help(Hershey)\n> demo(Hershey)\n> help(Japanese)\n> demo(Japanese)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-interacting-with-graphics",
    "href": "tutorials/R/r-manuals/test.html#sec-interacting-with-graphics",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.3 Interacting with graphics",
    "text": "12.3 Interacting with graphics\nR also provides functions which allow users to extract or add information to a plot using a mouse. The simplest of these is the locator() function:\n\nlocator(n, type)\n\n\nWaits for the user to select locations on the current plot using the left mouse button. This continues until n (default 512) points have been selected, or another mouse button is pressed. The type argument allows for plotting at the selected points and has the same effect as for high-level graphics commands; the default is no plotting. locator() returns the locations of the points selected as a list with two components x and y.\n\n\nlocator() is usually called with no arguments. It is particularly useful for interactively selecting positions for graphic elements such as legends or labels when it is difficult to calculate in advance where the graphic should be placed. For example, to place some informative text near an outlying point, the command\n> text(locator(1), \"Outlier\", adj=0)\nmay be useful. (locator() will be ignored if the current device, such as postscript does not support interactive pointing.)\n\nidentify(x, y, labels)\n\n\nAllow the user to highlight any of the points defined by x and y (using the left mouse button) by plotting the corresponding component of labels nearby (or the index number of the point if labels is absent). Returns the indices of the selected points when another button is pressed.\n\n\nSometimes we want to identify particular points on a plot, rather than their positions. For example, we may wish the user to select some observation of interest from a graphical display and then manipulate that observation in some way. Given a number of (x, y) coordinates in two numeric vectors x and y, we could use the identify() function as follows:\n> plot(x, y)\n> identify(x, y)\nThe identify() functions performs no plotting itself, but simply allows the user to move the mouse pointer and click the left mouse button near a point. If there is a point near the mouse pointer it will be marked with its index number (that is, its position in the x/y vectors) plotted nearby. Alternatively, you could use some informative string (such as a case name) as a highlight by using the labels argument to identify(), or disable marking altogether with the plot = FALSE argument. When the process is terminated (see above), identify() returns the indices of the selected points; you can use these indices to extract the selected points from the original vectors x and y."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-using-graphics-parameters",
    "href": "tutorials/R/r-manuals/test.html#sec-using-graphics-parameters",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.4 Using graphics parameters",
    "text": "12.4 Using graphics parameters\nWhen creating graphics, particularly for presentation or publication purposes, R’s defaults do not always produce exactly that which is required. You can, however, customize almost every aspect of the display using graphics parameters. R maintains a list of a large number of graphics parameters which control things such as line style, colors, figure arrangement and text justification among many others. Every graphics parameter has a name (such as col, which controls colors,) and a value (a color number, for example.)\nA separate list of graphics parameters is maintained for each active device, and each device has a default set of parameters when initialized. Graphics parameters can be set in two ways: either permanently, affecting all graphics functions which access the current device; or temporarily, affecting only a single graphics function call.\n\n12.4.1 Permanent changes: The par() function {#sec-permanent-changes:-the-par()-function}\nThe par() function is used to access and modify the list of graphics parameters for the current graphics device.\n\npar()\n\nWithout arguments, returns a list of all graphics parameters and their values for the current device.\n\npar(c(\"col\", \"lty\"))\n\nWith a character vector argument, returns only the named graphics parameters (again, as a list.)\n\npar(col=4, lty=2)\n\nWith named arguments (or a single list argument), sets the values of the named graphics parameters, and returns the original values of the parameters as a list.\n\n\nSetting graphics parameters with the par() function changes the value of the parameters permanently, in the sense that all future calls to graphics functions (on the current device) will be affected by the new value. You can think of setting graphics parameters in this way as setting “default” values for the parameters, which will be used by all graphics functions unless an alternative value is given.\nNote that calls to par() always affect the global values of graphics parameters, even when par() is called from within a function. This is often undesirable behavior—usually we want to set some graphics parameters, do some plotting, and then restore the original values so as not to affect the user’s R session. You can restore the initial values by saving the result of par() when making changes, and restoring the initial values when plotting is complete.\n> oldpar <- par(col=4, lty=2)\n  … plotting commands …\n> par(oldpar)\nTo save and restore all settable24 graphical parameters use\n> oldpar <- par(no.readonly=TRUE)\n  … plotting commands …\n> par(oldpar)\n\n\n12.4.2 Temporary changes: Arguments to graphics functions\nGraphics parameters may also be passed to (almost) any graphics function as named arguments. This has the same effect as passing the arguments to the par() function, except that the changes only last for the duration of the function call. For example:\n> plot(x, y, pch=\"+\")\nproduces a scatterplot using a plus sign as the plotting character, without changing the default plotting character for future plots.\nUnfortunately, this is not implemented entirely consistently and it is sometimes necessary to set and reset graphics parameters using par()."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-graphics-parameters-list",
    "href": "tutorials/R/r-manuals/test.html#sec-graphics-parameters-list",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.5 Graphics parameters list",
    "text": "12.5 Graphics parameters list\nThe following sections detail many of the commonly-used graphical parameters. The R help documentation for the par() function provides a more concise summary; this is provided as a somewhat more detailed alternative.\nGraphics parameters will be presented in the following form:\n\nname=``value\n\nA description of the parameter’s effect. name is the name of the parameter, that is, the argument name to use in calls to par() or a graphics function. value is a typical value you might use when setting the parameter.\n\n\nNote that axes is not a graphics parameter but an argument to a few plot methods: see xaxt and yaxt.\n\n12.5.1 Graphical elements\nR plots are made up of points, lines, text and polygons (filled regions.) Graphical parameters exist which control how these graphical elements are drawn, as follows:\n\npch=\"+\"\n\nCharacter to be used for plotting points. The default varies with graphics drivers, but it is usually a circle. Plotted points tend to appear slightly above or below the appropriate position unless you use \".\" as the plotting character, which produces centered points.\n\npch=4\n\nWhen pch is given as an integer between 0 and 25 inclusive, a specialized plotting symbol is produced. To see what the symbols are, use the command\n> legend(locator(1), as.character(0:25), pch = 0:25)\nThose from 21 to 25 may appear to duplicate earlier symbols, but can be coloured in different ways: see the help on points and its examples.\nIn addition, pch can be a character or a number in the range 32:255 representing a character in the current font.\n\nlty=2\n\nLine types. Alternative line styles are not supported on all graphics devices (and vary on those that do) but line type 1 is always a solid line, line type 0 is always invisible, and line types 2 and onwards are dotted or dashed lines, or some combination of both.\n\nlwd=2\n\nLine widths. Desired width of lines, in multiples of the “standard” line width. Affects axis lines as well as lines drawn with lines(), etc. Not all devices support this, and some have restrictions on the widths that can be used.\n\ncol=2\n\nColors to be used for points, lines, text, filled regions and images. A number from the current palette (see ?palette) or a named colour.\n\n\ncol.axis\ncol.lab\ncol.main\ncol.sub\n: The color to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\nfont=2\n\nAn integer which specifies which font to use for text. If possible, device drivers arrange so that 1 corresponds to plain text, 2 to bold face, 3 to italic, 4 to bold italic and 5 to a symbol font (which include Greek letters).\n\n\nfont.axis\nfont.lab\nfont.main\nfont.sub\n: The font to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\nadj=-0.1\n\nJustification of text relative to the plotting position. 0 means left justify, 1 means right justify and 0.5 means to center horizontally about the plotting position. The actual value is the proportion of text that appears to the left of the plotting position, so a value of -0.1 leaves a gap of 10% of the text width between the text and the plotting position.\n\ncex=1.5\n\nCharacter expansion. The value is the desired size of text characters (including plotting characters) relative to the default text size.\n\n\ncex.axis\ncex.lab\ncex.main\ncex.sub\n: The character expansion to be used for axis annotation, x and y labels, main and sub-titles, respectively.\n\n\n12.5.2 Axes and tick marks\nMany of R’s high-level plots have axes, and you can construct axes yourself with the low-level axis() graphics function. Axes have three main components: the axis line (line style controlled by the lty graphics parameter), the tick marks (which mark off unit divisions along the axis line) and the tick labels (which mark the units.) These components can be customized with the following graphics parameters.\n\nlab=c(5, 7, 12)\n\nThe first two numbers are the desired number of tick intervals on the x and y axes respectively. The third number is the desired length of axis labels, in characters (including the decimal point.) Choosing a too-small value for this parameter may result in all tick labels being rounded to the same number!\n\nlas=1\n\nOrientation of axis labels. 0 means always parallel to axis, 1 means always horizontal, and 2 means always perpendicular to the axis.\n\nmgp=c(3, 1, 0)\n\nPositions of axis components. The first component is the distance from the axis label to the axis position, in text lines. The second component is the distance to the tick labels, and the final component is the distance from the axis position to the axis line (usually zero). Positive numbers measure outside the plot region, negative numbers inside.\n\ntck=0.01\n\nLength of tick marks, as a fraction of the size of the plotting region. When tck is small (less than 0.5) the tick marks on the x and y axes are forced to be the same size. A value of 1 gives grid lines. Negative values give tick marks outside the plotting region. Use tck=0.01 and mgp=c(1,-1.5,0) for internal tick marks.\n\n\nxaxs=\"r\"\nyaxs=\"i\"\n: Axis styles for the x and y axes, respectively. With styles \"i\" (internal) and \"r\" (the default) tick marks always fall within the range of the data, however style \"r\" leaves a small amount of space at the edges.\n\n\n12.5.3 Figure margins\nA single plot in R is known as a figure and comprises a plot region surrounded by margins (possibly containing axis labels, titles, etc.) and (usually) bounded by the axes themselves.\nA typical figure is\n\n\n\nimages/fig11\n\n\nGraphics parameters controlling figure layout include:\n\nmai=c(1, 0.5, 0.5, 0)\n\nWidths of the bottom, left, top and right margins, respectively, measured in inches.\n\nmar=c(4, 2, 2, 1)\n\nSimilar to mai, except the measurement unit is text lines.\n\n\nmar and mai are equivalent in the sense that setting one changes the value of the other. The default values chosen for this parameter are often too large; the right-hand margin is rarely needed, and neither is the top margin if no title is being used. The bottom and left margins must be large enough to accommodate the axis and tick labels. Furthermore, the default is chosen without regard to the size of the device surface: for example, using the postscript() driver with the height=4 argument will result in a plot which is about 50% margin unless mar or mai are set explicitly. When multiple figures are in use (see below) the margins are reduced, however this may not be enough when many figures share the same page.\n\n\n12.5.4 Multiple figure environment\nR allows you to create an n by m array of figures on a single page. Each figure has its own margins, and the array of figures is optionally surrounded by an outer margin, as shown in the following figure.\n\n\n\nimages/fig12\n\n\nThe graphical parameters relating to multiple figures are as follows:\nmfcol=c(3, 2)\nmfrow=c(2, 4)\n: Set the size of a multiple figure array. The first value is the number of rows; the second is the number of columns. The only difference between these two parameters is that setting mfcol causes figures to be filled by column; mfrow fills by rows.\nThe layout in the Figure could have been created by setting\n`mfrow=c(3,2)`; the figure shows the page after four plots have been\ndrawn.\n\nSetting either of these can reduce the base size of symbols and text\n(controlled by `par(\"cex\")` and the pointsize of the device). In a\nlayout with exactly two rows and columns the base size is reduced by\na factor of 0.83: if there are three or more of either rows or\ncolumns, the reduction factor is 0.66.\n\nmfg=c(2, 2, 3, 2)\n\nPosition of the current figure in a multiple figure environment. The first two numbers are the row and column of the current figure; the last two are the number of rows and columns in the multiple figure array. Set this parameter to jump between figures in the array. You can even use different values for the last two numbers than the true values for unequally-sized figures on the same page.\n\nfig=c(4, 9, 1, 4)/10\n\nPosition of the current figure on the page. Values are the positions of the left, right, bottom and top edges respectively, as a percentage of the page measured from the bottom left corner. The example value would be for a figure in the bottom right of the page. Set this parameter for arbitrary positioning of figures within a page. If you want to add a figure to a current page, use new=TRUE as well (unlike S).\n\n\noma=c(2, 0, 3, 0)\nomi=c(0, 0, 0.8, 0)\n: Size of outer margins. Like mar and mai, the first measures in text lines and the second in inches, starting with the bottom margin and working clockwise.\nOuter margins are particularly useful for page-wise titles, etc. Text can be added to the outer margins with the mtext() function with argument outer=TRUE. There are no outer margins by default, however, so you must create them explicitly using oma or omi.\nMore complicated arrangements of multiple figures can be produced by the split.screen() and layout() functions, as well as by the grid and lattice packages."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-device-drivers",
    "href": "tutorials/R/r-manuals/test.html#sec-device-drivers",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.6 Device drivers",
    "text": "12.6 Device drivers\nR can generate graphics (of varying levels of quality) on almost any type of display or printing device. Before this can begin, however, R needs to be informed what type of device it is dealing with. This is done by starting a device driver. The purpose of a device driver is to convert graphical instructions from R (“draw a line,” for example) into a form that the particular device can understand.\nDevice drivers are started by calling a device driver function. There is one such function for every device driver: type help(Devices) for a list of them all. For example, issuing the command\n> postscript()\ncauses all future graphics output to be sent to the printer in PostScript format. Some commonly-used device drivers are:\n\nX11()\n\n\nFor use with the X11 window system on Unix-alikes\n\nwindows()\n\n\nFor use on Windows\n\nquartz()\n\n\nFor use on macOS\n\npostscript()\n\n\nFor printing on PostScript printers, or creating PostScript graphics files.\n\npdf()\n\n\nProduces a PDF file, which can also be included into PDF files.\n\npng()\n\n\nProduces a bitmap PNG file. (Not always available: see its help page.)\n\njpeg()\n\n\nProduces a bitmap JPEG file, best used for image plots. (Not always available: see its help page.)\n\n\nWhen you have finished with a device, be sure to terminate the device driver by issuing the command\n> dev.off()\nThis ensures that the device finishes cleanly; for example in the case of hardcopy devices this ensures that every page is completed and has been sent to the printer. (This will happen automatically at the normal end of a session.)\n\n12.6.1 PostScript diagrams for typeset documents\nBy passing the file argument to the postscript() device driver function, you may store the graphics in PostScript format in a file of your choice. The plot will be in landscape orientation unless the horizontal=FALSE argument is given, and you can control the size of the graphic with the width and height arguments (the plot will be scaled as appropriate to fit these dimensions.) For example, the command\n> postscript(\"file.ps\", horizontal=FALSE, height=5, pointsize=10)\nwill produce a file containing PostScript code for a figure five inches high, perhaps for inclusion in a document. It is important to note that if the file named in the command already exists, it will be overwritten. This is the case even if the file was only created earlier in the same R session.\nMany usages of PostScript output will be to incorporate the figure in another document. This works best when encapsulated PostScript is produced: R always produces conformant output, but only marks the output as such when the onefile=FALSE argument is supplied. This unusual notation stems from S-compatibility: it really means that the output will be a single page (which is part of the EPSF specification). Thus to produce a plot for inclusion use something like\n> postscript(\"plot1.eps\", horizontal=FALSE, onefile=FALSE,\n             height=8, width=6, pointsize=10)\n\n\n12.6.2 Multiple graphics devices\nIn advanced use of R it is often useful to have several graphics devices in use at the same time. Of course only one graphics device can accept graphics commands at any one time, and this is known as the current device. When multiple devices are open, they form a numbered sequence with names giving the kind of device at any position.\nThe main commands used for operating with multiple devices, and their meanings are as follows:\n\nX11()\n\n[UNIX]\n\n\nwindows()\nwin.printer()\nwin.metafile()\n: [Windows]\n\nquartz()\n\n[macOS]\n\n\npostscript()\npdf()\npng()\njpeg()\ntiff()\nbitmap()\n…\n: Each new call to a device driver function opens a new graphics device, thus extending by one the device list. This device becomes the current device, to which graphics output will be sent.\n\ndev.list()\n\n\nReturns the number and name of all active devices. The device at position 1 on the list is always the null device which does not accept graphics commands at all.\n\n\ndev.next()\ndev.prev()\n: \nReturns the number and name of the graphics device next to, or\nprevious to the current device, respectively.\n\ndev.set(which=``k)\n\n\nCan be used to change the current graphics device to the one at position k of the device list. Returns the number and label of the device.\n\ndev.off(``k)\n\n\nTerminate the graphics device at point k of the device list. For some devices, such as postscript devices, this will either print the file immediately or correctly complete the file for later printing, depending on how the device was initiated.\n\n\ndev.copy(device, …, which=``k)\ndev.print(device, …, which=``k)\n: Make a copy of the device k. Here device is a device function, such as postscript, with extra arguments, if needed, specified by ‘…’. dev.print is similar, but the copied device is immediately closed, so that end actions, such as printing hardcopies, are immediately performed.\n\ngraphics.off()\n\nTerminate all graphics devices on the list, except the null device."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-dynamic-graphics",
    "href": "tutorials/R/r-manuals/test.html#sec-dynamic-graphics",
    "title": "R Manuals :: An Introduction to R",
    "section": "12.7 Dynamic graphics",
    "text": "12.7 Dynamic graphics\nR does not have builtin capabilities for dynamic or interactive graphics, e.g. rotating point clouds or to “brushing” (interactively highlighting) points. However, extensive dynamic graphics facilities are available in the system GGobi by Swayne, Cook and Buja available from\n\nhttp://ggobi.org/\n\nand these can be accessed from R via the package rggobi, described at http://ggobi.org/rggobi.html.\nAlso, package rgl provides ways to interact with 3D plots, for example of surfaces."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-standard-packages",
    "href": "tutorials/R/r-manuals/test.html#sec-standard-packages",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.1 Standard packages",
    "text": "13.1 Standard packages\nThe standard (or base) packages are considered part of the R source code. They contain the basic functions that allow R to work, and the datasets and standard statistical and graphical functions that are described in this manual. They should be automatically available in any R installation. See R packages in R FAQ, for a complete list."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-contributed-packages-and-cran",
    "href": "tutorials/R/r-manuals/test.html#sec-contributed-packages-and-cran",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.2 Contributed packages and CRAN",
    "text": "13.2 Contributed packages and CRAN\nThere are thousands of contributed packages for R, written by many different authors. Some of these packages implement specialized statistical methods, others give access to data or hardware, and others are designed to complement textbooks. Some (the recommended packages) are distributed with every binary distribution of R. Most are available for download from CRAN (https://CRAN.R-project.org/ and its mirrors) and other repositories such as Bioconductor (https://www.bioconductor.org/). The R FAQ contains a list of CRAN packages current at the time of release, but the collection of available packages changes very frequently."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-namespaces",
    "href": "tutorials/R/r-manuals/test.html#sec-namespaces",
    "title": "R Manuals :: An Introduction to R",
    "section": "13.3 Namespaces",
    "text": "13.3 Namespaces\nPackages have namespaces, which do three things: they allow the package writer to hide functions and data that are meant only for internal use, they prevent functions from breaking when a user (or other package writer) picks a name that clashes with one in the package, and they provide a way to refer to an object within a particular package.\nFor example, t() is the transpose function in R, but users might define their own function named t. Namespaces prevent the user’s definition from taking precedence, and breaking every function that tries to transpose a matrix.\nThere are two operators that work with namespaces. The double-colon operator :: selects definitions from a particular namespace. In the example above, the transpose function will always be available as base::t, because it is defined in the base package. Only functions that are exported from the package can be retrieved in this way.\nThe triple-colon operator ::: may be seen in a few places in R code: it acts like the double-colon operator but also allows access to hidden objects. Users are more likely to use the getAnywhere() function, which searches multiple packages.\nPackages are often inter-dependent, and loading one may cause others to be automatically loaded. The colon operators described above will also cause automatic loading of the associated package. When packages with namespaces are loaded automatically they are not added to the search list."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-files-and-directories",
    "href": "tutorials/R/r-manuals/test.html#sec-files-and-directories",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.1 Files and directories",
    "text": "14.1 Files and directories\nThere are many functions to manipulate files and directories. Here are pointers to some of the more commonly used ones.\nTo create an (empty) file or directory, use file.create or dir.create. (These are the analogues of the POSIX utilities touch and mkdir.) For temporary files and directories in the R session directory see tempfile.\nFiles can be removed by either file.remove or unlink: the latter can remove directory trees.\nFor directory listings use list.files (also available as dir) or list.dirs. These can select files using a regular expression: to select by wildcards use Sys.glob.\nMany types of information on a filepath (including for example if it is a file or directory) can be found by file.info.\nThere are several ways to find out if a file ‘exists’ (a file can exist on the filesystem and not be visible to the current user). There are functions file.exists, file.access and file_test with various versions of this test: file_test is a version of the POSIX test command for those familiar with shell scripting.\nFunction file.copy is the R analogue of the POSIX command cp.\nChoosing files can be done interactively by file.choose: the Windows port has the more versatile functions choose.files and choose.dir and there are similar functions in the tcltk package: tk_choose.files and tk_choose.dir.\nFunctions file.show and file.edit will display and edit one or more files in a way appropriate to the R port, using the facilities of a console (such as RGui on Windows or R.app on macOS) if one is in use.\nThere is some support for links in the filesystem: see functions file.link and Sys.readlink."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-filepaths",
    "href": "tutorials/R/r-manuals/test.html#sec-filepaths",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.2 Filepaths",
    "text": "14.2 Filepaths\nWith a few exceptions, R relies on the underlying OS functions to manipulate filepaths. Some aspects of this are allowed to depend on the OS, and do, even down to the version of the OS. There are POSIX standards for how OSes should interpret filepaths and many R users assume POSIX compliance: but Windows does not claim to be compliant and other OSes may be less than completely compliant.\nThe following are some issues which have been encountered with filepaths.\n\nPOSIX filesystems are case-sensitive, so foo.png and Foo.PNG are different files. However, the defaults on Windows and macOS are to be case-insensitive, and FAT filesystems (commonly used on removable storage) are not normally case-sensitive (and all filepaths may be mapped to lower case).\nAlmost all the Windows’ OS services support the use of slash or backslash as the filepath separator, and R converts the known exceptions to the form required by Windows.\nThe behaviour of filepaths with a trailing slash is OS-dependent. Such paths are not valid on Windows and should not be expected to work. POSIX-2008 requires such paths to match only directories, but earlier versions allowed them to also match files. So they are best avoided.\nMultiple slashes in filepaths such as /abc//def are valid on POSIX filesystems and treated as if there was only one slash. They are usually accepted by Windows’ OS functions. However, leading double slashes may have a different meaning.\nWindows’ UNC filepaths (such as \\\\server\\dir1\\dir2\\file and \\\\?\\UNC\\server\\dir1\\dir2\\file) are not supported, but they may work in some R functions. POSIX filesystems are allowed to treat a leading double slash specially.\nWindows allows filepaths containing drives and relative to the current directory on a drive, e.g. d:foo/bar refers to d:/a/b/c/foo/bar if the current directory on drive d: is /a/b/c. It is intended that these work, but the use of absolute paths is safer.\n\nFunctions basename and dirname select parts of a file path: the recommended way to assemble a file path from components is file.path. Function pathexpand does ‘tilde expansion’, substituting values for home directories (the current user’s, and perhaps those of other users).\nOn filesystems with links, a single file can be referred to by many filepaths. Function normalizePath will find a canonical filepath.\nWindows has the concepts of short (‘8.3’) and long file names: normalizePath will return an absolute path using long file names and shortPathName will return a version using short names. The latter does not contain spaces and uses backslash as the separator, so is sometimes useful for exporting names from R.\nFile permissions are a related topic. R has support for the POSIX concepts of read/write/execute permission for owner/group/all but this may be only partially supported on the filesystem, so for example on Windows only read-only files (for the account running the R session) are recognized. Access Control Lists (ACLs) are employed on several filesystems, but do not have an agreed standard and R has no facilities to control them. Use Sys.chmod to change permissions."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-system-commands",
    "href": "tutorials/R/r-manuals/test.html#sec-system-commands",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.3 System commands",
    "text": "14.3 System commands\nFunctions system and system2 are used to invoke a system command and optionally collect its output. system2 is a little more general but its main advantage is that it is easier to write cross-platform code using it.\nsystem behaves differently on Windows from other OSes (because the API C call of that name does). Elsewhere it invokes a shell to run the command: the Windows port of R has a function shell to do that.\nTo find out if the OS includes a command, use Sys.which, which attempts to do this in a cross-platform way (unfortunately it is not a standard OS service).\nFunction shQuote will quote filepaths as needed for commands in the current OS."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-compression-and-archives",
    "href": "tutorials/R/r-manuals/test.html#sec-compression-and-archives",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.4 Compression and Archives",
    "text": "14.4 Compression and Archives\nRecent versions of R have extensive facilities to read and write compressed files, often transparently. Reading of files in R is to a very large extent done by connections, and the file function which is used to open a connection to a file (or a URL) and is able to identify the compression used from the ‘magic’ header of the file.\nThe type of compression which has been supported for longest is gzip compression, and that remains a good general compromise. Files compressed by the earlier Unix compress utility can also be read, but these are becoming rare. Two other forms of compression, those of the bzip2 and xz utilities are also available. These generally achieve higher rates of compression (depending on the file, much higher) at the expense of slower decompression and much slower compression.\nThere is some confusion between xz and lzma compression (see https://en.wikipedia.org/wiki/Xz and https://en.wikipedia.org/wiki/LZMA): R can read files compressed by most versions of either.\nFile archives are single files which contain a collection of files, the most common ones being ‘tarballs’ and zip files as used to distribute R packages. R can list and unpack both (see functions untar and unzip) and create both (for zip with the help of an external program)."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-b.1-invoking-r-from-the-command-line",
    "href": "tutorials/R/r-manuals/test.html#sec-b.1-invoking-r-from-the-command-line",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.5 B.1 Invoking R from the command line",
    "text": "14.5 B.1 Invoking R from the command line\nWhen working at a command line on UNIX or Windows, the command ‘R’ can be used both for starting the main R program in the form\n\nR [options] [<infile] [>outfile],\n\nor, via the R CMD interface, as a wrapper to various R tools (e.g., for processing files in R documentation format or manipulating add-on packages) which are not intended to be called “directly”.\nAt the Windows command-line, Rterm.exe is preferred to R.\nYou need to ensure that either the environment variable TMPDIR is unset or it points to a valid place to create temporary files and directories.\nMost options control what happens at the beginning and at the end of an R session. The startup mechanism is as follows (see also the on-line help for topic ‘Startup’ for more information, and the section below for some Windows-specific details).\n\nUnless --no-environ was given, R searches for user and site files to process for setting environment variables. The name of the site file is the one pointed to by the environment variable R_ENVIRON; if this is unset, R_HOME/etc/Renviron.site is used (if it exists). The user file is the one pointed to by the environment variable R_ENVIRON_USER if this is set; otherwise, files .Renviron in the current or in the user’s home directory (in that order) are searched for. These files should contain lines of the form ‘name=``value’. (See help(\"Startup\") for a precise description.) Variables you might want to set include R_PAPERSIZE (the default paper size), R_PRINTCMD (the default print command) and R_LIBS (specifies the list of R library trees searched for add-on packages).\nThen R searches for the site-wide startup profile unless the command line option --no-site-file was given. The name of this file is taken from the value of the R_PROFILE environment variable. If that variable is unset, the default R_HOME/etc/Rprofile.site is used if this exists.\nThen, unless --no-init-file was given, R searches for a user profile and sources it. The name of this file is taken from the environment variable R_PROFILE_USER; if unset, a file called .Rprofile in the current directory or in the user’s home directory (in that order) is searched for.\nIt also loads a saved workspace from file .RData in the current directory if there is one (unless --no-restore or --no-restore-data was specified).\nFinally, if a function .First() exists, it is executed. This function (as well as .Last() which is executed at the end of the R session) can be defined in the appropriate startup profiles, or reside in .RData.\n\nIn addition, there are options for controlling the memory available to the R process (see the on-line help for topic ‘Memory’ for more information). Users will not normally need to use these unless they are trying to limit the amount of memory used by R.\nR accepts the following command-line options.\n--help\n-h\n: Print short help message to standard output and exit successfully.\n\n--version\n\nPrint version information to standard output and exit successfully.\n\n--encoding=``enc\n\nSpecify the encoding to be assumed for input from the console or stdin. This needs to be an encoding known to iconv: see its help page. (--encoding ``enc is also accepted.) The input is re-encoded to the locale R is running in and needs to be representable in the latter’s encoding (so e.g. you cannot re-encode Greek text in a French locale unless that locale uses the UTF-8 encoding).\n\nRHOME\n\nPrint the path to the R “home directory” to standard output and exit successfully. Apart from the front-end shell script and the man page, R installation puts everything (executables, packages, etc.) into this directory.\n\n\n--save\n--no-save\n: Control whether data sets should be saved or not at the end of the R session. If neither is given in an interactive session, the user is asked for the desired behavior when ending the session with q(); in non-interactive use one of these must be specified or implied by some other option (see below).\n\n--no-environ\n\nDo not read any user file to set environment variables.\n\n--no-site-file\n\nDo not read the site-wide profile at startup.\n\n--no-init-file\n\nDo not read the user’s profile at startup.\n\n\n--restore\n--no-restore\n--no-restore-data\n: Control whether saved images (file .RData in the directory where R was started) should be restored at startup or not. The default is to restore. (--no-restore implies all the specific --no-restore-* options.)\n\n--no-restore-history\n\nControl whether the history file (normally file .Rhistory in the directory where R was started, but can be set by the environment variable R_HISTFILE) should be restored at startup or not. The default is to restore.\n\n--no-Rconsole\n\n(Windows only) Prevent loading the Rconsole file at startup.\n\n--vanilla\n\nCombine --no-save, --no-environ, --no-site-file, --no-init-file and --no-restore. Under Windows, this also includes --no-Rconsole.\n\n\n-f ``file\n--file=``file\n: (not Rgui.exe) Take input from file: ‘-’ means stdin. Implies --no-save unless --save has been set. On a Unix-alike, shell metacharacters should be avoided in file (but spaces are allowed).\n\n-e ``expression\n\n(not Rgui.exe) Use expression as an input line. One or more -e options can be used, but not together with -f or --file. Implies --no-save unless --save has been set. (There is a limit of 10,000 bytes on the total length of expressions used in this way. Expressions containing spaces or shell metacharacters will need to be quoted.)\n\n--no-readline\n\n(UNIX only) Turn off command-line editing via readline. This is useful when running R from within Emacs using the ESS (“Emacs Speaks Statistics”) package. See Section 17 , for more information. Command-line editing is enabled for default interactive use (see --interactive). This option also affects tilde-expansion: see the help for path.expand.\n\n\n--min-vsize=``N\n--min-nsize=``N\n: For expert use only: set the initial trigger sizes for garbage collection of vector heap (in bytes) and cons cells (number) respectively. Suffix ‘M’ specifies megabytes or millions of cells respectively. The defaults are 6Mb and 350k respectively and can also be set by environment variables R_NSIZE and R_VSIZE.\n\n--max-ppsize=``N\n\nSpecify the maximum size of the pointer protection stack as N locations. This defaults to 10000, but can be increased to allow large and complicated calculations to be done. Currently the maximum value accepted is 100000.\n\n\n--quiet\n--silent\n-q\n: Do not print out the initial copyright and welcome messages.\n\n--no-echo\n\nMake R run as quietly as possible. This option is intended to support programs which use R to compute results for them. It implies --quiet and --no-save.\n\n--interactive\n\n(UNIX only) Assert that R really is being run interactively even if input has been redirected: use if input is from a FIFO or pipe and fed from an interactive program. (The default is to deduce that R is being run interactively if and only if stdin is connected to a terminal or pty.) Using -e, -f or --file asserts non-interactive use even if --interactive is given.\nNote that this does not turn on command-line editing.\n\n--ess\n\n(Windows only) Set Rterm up for use by R-inferior-mode in ESS, including asserting interactive use (without the command-line editor) and no buffering of stdout.\n\n--verbose\n\nPrint more information about progress, and in particular set R’s option verbose to TRUE. R code uses this option to control the printing of diagnostic messages.\n\n\n--debugger=``name\n-d ``name\n: (UNIX only) Run R through debugger name. For most debuggers (the exceptions are valgrind and recent versions of gdb), further command line options are disregarded, and should instead be given when starting the R executable from inside the debugger.\n--gui=``type\n-g ``type\n: (UNIX only) Use type as graphical user interface (note that this also includes interactive graphics). Currently, possible values for type are ‘X11’ (the default) and, provided that ‘Tcl/Tk’ support is available, ‘Tk’. (For back-compatibility, ‘x11’ and ‘tk’ are accepted.)\n\n--arch=``name\n\n(UNIX only) Run the specified sub-architecture.\n\n--args\n\nThis flag does nothing except cause the rest of the command line to be skipped: this can be useful to retrieve values from it with commandArgs(TRUE).\n\n\nNote that input and output can be redirected in the usual way (using ‘<’ and ‘>’), but the line length limit of 4095 bytes still applies. Warning and error messages are sent to the error channel (stderr).\nThe command R CMD allows the invocation of various tools which are useful in conjunction with R, but not intended to be called “directly”. The general form is\nR CMD command args\nwhere command is the name of the tool and args the arguments passed on to it.\nCurrently, the following tools are available.\n\nBATCH\n\nRun R in batch mode. Runs R --restore --save with possibly further options (see ?BATCH).\n\nCOMPILE\n\n(UNIX only) Compile C, C++, Fortran … files for use with R.\n\nSHLIB\n\nBuild shared library for dynamic loading.\n\nINSTALL\n\nInstall add-on packages.\n\nREMOVE\n\nRemove add-on packages.\n\nbuild\n\nBuild (that is, package) add-on packages.\n\ncheck\n\nCheck add-on packages.\n\nLINK\n\n(UNIX only) Front-end for creating executable programs.\n\nRprof\n\nPost-process R profiling files.\n\n\nRdconv\nRd2txt\n: Convert Rd format to various other formats, including HTML, LaTeX, plain text, and extracting the examples. Rd2txt can be used as shorthand for Rd2conv -t txt.\n\nRd2pdf\n\nConvert Rd format to PDF.\n\nStangle\n\nExtract S/R code from Sweave or other vignette documentation\n\nSweave\n\nProcess Sweave or other vignette documentation\n\nRdiff\n\nDiff R output ignoring headers etc\n\nconfig\n\nObtain configuration information\n\njavareconf\n\n(Unix only) Update the Java configuration variables\n\nrtags\n\n(Unix only) Create Emacs-style tag files from C, R, and Rd files\n\nopen\n\n(Windows only) Open a file via Windows’ file associations\n\ntexify\n\n(Windows only) Process (La)TeX files with R’s style files\n\n\nUse\nR CMD command --help\nto obtain usage information for each of the tools accessible via the R CMD interface.\nIn addition, you can use options --arch=, --no-environ, --no-init-file, --no-site-file and --vanilla between R and CMD: these affect any R processes run by the tools. (Here --vanilla is equivalent to --no-environ --no-site-file --no-init-file.) However, note that R CMD does not of itself use any R startup files (in particular, neither user nor site Renviron files), and all of the R processes run by these tools (except BATCH) use --no-restore. Most use --vanilla and so invoke no R startup files: the current exceptions are INSTALL, REMOVE, Sweave and SHLIB (which uses --no-site-file --no-init-file).\nR CMD cmd args\nfor any other executable cmd on the path or given by an absolute filepath: this is useful to have the same environment as R or the specific commands run under, for example to run ldd or pdflatex. Under Windows cmd can be an executable or a batch file, or if it has extension .sh or .pl the appropriate interpreter (if available) is called to run it."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-b.2-invoking-r-under-windows",
    "href": "tutorials/R/r-manuals/test.html#sec-b.2-invoking-r-under-windows",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.6 B.2 Invoking R under Windows",
    "text": "14.6 B.2 Invoking R under Windows\nThere are two ways to run R under Windows. Within a terminal window (e.g. cmd.exe or a more capable shell), the methods described in the previous section may be used, invoking by R.exe or more directly by Rterm.exe. For interactive use, there is a console-based GUI (Rgui.exe).\nThe startup procedure under Windows is very similar to that under UNIX, but references to the ‘home directory’ need to be clarified, as this is not always defined on Windows. If the environment variable R_USER is defined, that gives the home directory. Next, if the environment variable HOME is defined, that gives the home directory. After those two user-controllable settings, R tries to find system defined home directories. It first tries to use the Windows \"personal\" directory (typically My Documents in recent versions of Windows). If that fails, and environment variables HOMEDRIVE and HOMEPATH are defined (and they normally are) these define the home directory. Failing all those, the home directory is taken to be the starting directory.\nYou need to ensure that either the environment variables TMPDIR, TMP and TEMP are either unset or one of them points to a valid place to create temporary files and directories.\nEnvironment variables can be supplied as ‘name=``value’ pairs on the command line.\nIf there is an argument ending .RData (in any case) it is interpreted as the path to the workspace to be restored: it implies --restore and sets the working directory to the parent of the named file. (This mechanism is used for drag-and-drop and file association with RGui.exe, but also works for Rterm.exe. If the named file does not exist it sets the working directory if the parent directory exists.)\nThe following additional command-line options are available when invoking RGui.exe.\n--mdi\n--sdi\n--no-mdi\n: Control whether Rgui will operate as an MDI program (with multiple child windows within one main window) or an SDI application (with multiple top-level windows for the console, graphics and pager). The command-line setting overrides the setting in the user’s Rconsole file.\n\n--debug\n\nEnable the “Break to debugger” menu item in Rgui, and trigger a break to the debugger during command line processing.\n\n\nUnder Windows with R CMD you may also specify your own .bat, .exe, .sh or .pl file. It will be run under the appropriate interpreter (Perl for .pl) with several environment variables set appropriately, including R_HOME, R_OSTYPE, PATH, BSTINPUTS and TEXINPUTS. For example, if you already have latex.exe on your path, then\nR CMD latex.exe mydoc\nwill run LaTeX on mydoc.tex, with the path to R’s share/texmf macros appended to TEXINPUTS. (Unfortunately, this does not help with the MiKTeX build of LaTeX, but R CMD texify mydoc will work in that case.)"
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-b.3-invoking-r-under-macos",
    "href": "tutorials/R/r-manuals/test.html#sec-b.3-invoking-r-under-macos",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.7 B.3 Invoking R under macOS",
    "text": "14.7 B.3 Invoking R under macOS\nThere are two ways to run R under macOS. Within a Terminal.app window by invoking R, the methods described in the first subsection apply. There is also console-based GUI (R.app) that by default is installed in the Applications folder on your system. It is a standard double-clickable macOS application.\nThe startup procedure under macOS is very similar to that under UNIX, but R.app does not make use of command-line arguments. The ‘home directory’ is the one inside the R.framework, but the startup and current working directory are set as the user’s home directory unless a different startup directory is given in the Preferences window accessible from within the GUI."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-b.4-scripting-with-r",
    "href": "tutorials/R/r-manuals/test.html#sec-b.4-scripting-with-r",
    "title": "R Manuals :: An Introduction to R",
    "section": "14.8 B.4 Scripting with R",
    "text": "14.8 B.4 Scripting with R\nIf you just want to run a file foo.R of R commands, the recommended way is to use R CMD BATCH foo.R. If you want to run this in the background or as a batch job use OS-specific facilities to do so: for example in most shells on Unix-alike OSes R CMD BATCH foo.R & runs a background job.\nYou can pass parameters to scripts via additional arguments on the command line: for example (where the exact quoting needed will depend on the shell in use)\nR CMD BATCH \"--args arg1 arg2\" foo.R &\nwill pass arguments to a script which can be retrieved as a character vector by\nargs <- commandArgs(TRUE)\nThis is made simpler by the alternative front-end Rscript, which can be invoked by\nRscript foo.R arg1 arg2\nand this can also be used to write executable script files like (at least on Unix-alikes, and in some Windows shells)\n#! /path/to/Rscript\nargs <- commandArgs(TRUE)\n...\nq(status=<exit status code>)\nIf this is entered into a text file runfoo and this is made executable (by chmod 755 runfoo), it can be invoked for different arguments by\nrunfoo arg1 arg2\nFor further options see help(\"Rscript\"). This writes R output to stdout and stderr, and this can be redirected in the usual way for the shell running the command.\nIf you do not wish to hardcode the path to Rscript but have it in your path (which is normally the case for an installed R except on Windows, but e.g. macOS users may need to add /usr/local/bin to their path), use\n#! /usr/bin/env Rscript\n...\nAt least in Bourne and bash shells, the #! mechanism does not allow extra arguments like #! /usr/bin/env Rscript --vanilla.\nOne thing to consider is what stdin() refers to. It is commonplace to write R scripts with segments like\nchem <- scan(n=24)\n2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20\n5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70\nand stdin() refers to the script file to allow such traditional usage. If you want to refer to the process’s stdin, use \"stdin\" as a file connection, e.g. scan(\"stdin\", ...).\nAnother way to write executable script files (suggested by François Pinard) is to use a here document like\n#!/bin/sh\n[environment variables can be set here]\nR --no-echo [other options] <<EOF\n\n   R program goes here...\n\nEOF\nbut here stdin() refers to the program source and \"stdin\" will not be usable.\nShort scripts can be passed to Rscript on the command-line via the -e flag. (Empty scripts are not accepted.)\nNote that on a Unix-alike the input filename (such as foo.R) should not contain spaces nor shell metacharacters."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-c.1-preliminaries",
    "href": "tutorials/R/r-manuals/test.html#sec-c.1-preliminaries",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.1 Preliminaries",
    "text": "17.1 Preliminaries\nWhen the GNU readline library is available at the time R is configured for compilation under UNIX, an inbuilt command line editor allowing recall, editing and re-submission of prior commands is used. Note that other versions of readline exist and may be used by the inbuilt command line editor: this is most common on macOS. You can find out which version (if any) is available by running extSoftVersion() in an R session.\nIt can be disabled (useful for usage with ESS 25) using the startup option --no-readline.\nWindows versions of R have somewhat simpler command-line editing: see ‘Console’ under the ‘Help’ menu of the GUI, and the file README.Rterm for command-line editing under Rterm.exe.\nWhen using R with GNU26 readline capabilities, the functions described below are available, as well as others (probably) documented in man readline or info readline on your system.\nMany of these use either Control or Meta characters. Control characters, such as Control-m, are obtained by holding the CTRL down while you press the m key, and are written as C-m below. Meta characters, such as Meta-b, are typed by holding down META27 and pressing b, and written as M-b in the following. If your terminal does not have a META key enabled, you can still type Meta characters using two-character sequences starting with ESC. Thus, to enter M-b, you could type ESCb. The ESC character sequences are also allowed on terminals with real Meta keys. Note that case is significant for Meta characters.\nSome but not all versions28 of readline will recognize resizing of the terminal window so this is best avoided."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-c.2-editing-actions",
    "href": "tutorials/R/r-manuals/test.html#sec-c.2-editing-actions",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.2 Editing actions",
    "text": "17.2 Editing actions\nThe R program keeps a history of the command lines you type, including the erroneous lines, and commands in your history may be recalled, changed if necessary, and re-submitted as new commands. In Emacs-style command-line editing any straight typing you do while in this editing phase causes the characters to be inserted in the command you are editing, displacing any characters to the right of the cursor. In vi mode character insertion mode is started by M-i or M-a, characters are typed and insertion mode is finished by typing a further ESC. (The default is Emacs-style, and only that is described here: for vi mode see the readline documentation.)\nPressing the RET command at any time causes the command to be re-submitted.\nOther editing actions are summarized in the following table."
  },
  {
    "objectID": "tutorials/R/r-manuals/test.html#sec-c.3-command-line-editor-summary",
    "href": "tutorials/R/r-manuals/test.html#sec-c.3-command-line-editor-summary",
    "title": "R Manuals :: An Introduction to R",
    "section": "17.3 Command-line editor summary",
    "text": "17.3 Command-line editor summary\n\n17.3.1 Command recall and vertical motion\n\nC-p\n\nGo to the previous command (backwards in the history).\n\nC-n\n\nGo to the next command (forwards in the history).\n\nC-r text\n\nFind the last command with the text string in it. This can be cancelled by C-g (and on some versions of R by C-c).\n\n\nOn most terminals, you can also use the up and down arrow keys instead of C-p and C-n, respectively.\n\n\n17.3.2 Horizontal motion of the cursor\n\nC-a\n\nGo to the beginning of the command.\n\nC-e\n\nGo to the end of the line.\n\nM-b\n\nGo back one word.\n\nM-f\n\nGo forward one word.\n\nC-b\n\nGo back one character.\n\nC-f\n\nGo forward one character.\n\n\nOn most terminals, you can also use the left and right arrow keys instead of C-b and C-f, respectively.\n\n\n17.3.3 Editing and re-submission\n\ntext\n\nInsert text at the cursor.\n\nC-f text\n\nAppend text after the cursor.\n\nDEL\n\nDelete the previous character (left of the cursor).\n\nC-d\n\nDelete the character under the cursor.\n\nM-d\n\nDelete the rest of the word under the cursor, and “save” it.\n\nC-k\n\nDelete from cursor to end of command, and “save” it.\n\nC-y\n\nInsert (yank) the last “saved” text here.\n\nC-t\n\nTranspose the character under the cursor with the next.\n\nM-l\n\nChange the rest of the word to lower case.\n\nM-c\n\nChange the rest of the word to upper case.\n\nRET\n\nRe-submit the command to R.\n\n\nThe final RET terminates the command line editing sequence.\nThe readline key bindings can be customized in the usual way via a ~/.inputrc file. These customizations can be conditioned on application R, that is by including a section like\n$if R\n  \"\\C-xd\": \"q('no')\\n\"\n$endif"
  },
  {
    "objectID": "tutorials/python/index.html",
    "href": "tutorials/python/index.html",
    "title": "python",
    "section": "",
    "text": "Python"
  }
]